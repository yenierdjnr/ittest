{
  "description": "In this series, we cover the basics of using NumPy for basic data analysis. Some of the things that are covered are as follows: installing NumPy using the Anaconda Python distribution, creating NumPy arrays in a variety of ways, gathering information about large datasets such as the mean, median and standard deviation, as well as utilizing Jupyter Notebooks for exploration using NumPy. If you are looking to get started with NumPy then join us!",
  "descriptionMD": "In this series, we cover the basics of using NumPy for basic data analysis. Some of the things that are covered are as follows: installing NumPy using the Anaconda Python distribution, creating NumPy arrays in a variety of ways, gathering information about large datasets such as the mean, median and standard deviation, as well as utilizing Jupyter Notebooks for exploration using NumPy. If you are looking to get started with NumPy then join us!",
  "length": "17527",
  "name": "Intro to NumPy",
  "practiceExam": false,
  "subtitle": "Fast Numbers with Python Ease",
  "tagUrl": "developer",
  "topics": [
    {
      "episodes": [
        {
          "description": "In this series, we cover the basics of using NumPy for basic data analysis. Some of the things that are covered are as follows: installing NumPy using the Anaconda Python distribution, creating NumPy arrays in a variety of ways, gathering information about large datasets such as the mean, median and standard deviation, as well as utilizing Jupyter Notebooks for exploration using NumPy. If you are looking to get started with NumPy then join us!",
          "length": "85",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-0-0-overview-042817-PGM.00_00_03_04.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-0-0-overview-042817-PGM.00_00_03_04.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-0-0-overview-042817-PGM.00_00_03_04.Still001-sm.jpg",
          "title": "Overview",
          "transcript": "",
          "vimeoId": "215994207"
        },
        {
          "description": "In this show, Cherokee and Justin review Python basics and and explain how it relates to NumPy and the Scientific community. They also take a look at a useful tool called Jupyter. Justin demonstrates how to install NumPy and verify the program is functioning properly.",
          "length": "989",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-1-1-scienfific_python_and_setup-042416-PGM.00_16_14_02.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-1-1-scienfific_python_and_setup-042416-PGM.00_16_14_02.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-1-1-scienfific_python_and_setup-042416-PGM.00_16_14_02.Still001-sm.jpg",
          "title": "Scientific Python and Setup",
          "transcript": "",
          "vimeoId": "214849443"
        },
        {
          "description": "In this show, Cherokee and Justin review some NumPy concepts and delve into using Jupyter. Justin explains what we need to know before we get started by providing insightful tips and tricks. He also demonstrates how to manipulate lists us Jupyter.",
          "length": "1767",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-2-1-review_of_basics_jupyter-042417-PGM.00_29_12_18.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-2-1-review_of_basics_jupyter-042417-PGM.00_29_12_18.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-2-1-review_of_basics_jupyter-042417-PGM.00_29_12_18.Still001-sm.jpg",
          "title": "Review of Python Basics with Jupyter",
          "transcript": "",
          "vimeoId": "214850345"
        },
        {
          "description": null,
          "length": "1829",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-3-1-introducing_numpy_arrays-042417-PGM.00_30_13_12.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-3-1-introducing_numpy_arrays-042417-PGM.00_30_13_12.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-3-1-introducing_numpy_arrays-042417-PGM.00_30_13_12.Still001-sm.jpg",
          "title": "Introducing NumPy Arrays",
          "transcript": "",
          "vimeoId": "214851919"
        },
        {
          "description": "In this episode, Peter and Justin dig into arrays and data types within NumPy. They will talk about what data types are available and how to construct arrays using that data, as well as the special considerations needed when working with those data types in NumPy.",
          "length": "1510",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-4-1-numpy_array_and_datatypes-042617-PGM.00_24_55_26.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-4-1-numpy_array_and_datatypes-042617-PGM.00_24_55_26.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-4-1-numpy_array_and_datatypes-042617-PGM.00_24_55_26.Still001-sm.jpg",
          "title": "NumPy Array and Data Types",
          "transcript": "",
          "vimeoId": "215201069"
        },
        {
          "description": "Numpy lets you view your data graphically as well as in its raw format. Justin and Peter show you how to use tools like matplotlib to see the relationships between arrays and provide examples of when this functionality might be useful for you.",
          "length": "1355",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-5-1-graphing_and_visualiation-042517-PGM.00_22_20_27.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-5-1-graphing_and_visualiation-042517-PGM.00_22_20_27.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-5-1-graphing_and_visualiation-042517-PGM.00_22_20_27.Still001-sm.jpg",
          "title": "Graphing and Visualization",
          "transcript": "",
          "vimeoId": "215201297"
        },
        {
          "description": "Indexing and slicing arrays in NumPy can be a very powerful tool in your arsenal. In this episode, Justin and Peter show how to index and slice arrays, including multidimensional arrays, and search or slice for specific conditions. They also cover potential drawbacks and concerns to using these tools.",
          "length": "1138",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-6-1-indexing_and_slicing-arrays-042517-PGM.00_18_43_14.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-6-1-indexing_and_slicing-arrays-042517-PGM.00_18_43_14.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-6-1-indexing_and_slicing-arrays-042517-PGM.00_18_43_14.Still001-sm.jpg",
          "title": "Indexing and Slicing Arrays",
          "transcript": "",
          "vimeoId": "215201511"
        },
        {
          "description": "Views and copies are similar, but each has its own unique benefits and limitations. Justin and Peter show how NumPy handles multiple variables referencing the same underlying data and how to reconcile any issues that may cause.",
          "length": "1207",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-7-1-copies_and_views-042617-PGM.00_19_52_28.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-7-1-copies_and_views-042617-PGM.00_19_52_28.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-7-1-copies_and_views-042617-PGM.00_19_52_28.Still001-sm.jpg",
          "title": "Copies and Views",
          "transcript": "WEBVTT\n\n1\n00:00:00.078 --> 00:00:06.460\nWelcome to ITProTV, I'm your host-\n&gt;&gt; [CROSSTALK]\n\n2\n00:00:06.460 --> 00:00:07.985\n[MUSIC]\n\n3\n00:00:07.985 --> 00:00:12.272\n&gt;&gt; You're watching ITProTV.\n\n4\n00:00:12.272 --> 00:00:14.660\n&gt;&gt; Hello, and welcome to ITProTV.\n\n5\n00:00:14.660 --> 00:00:15.950\nI'm your host, Peter VanRysdam, and\n\n6\n00:00:15.950 --> 00:00:18.190\ntoday we're continuing with\nour introduction to NumPy.\n\n7\n00:00:18.190 --> 00:00:22.770\nAnd specifically in this episode, we're\ngonna be talking about copies and views.\n\n8\n00:00:22.770 --> 00:00:26.340\nAnd here to help us, we have the wind\nbeneath my wings, Justin Dennison.\n\n9\n00:00:26.340 --> 00:00:27.235\nJustin, how are you?\n\n10\n00:00:27.235 --> 00:00:29.350\n&gt;&gt; I am doing well, Peter, and\nexcited to be back in the studio.\n\n11\n00:00:29.350 --> 00:00:30.760\nHow are you today?\n\n12\n00:00:30.760 --> 00:00:31.700\n&gt;&gt; I'm great, thanks for asking.\n\n13\n00:00:31.700 --> 00:00:35.812\nAnd I wanted to start this episode by\nasking you, I know in Python, we can have\n\n14\n00:00:35.812 --> 00:00:40.016\ntwo variables referencing the same data,\nbut that can cause some surprises.\n\n15\n00:00:40.016 --> 00:00:42.970\nIs that something we run\ninto with NumPy as well?\n\n16\n00:00:42.970 --> 00:00:46.304\n&gt;&gt; Unfortunately, it is something\nwe run into with NumPy Well,\n\n17\n00:00:46.304 --> 00:00:50.357\nit's just the nature in how data is\nreferenced using variables in Python.\n\n18\n00:00:50.357 --> 00:00:52.884\nNow, I could talk about this a great deal.\n\n19\n00:00:52.884 --> 00:00:57.284\nBut I think it's a lot easier if we just\ntake a look at what happens in Python and\n\n20\n00:00:57.284 --> 00:00:59.180\nthen what happens with NumPy, so\n\n21\n00:00:59.180 --> 00:01:02.980\nwe can wrap our minds around things\nwe need to be careful about.\n\n22\n00:01:02.980 --> 00:01:05.168\nSo, let's go ahead and\ntake a look at my screen here.\n\n23\n00:01:05.168 --> 00:01:07.218\nI'm on my desktop now,\nI have a bunch of folders.\n\n24\n00:01:07.218 --> 00:01:12.080\nBut I'm gonna make some copies and\nviews folder here.\n\n25\n00:01:12.080 --> 00:01:16.240\nI'm gonna make a, not multiple folders,\nthat's an important distinction there.\n\n26\n00:01:16.240 --> 00:01:19.980\nAnd then I'm gonna start\nup Jupyter Notebook.\n\n27\n00:01:19.980 --> 00:01:24.090\nAnd we should be up and\ngoing here in just a moment, wait for it.\n\n28\n00:01:24.090 --> 00:01:26.880\nAnd, well,\nwe got a little bit of an error there, and\n\n29\n00:01:26.880 --> 00:01:30.170\nthat has to do with my computer,\nnot so much Jupyter Notebook.\n\n30\n00:01:30.170 --> 00:01:34.980\nSo as long as I grab this this tokenized\nlogin, I should be good to go.\n\n31\n00:01:34.980 --> 00:01:36.348\nSo it's all right.\n\n32\n00:01:36.348 --> 00:01:40.055\nIf you do ever experience this,\ntry to navigate,\n\n33\n00:01:40.055 --> 00:01:42.543\nI found that a reboot does fix it.\n\n34\n00:01:42.543 --> 00:01:47.486\nI haven't seen this until recently, so\ndon't worry, if things are still working,\n\n35\n00:01:47.486 --> 00:01:48.662\nyou should be fine.\n\n36\n00:01:48.662 --> 00:01:51.840\nBut reboot, make sure it doesn't persist.\n\n37\n00:01:51.840 --> 00:01:54.760\nIf it does,\nthen reach out to the NumPy team.\n\n38\n00:01:54.760 --> 00:01:57.080\nSo there we go, let's go ahead and\ncreate a notebook.\n\n39\n00:01:58.360 --> 00:01:59.637\nAnd well, not upload a notebook.\n\n40\n00:01:59.637 --> 00:02:04.762\nLet's create a new notebook and\nlet's just call it Playground.\n\n41\n00:02:04.762 --> 00:02:06.310\nI think that's important,\n\n42\n00:02:06.310 --> 00:02:09.800\nbecause the folder kind of gives\nus an idea of what we're doing.\n\n43\n00:02:09.800 --> 00:02:14.400\nSo, let's think about what you asked,\nPeter.\n\n44\n00:02:14.400 --> 00:02:18.502\nWhat happens if I have two variables\nreferencing the same underlying data and\n\n45\n00:02:18.502 --> 00:02:20.590\nsomething changes?.\n\n46\n00:02:20.590 --> 00:02:24.990\nAnd typically it's the certain types of\ndata that this becomes an issue with,\n\n47\n00:02:24.990 --> 00:02:27.310\nbecause of how data is represented.\n\n48\n00:02:27.310 --> 00:02:31.480\nTypically we're gonna see this in complex\ndata structures like dictionaries and\n\n49\n00:02:31.480 --> 00:02:32.580\nlists.\n\n50\n00:02:32.580 --> 00:02:37.170\nWe're gonna use a list here because it\nlooks very similar to a NumPy array.\n\n51\n00:02:37.170 --> 00:02:44.676\nSo I'm going to just say x = [1,\n2, 3] and then, y = x.\n\n52\n00:02:44.676 --> 00:02:47.270\nAnd I should get a reference\nto the same underlying data.\n\n53\n00:02:47.270 --> 00:02:49.400\nLet's see what x is.\n\n54\n00:02:49.400 --> 00:02:51.400\nWell, it is 1, 2, 3.\n\n55\n00:02:51.400 --> 00:02:53.140\nLet's see what y is, it is also 1, 2, 3.\n\n56\n00:02:53.140 --> 00:02:57.910\nNow I'm going to evaluate this cell,\nleave it alone.\n\n57\n00:02:57.910 --> 00:03:02.315\nAt this point though, I'm gonna\nchange the very first element, or\n\n58\n00:03:02.315 --> 00:03:05.650\nthe zero index element,\nof x to 'a', all right?\n\n59\n00:03:05.650 --> 00:03:10.160\nAnd if I look at x,\nit's 'a', 2, 3, now, okay.\n\n60\n00:03:10.160 --> 00:03:15.665\nA lot of times, though, people will\nmake the mistake that, y equals x,\n\n61\n00:03:15.665 --> 00:03:21.380\nI now have a copy of what was assigned by\nx, and let's see if that's still true.\n\n62\n00:03:21.380 --> 00:03:26.570\nWell, it is unfortunately not, because in\norder to save space and memory and make\n\n63\n00:03:26.570 --> 00:03:33.190\nsure things run fluidly, this is not made\ntwice unless you specifically ask for it.\n\n64\n00:03:33.190 --> 00:03:37.579\nIf I wanted the exact\n\n65\n00:03:37.579 --> 00:03:42.960\nsame data, but make a copy,\nI could try to give it a list.\n\n66\n00:03:42.960 --> 00:03:46.130\nSo I give the list\nfunction the value of x.\n\n67\n00:03:46.130 --> 00:03:48.430\nLet's see what happens here.\n\n68\n00:03:48.430 --> 00:03:53.010\nAnd now you can see I have two copies,\nso we have to be careful about that.\n\n69\n00:03:53.010 --> 00:03:58.050\nNow, the downside is, if I make a lot\nof copies, I eat up a lot of memory.\n\n70\n00:03:58.050 --> 00:04:00.900\nAnd I have to make those\ncopies as I'm running, so\n\n71\n00:04:00.900 --> 00:04:02.570\nthere may be a performance hit.\n\n72\n00:04:02.570 --> 00:04:03.990\nSo now, this is regular Python.\n\n73\n00:04:03.990 --> 00:04:05.080\nWhat happens with NumPy?\n\n74\n00:04:05.080 --> 00:04:07.460\nIs the story any different?\n\n75\n00:04:08.470 --> 00:04:13.944\nWell, I'm gonna remove this,\nand say import in NumPy\n\n76\n00:04:13.944 --> 00:04:19.860\nas np, and then just evaluate\nthrough here and get rid of that.\n\n77\n00:04:19.860 --> 00:04:23.172\nAnd make sure I evaluate that cell so\nI actually have NumPy.\n\n78\n00:04:23.172 --> 00:04:29.100\nAnd let's make another x and\nsay arange of up to 3,\n\n79\n00:04:29.100 --> 00:04:34.170\nactually 1 to 3, 1 to 4,\nbecause I have to go over by 1.\n\n80\n00:04:34.170 --> 00:04:38.068\nSo I should have similar to what I\ndid in just the previous example.\n\n81\n00:04:38.068 --> 00:04:40.048\nAnd now I have an array of [1, 2, 3].\n\n82\n00:04:40.048 --> 00:04:47.280\nAll right, well, what if I have y = x,\nand then what is y?\n\n83\n00:04:47.280 --> 00:04:48.950\nWell, it's still 1, 2, 3.\n\n84\n00:04:48.950 --> 00:04:53.918\nAnd now, let's go through\nthe same kind of machinations.\n\n85\n00:04:53.918 --> 00:04:55.260\nDoes the data change?\n\n86\n00:04:55.260 --> 00:04:57.569\nThese are little bit different,\nthese are behind the scenes.\n\n87\n00:04:57.569 --> 00:05:01.910\nThey're C-based things,\nthey're Fortran-based things.\n\n88\n00:05:01.910 --> 00:05:06.737\nNow, I'm using things kind of in\na hand-wavy way because that's not really\n\n89\n00:05:06.737 --> 00:05:10.310\nimportant to us,\nwe're using Python for the ease of it.\n\n90\n00:05:10.310 --> 00:05:15.376\nSo if I say x, it's 1, 2,\n3, but if I go x[0] =, now,\n\n91\n00:05:15.376 --> 00:05:22.310\nI can't do a, because this type, I would\nhave to do some weird type manipulations.\n\n92\n00:05:22.310 --> 00:05:23.300\nI just wanna make sure\nI can change the data.\n\n93\n00:05:23.300 --> 00:05:27.882\nI'm gonna change this to 4,\nsee what's in x, well, that's 4, 2, 3.\n\n94\n00:05:27.882 --> 00:05:32.198\nAnd then, there's y, and\nwe still have the same issue.\n\n95\n00:05:32.198 --> 00:05:37.300\nSo as we can see, that problem still\npersists, even though we are using NumPy.\n\n96\n00:05:37.300 --> 00:05:40.518\n&gt;&gt; And so now that we know that we're\ngoing to experience that again,\n\n97\n00:05:40.518 --> 00:05:43.972\nhow do we reconcile that, or\nat least make sure that we're aware of it?\n\n98\n00:05:43.972 --> 00:05:49.310\n&gt;&gt; So, we have to be very careful,\nbecause what is the purpose of this?\n\n99\n00:05:49.310 --> 00:05:51.426\nIt's to reduce memory consumption.\n\n100\n00:05:51.426 --> 00:05:55.990\nNumPy is not going to create a new\narray if it doesn't have to, right?\n\n101\n00:05:55.990 --> 00:05:57.750\nSo let's take a look.\n\n102\n00:05:57.750 --> 00:06:02.821\nThere's actually a built-in function\nthat will tell you, hey, these things\n\n103\n00:06:02.821 --> 00:06:08.054\nmay share memory, especially if you start\ntaking slices and things of that sort.\n\n104\n00:06:08.054 --> 00:06:11.025\nSo, let's change it up a little bit,\nmake it a little more complex,\n\n105\n00:06:11.025 --> 00:06:12.955\nand see how those things change.\n\n106\n00:06:12.955 --> 00:06:20.440\nI'm actually gonna make this 1 to 101 and\nremove these.\n\n107\n00:06:20.440 --> 00:06:24.650\nAnd there we go, just as a clean slate.\n\n108\n00:06:24.650 --> 00:06:27.642\nI have a whole lot of clean slates,\napparently.\n\n109\n00:06:27.642 --> 00:06:29.910\nYou gotta be careful there, the x key,\n\n110\n00:06:29.910 --> 00:06:34.500\nwhen not in cursor form, actually\ndeletes a cell, and that was my fault.\n\n111\n00:06:34.500 --> 00:06:38.270\nSo, 1 to 101, and what is x?\n\n112\n00:06:38.270 --> 00:06:40.970\nWell, it's the array from 1 to 100.\n\n113\n00:06:40.970 --> 00:06:43.270\nAll right, so this is fairly large.\n\n114\n00:06:43.270 --> 00:06:45.650\nThis could be a million elements.\n\n115\n00:06:45.650 --> 00:06:47.780\nIt could take up a bunch of RAM.\n\n116\n00:06:47.780 --> 00:06:51.320\nNow, like I said before in previous\nepisodes, I'm not saying I have, but\n\n117\n00:06:51.320 --> 00:06:56.080\nI have heard of people accidentally\nputting too many NumPy arrays in memory,\n\n118\n00:06:56.080 --> 00:06:58.460\nlocking up their computer,\nand it's just a bad day.\n\n119\n00:06:59.770 --> 00:07:03.060\nActually, I'm gonna confess,\nthat was me, but that's okay.\n\n120\n00:07:03.060 --> 00:07:08.410\nSo, NumPy tries to help you, but you need\nto be aware of things that you do that\n\n121\n00:07:08.410 --> 00:07:13.850\nwill force it to make a copy of that\ndata instead of using what is a view.\n\n122\n00:07:13.850 --> 00:07:19.560\nSo the underlying data in memory is just\npresented to you as a different type,\n\n123\n00:07:19.560 --> 00:07:22.340\nor a different section.\n\n124\n00:07:22.340 --> 00:07:25.986\nSo, if I say y, and\ninstead of saying y = x,\n\n125\n00:07:25.986 --> 00:07:31.529\nI'm actually gonna say y = x[1:10],\nI'm taking a slice.\n\n126\n00:07:31.529 --> 00:07:34.900\nNow, we saw in a previous episode that\nwe could take a slice of this array.\n\n127\n00:07:34.900 --> 00:07:37.550\nAnd if we look at x,\nthat's still 1 to 100.\n\n128\n00:07:37.550 --> 00:07:42.831\nWe look at y, it's 2 to 10,\ncuz I took that slice from 1 to 10,\n\n129\n00:07:42.831 --> 00:07:47.405\nbecause I started at 1 and\nit ends up being these numbers.\n\n130\n00:07:47.405 --> 00:07:51.400\nAnd we would say, well,\nthese are different now.\n\n131\n00:07:51.400 --> 00:07:53.841\nI got a new copy of this back.\n\n132\n00:07:53.841 --> 00:07:57.009\nWell, let's see if that's the case,\n\n133\n00:07:57.009 --> 00:08:01.713\nand we can test that by modifying\nx In those same ranges, so\n\n134\n00:08:01.713 --> 00:08:05.380\nI'm just gonna go x[5] = 10,000.\n\n135\n00:08:05.380 --> 00:08:11.730\nAnd if I look at x, well x has changed,\nif I look at y, y has also changed.\n\n136\n00:08:11.730 --> 00:08:16.240\nSo, that's kinda odd,\nI mean we saw that but\n\n137\n00:08:16.240 --> 00:08:19.120\nI took a slice and wasn't what I expected.\n\n138\n00:08:19.120 --> 00:08:24.150\nHow could I make sure,\nthat I have a new copy if I need it or\n\n139\n00:08:24.150 --> 00:08:28.270\nif I need to be careful about\nsharing data underlying.\n\n140\n00:08:28.270 --> 00:08:33.182\nCuz what the real trouble comes into play\nis if you're doing a great deal of array\n\n141\n00:08:33.182 --> 00:08:34.296\nmanipulations.\n\n142\n00:08:34.296 --> 00:08:39.430\nAnd you're not prepared for possible data\nchanges that happen out from under you.\n\n143\n00:08:39.430 --> 00:08:41.860\nYou can end up with\nvery poor calculations.\n\n144\n00:08:41.860 --> 00:08:46.490\nAnd if it's a critical thing like\nmission to Mars, that could be an issue.\n\n145\n00:08:46.490 --> 00:08:51.650\nNow I'm not saying that they use NumPy\nto do calculations for space missions,\n\n146\n00:08:51.650 --> 00:08:54.030\nbut to give some context there.\n\n147\n00:08:55.030 --> 00:08:59.260\nSo NumPy brings in, or\ngives you a function that lets you know,\n\n148\n00:08:59.260 --> 00:09:02.770\nhey, are underlying, are these shared?\n\n149\n00:09:02.770 --> 00:09:08.330\nWell, let's see, it is may_share_memory,\nmay_share_memory.\n\n150\n00:09:08.330 --> 00:09:12.760\nAnd that means underneath in the RAM,\nthis information and\n\n151\n00:09:12.760 --> 00:09:15.250\nthis information may be\nstored in the same place.\n\n152\n00:09:15.250 --> 00:09:21.200\nIt's not making those NumPy ints again,\nagain just to save memory.\n\n153\n00:09:21.200 --> 00:09:24.340\nAnd you can say do x and y share memory.\n\n154\n00:09:24.340 --> 00:09:27.330\nWell, if they do it'll return true, so\n\n155\n00:09:27.330 --> 00:09:31.140\nwe can see here that slices,\nthey don't give us a copy of that data.\n\n156\n00:09:31.140 --> 00:09:34.707\nThey instead return a view, a NumPy view.\n\n157\n00:09:34.707 --> 00:09:39.520\nNow that's kind of a weird terminology,\nwhat does a view actually mean?\n\n158\n00:09:39.520 --> 00:09:43.374\nAnd the best place to read about this is,\nwell, the NumPy official documentation.\n\n159\n00:09:43.374 --> 00:09:47.954\nNumPy documentation view, and\n\n160\n00:09:47.954 --> 00:09:52.840\nI just wanna look at NumPy views.\n\n161\n00:09:52.840 --> 00:09:57.680\nViews versus copies, NumPy arrays,\nsubclassing ndarray.\n\n162\n00:09:57.680 --> 00:10:00.120\nSo I'm gonna take a look here\n\n163\n00:10:00.120 --> 00:10:03.620\nbecause there's this little\nsection called view casting.\n\n164\n00:10:03.620 --> 00:10:07.940\nAnd what does that mean, view casting is\nthe standard ndarray mechanism by which\n\n165\n00:10:07.940 --> 00:10:11.320\nyou take an ndarray and\nthen return a view.\n\n166\n00:10:11.320 --> 00:10:16.320\nOkay, so what is a view, let's go back and\ndo an additional search,\n\n167\n00:10:16.320 --> 00:10:17.796\na NumPy reference.\n\n168\n00:10:17.796 --> 00:10:21.981\nAnd let's look at views,\nthere is nothing on that page.\n\n169\n00:10:21.981 --> 00:10:25.491\nBut if I come to the SciPy cookbook,\n\n170\n00:10:25.491 --> 00:10:31.936\nthis is a supplementary thing,\na views, what is a view in NumPy?\n\n171\n00:10:31.936 --> 00:10:35.788\nIt is simply another way of viewing the\nsame data, so we are not making a copy,\n\n172\n00:10:35.788 --> 00:10:38.312\nwe're just giving\na different representation.\n\n173\n00:10:38.312 --> 00:10:40.720\nAll right, so that data has not changed,\n\n174\n00:10:40.720 --> 00:10:43.700\nit's not copied,\nit's just presented differently.\n\n175\n00:10:43.700 --> 00:10:47.537\nWell, if that's the case,\nwhat if I made a slice and\n\n176\n00:10:47.537 --> 00:10:50.687\nchanged the type, does that force a copy?\n\n177\n00:10:50.687 --> 00:10:57.168\nInstead of just presenting a view like y,\ninstead of y being a standard slice,\n\n178\n00:10:57.168 --> 00:11:01.991\nwhat if I say astype(np.float)and\nI run back through.\n\n179\n00:11:01.991 --> 00:11:06.810\nNotice these arrays now look different,\ndo they still share memory?\n\n180\n00:11:08.010 --> 00:11:10.980\nNo, they don't because,\nwell, they've changed type.\n\n181\n00:11:10.980 --> 00:11:13.790\nAnd with a slice and type change,\nthat can be different.\n\n182\n00:11:13.790 --> 00:11:15.750\nThat is not always the case though.\n\n183\n00:11:15.750 --> 00:11:20.320\nSo that's why I'm sharing with you\nthe may_share_memory function.\n\n184\n00:11:20.320 --> 00:11:23.810\nBecause it's gonna help you know,\nhey, am I changing this?\n\n185\n00:11:23.810 --> 00:11:26.790\nAre they separate or are they the same?\n\n186\n00:11:28.220 --> 00:11:30.400\nSo may_share_memory is very helpful.\n\n187\n00:11:30.400 --> 00:11:33.670\nNow what are some things\nthat calls copies?\n\n188\n00:11:33.670 --> 00:11:38.985\nWell we found out the slices, but\na slice and an astype change, right?\n\n189\n00:11:38.985 --> 00:11:43.730\nWell, np.float,\nthose are different from ints.\n\n190\n00:11:43.730 --> 00:11:49.333\nWhat was the type of x,\nso, dtype, it is int64.\n\n191\n00:11:49.333 --> 00:11:55.130\nWhat if I went to int32, does that change\nif I take a slice and go to int32?\n\n192\n00:11:55.130 --> 00:11:56.780\nWell, there's int32 and it\n\n193\n00:11:58.970 --> 00:12:04.180\nstill changes over because there's\ndifferent memory restrictions for those.\n\n194\n00:12:04.180 --> 00:12:09.085\nSo we have to be careful there, and astype\nwith a slice can make those changes.\n\n195\n00:12:09.085 --> 00:12:13.032\nBut a slice alone will not necessarily\nmake those changes as well.\n\n196\n00:12:13.032 --> 00:12:15.426\nNow we're gonna dive\nforward a little bit for\n\n197\n00:12:15.426 --> 00:12:17.694\nsomething that we haven't talked about.\n\n198\n00:12:17.694 --> 00:12:22.490\nAnd that's modifying the shape for\nmultidimensional arrays.\n\n199\n00:12:22.490 --> 00:12:26.966\nIf I have a three by three matrix,\nor three by three array.\n\n200\n00:12:26.966 --> 00:12:31.240\nWell, what are some things that can\ncause copies versus views there.\n\n201\n00:12:32.640 --> 00:12:36.650\nSo if we take a look back at my\nscreen here, now I'm going to change.\n\n202\n00:12:36.650 --> 00:12:39.028\nThis has 100 elements,\nI'm going to use reshape.\n\n203\n00:12:39.028 --> 00:12:42.819\nAnd we'll talk in the future\nabout what this does.\n\n204\n00:12:42.819 --> 00:12:47.750\nA little more depth than we are here and\nI'm just gonna say 10, 10, all right?\n\n205\n00:12:47.750 --> 00:12:51.280\nAnd then well what is x at that point.\n\n206\n00:12:51.280 --> 00:12:58.060\nWell it looks like it's a 10 by 10 square\narray, right, 10 rows of 10 columns.\n\n207\n00:12:58.060 --> 00:13:01.974\nAnd if I look at the shape and\nis in fact that but\n\n208\n00:13:01.974 --> 00:13:05.077\nif all the numbers are still there.\n\n209\n00:13:05.077 --> 00:13:10.762\nWhat now if I take a slice of x, 1:10,\n\n210\n00:13:10.762 --> 00:13:15.315\nand also I just want all of those.\n\n211\n00:13:15.315 --> 00:13:18.949\nSo I can use that colon there\nto retrieve everything for\n\n212\n00:13:18.949 --> 00:13:21.260\nthat second dimension all right.\n\n213\n00:13:21.260 --> 00:13:25.620\nSo everything else is gonna stay the same,\njust gonna evaluate.\n\n214\n00:13:25.620 --> 00:13:32.650\nAnd well y is 11200 in a semi-square\nmatrix, it's not quite.\n\n215\n00:13:32.650 --> 00:13:36.652\nAnd then does it share memory,\nit in fact does.\n\n216\n00:13:36.652 --> 00:13:38.570\nBecause well I've just taken a slice,\n\n217\n00:13:38.570 --> 00:13:42.010\nbut if I change the type I would\nexperience something similar to that.\n\n218\n00:13:43.060 --> 00:13:48.587\nHowever, what happens if I now\nreshape this from 10 by 10,\n\n219\n00:13:48.587 --> 00:13:52.146\nto instead, I don't know, 5 by 20?\n\n220\n00:13:52.146 --> 00:13:56.662\nRight, that's still 100 elements,\nand so I'm gonna say reshape(5,\n\n221\n00:13:56.662 --> 00:14:00.460\n20), and\nlet's make sure that I did that correctly.\n\n222\n00:14:00.460 --> 00:14:03.300\nAnd it looks like I did,\ngonna get rid of that there.\n\n223\n00:14:04.850 --> 00:14:09.453\nAnd y, well it's a little different,\nit's still the same information.\n\n224\n00:14:09.453 --> 00:14:11.532\nDo they share memory, and they still do.\n\n225\n00:14:11.532 --> 00:14:16.763\nSo even changing how the data\nis represented dimensionally.\n\n226\n00:14:16.763 --> 00:14:18.078\nWell that doesn't trigger a view.\n\n227\n00:14:18.078 --> 00:14:22.176\nThere's one final thing though,\nwhat if I switch the order?\n\n228\n00:14:22.176 --> 00:14:26.240\nLike I kinda take this matrix and\nspin it around.\n\n229\n00:14:26.240 --> 00:14:33.230\nAnd that's called the transpose,\nwell what if I transpose x.\n\n230\n00:14:33.230 --> 00:14:38.990\nSo I take the transpose, so notice it\nkind of flips it around 90 degrees.\n\n231\n00:14:38.990 --> 00:14:41.430\nRows become columns, columns become rows.\n\n232\n00:14:41.430 --> 00:14:45.070\nNow if you're you're like,\nwhy would I ever use that,\n\n233\n00:14:45.070 --> 00:14:46.230\nit's kind of outside the scope.\n\n234\n00:14:46.230 --> 00:14:51.560\nWe're just trying to make sure that we\ndon't have any issues crop up when we're\n\n235\n00:14:51.560 --> 00:14:52.910\ndoing data analysis.\n\n236\n00:14:52.910 --> 00:14:57.380\nThat becomes, you're like, I'm sharing\nthis memory, but then you're not.\n\n237\n00:14:57.380 --> 00:15:00.510\nOr you do not assume you're\nsharing memory and you are, and\n\n238\n00:15:00.510 --> 00:15:02.470\nthen something changes out from under you.\n\n239\n00:15:02.470 --> 00:15:06.776\nSo do they share, and they still do,\nso even flipping things around,\n\n240\n00:15:06.776 --> 00:15:10.390\nthat doesn't change anything.\n\n241\n00:15:10.390 --> 00:15:14.161\nReally the biggest issue\nis changing data types,\n\n242\n00:15:14.161 --> 00:15:18.219\nI can force a copy though if\nI want them to be separate.\n\n243\n00:15:18.219 --> 00:15:22.976\nI can force a copy by saying copy, and\n\n244\n00:15:22.976 --> 00:15:27.130\nthen notice .copy is a method.\n\n245\n00:15:27.130 --> 00:15:31.650\nNow I'm gonna remove this transpose\njust because that's a little much.\n\n246\n00:15:31.650 --> 00:15:38.200\nAnd I'm actually gonna even remove\nthe reshape, it's exact same.\n\n247\n00:15:38.200 --> 00:15:39.860\nDoes it share memory, it doesn't.\n\n248\n00:15:39.860 --> 00:15:44.580\nAnd what I've done is ask NumPy,\nhey I need a separate copy of this.\n\n249\n00:15:44.580 --> 00:15:48.069\nCan you make that copy for\nme, so you can impose that.\n\n250\n00:15:48.069 --> 00:15:51.443\nYou just need to be really careful\nwith a shared memory or not.\n\n251\n00:15:51.443 --> 00:15:55.288\nBecause if you're doing data analysis and\nyou're doing matrix manipulations or\n\n252\n00:15:55.288 --> 00:15:56.410\narray manipulations.\n\n253\n00:15:56.410 --> 00:15:59.190\nAnd data changes and\nyou're not expecting it.\n\n254\n00:15:59.190 --> 00:16:00.872\nWell, you can definitely\nrun into some issues.\n\n255\n00:16:00.872 --> 00:16:04.584\n&gt;&gt; All right, so, Justin,\nother than what we just saw here,\n\n256\n00:16:04.584 --> 00:16:09.320\nare there any other ways that having\na view or copy are gonna affect us?\n\n257\n00:16:09.320 --> 00:16:14.540\n&gt;&gt; So, well, having data exchange\nout from under us, that is an issue.\n\n258\n00:16:14.540 --> 00:16:17.740\nBecause it can affect analytics,\nespecially if they're key analytics.\n\n259\n00:16:17.740 --> 00:16:21.840\nBut the real takeaway here is,\nunless you need a copy,\n\n260\n00:16:21.840 --> 00:16:26.500\nthere may be a significant performance hit\nif you make a copy and do not need it.\n\n261\n00:16:26.500 --> 00:16:30.210\nNow, let's just re-phrase that,\nif I do not\n\n262\n00:16:30.210 --> 00:16:34.830\nneed additional copies of that\ninformation, I should not make them.\n\n263\n00:16:34.830 --> 00:16:40.430\nI should use views only, because, well,\nthat keeps things fast, I use less memory.\n\n264\n00:16:40.430 --> 00:16:44.160\nAnd usually modifying existing data,\nin place,\n\n265\n00:16:44.160 --> 00:16:48.540\nis going to be faster, sometimes an order\nof magnitudes, so ten times faster.\n\n266\n00:16:48.540 --> 00:16:52.950\nAnd if you're calculating terabytes of\ndata that could be the difference between\n\n267\n00:16:52.950 --> 00:16:56.620\na day and well, about ten days, right?\n\n268\n00:16:56.620 --> 00:17:01.250\nSo you definitely need to consider\nthe performance characteristics.\n\n269\n00:17:01.250 --> 00:17:05.220\nUse a view unless you absolutely need to\nmake a copy and keep two separate pieces.\n\n270\n00:17:05.220 --> 00:17:10.270\nBecause if you're making copies it\ncould be slower and it could eat up all\n\n271\n00:17:10.270 --> 00:17:14.690\nthe memory in your computer, shut it down,\nlock it up, it's a bad day for everybody.\n\n272\n00:17:14.690 --> 00:17:18.860\n&gt;&gt; All right Justin, looks like that's\neverything with copies and views, right?\n\n273\n00:17:20.070 --> 00:17:23.170\n&gt;&gt; Peter,\nactually I just remembered something.\n\n274\n00:17:23.170 --> 00:17:26.040\nFancy indexing and\nusing different types of indexing.\n\n275\n00:17:26.040 --> 00:17:27.670\nBut slices, right?\n\n276\n00:17:27.670 --> 00:17:29.119\nWe may share memory but\n\n277\n00:17:29.119 --> 00:17:33.319\nwhat about this fancy indexing\nthat we saw in a previous episode?\n\n278\n00:17:33.319 --> 00:17:35.510\nSo, let's go ahead and\ncheck that out, and see.\n\n279\n00:17:35.510 --> 00:17:38.590\nThis fancy indexing,\nour using indices, arrays of indices,\n\n280\n00:17:38.590 --> 00:17:41.860\ndoes that change whether\nwe share memory or not?\n\n281\n00:17:41.860 --> 00:17:43.820\nSo, let's get rid of this copy.\n\n282\n00:17:43.820 --> 00:17:48.100\nAnd now, assign y equal to, well,\nI'm just gonna grab all of x,\n\n283\n00:17:48.100 --> 00:17:51.380\nwhere x is less than 10, all right?\n\n284\n00:17:51.380 --> 00:17:52.695\nSo what is y?\n\n285\n00:17:52.695 --> 00:17:57.326\nThat's a 1 through 9 because well,\nwhat is x and just as a reminder,\n\n286\n00:17:57.326 --> 00:18:02.680\nwe have 1 through 100 and the only part\nthat is less than 10 is 1 through 9.\n\n287\n00:18:02.680 --> 00:18:05.360\nDo those share memory?\n\n288\n00:18:07.310 --> 00:18:09.340\nDrumroll, and they do not.\n\n289\n00:18:09.340 --> 00:18:14.399\nSo fancy indexing actually calls a copy\nand if you're remembering in the indexing\n\n290\n00:18:14.399 --> 00:18:19.543\nepisode I talk about possible performance\nhits whenever you're using indexing.\n\n291\n00:18:19.543 --> 00:18:24.477\nAnd that's because some of these indexing\nrules can require you to copy over to new\n\n292\n00:18:24.477 --> 00:18:28.310\nmemory locations, which are,\nwell, they're a hit.\n\n293\n00:18:28.310 --> 00:18:31.400\nA hit, goodness.\n\n294\n00:18:31.400 --> 00:18:33.570\nSo, they're a performance hit so to speak.\n\n295\n00:18:33.570 --> 00:18:36.310\nSo this is using kind of\nthis boolean mask, right?\n\n296\n00:18:37.400 --> 00:18:44.256\nWhat about if I just pass in, well,\nan array of I want the 1st, 2nd, and 3rd.\n\n297\n00:18:44.256 --> 00:18:48.810\nNow these are indices that I would pull\n\n298\n00:18:48.810 --> 00:18:52.140\nout of another array\nusing various selectors.\n\n299\n00:18:52.140 --> 00:18:57.757\nI can do this and maybe this is one of\nthose things that are nuanced details\n\n300\n00:18:57.757 --> 00:19:03.850\nthat you miss but what happens now is\nwell, I have y that's 11 through 40.\n\n301\n00:19:03.850 --> 00:19:04.380\nWhy is that?\n\n302\n00:19:04.380 --> 00:19:08.420\nBecause that's the row index and\ndo those share memory?\n\n303\n00:19:08.420 --> 00:19:12.760\nNo they do not, so\nthese fancy indexing techniques can\n\n304\n00:19:12.760 --> 00:19:17.210\ncause copies that we may not be ready\nto handle with our performance.\n\n305\n00:19:17.210 --> 00:19:20.140\n&gt;&gt; I can't believe you missed that\nbefore but thank you for covering that.\n\n306\n00:19:20.140 --> 00:19:22.860\nSo now have we covered copies and views?\n\n307\n00:19:22.860 --> 00:19:23.800\n&gt;&gt; I think we're good.\n\n308\n00:19:23.800 --> 00:19:27.070\nWe may still see some additional\nthings crop up here and there.\n\n309\n00:19:27.070 --> 00:19:31.670\nJust keep it in mind as\nwe're engaging in NumPy\n\n310\n00:19:31.670 --> 00:19:35.960\ngoodness that you shouldn't have copies\nunless you absolutely need them.\n\n311\n00:19:35.960 --> 00:19:36.480\n&gt;&gt; Sounds good.\n\n312\n00:19:36.480 --> 00:19:39.930\nAll right, I think that's probably\na good spot to go ahead and sign off for\n\n313\n00:19:39.930 --> 00:19:40.660\nthis episode.\n\n314\n00:19:40.660 --> 00:19:42.010\nSo we're gonna go and wrap that up.\n\n315\n00:19:42.010 --> 00:19:44.950\nGot a lot more great NumPy content\ncoming your way as well, though,\n\n316\n00:19:44.950 --> 00:19:47.260\nso be sure to check that stuff out.\n\n317\n00:19:47.260 --> 00:19:50.960\nBut for now, signing off for ITPro.TV,\nI've been your host Peter VanRysdam.\n\n318\n00:19:50.960 --> 00:19:52.100\n&gt;&gt; And I'm Justin Dennison.\n\n319\n00:19:52.100 --> 00:19:59.978\n&gt;&gt; And we will see you next time.\n\n320\n00:19:59.978 --> 00:20:00.479\n[MUSIC]\n\n321\n00:20:00.479 --> 00:20:03.845\nThank you for watching ITPro.TV.\n\n",
          "vimeoId": "215009580"
        },
        {
          "description": "In this episode, Peter and Justin dive deeper into working with arrays to see what happens when you add two together. They will also cover working with scalar and multiple arrays of different sizes.",
          "length": "1248",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-8-1-elementwise_and_broadcasting_operations-042617-high.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-8-1-elementwise_and_broadcasting_operations-042617-high-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-8-1-elementwise_and_broadcasting_operations-042617-high-sm.jpg",
          "title": "Elementwise and Broadcasting Operations",
          "transcript": "",
          "vimeoId": "215201679"
        },
        {
          "description": "Arrays can get unruly, so Justin and Peter use this episode to highlight some of the ways to reduce their complexity, including multidimensional arrays. Justin also shows off some shortcuts to help reduce some of the more cumbersome repetitive commands required.",
          "length": "1177",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-9-1-reduction_operations-042617-PGM.00_19_22_27.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-9-1-reduction_operations-042617-PGM.00_19_22_27.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-9-1-reduction_operations-042617-PGM.00_19_22_27.Still001-sm.jpg",
          "title": "Reduction Operations",
          "transcript": "",
          "vimeoId": "215201833"
        },
        {
          "description": "NumPy lets you easily reshape or restructure arrays. In this episode, Justin and Peter review how to carry out those operations and discuss the limitations when using the transpose functionality in NumPy.",
          "length": "1724",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-10-1-shape_and_sort_operations-042717-PGM.00_34_40_19.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-10-1-shape_and_sort_operations-042717-PGM.00_34_40_19.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-10-1-shape_and_sort_operations-042717-PGM.00_34_40_19.Still001-sm.jpg",
          "title": "Shape and Sort Operations",
          "transcript": "",
          "vimeoId": "215993760"
        },
        {
          "description": "In this episode, Justin and Peter look back at data types to determine if there are times when operating through broadcast or operations that an array's data type will remain unchanged. They also show when it would be helpful to create your own custom data types.",
          "length": "1092",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-11-1-data_types_casting_size_and_structure-042717-PGM.00_17_58_07.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-11-1-data_types_casting_size_and_structure-042717-PGM.00_17_58_07.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-11-1-data_types_casting_size_and_structure-042717-PGM.00_17_58_07.Still001-sm.jpg",
          "title": "Data Types: Casting, Size, and Structure",
          "transcript": "",
          "vimeoId": "215993961"
        },
        {
          "description": "In this episode, Justin and Peter will explain what structured arrays are and why you want them in your project. They'll also review the upsides beyond the obvious organizational ones, as well as any potential downsides to using structured arrays.",
          "length": "1032",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-12-1-structured_arrays-042717.00_16_59_23.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-12-1-structured_arrays-042717.00_16_59_23.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-12-1-structured_arrays-042717.00_16_59_23.Still001-sm.jpg",
          "title": "Structured Arrays",
          "transcript": "",
          "vimeoId": "215653529"
        },
        {
          "description": "In this show, Cherokee and Justin build on previous topics covered in this series. They take a look at a possible use case of data analysis, linspace functions, and fig and ax variables. Tune in now to watch Justin demonstrate these skills to perform analysis and more.",
          "length": "1374",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-13-1-lets_try_it_time_series_analysis-042817-PGM.00_22_38_14.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-13-1-lets_try_it_time_series_analysis-042817-PGM.00_22_38_14.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-introtonumpy/techskills-introtonumpy-13-1-lets_try_it_time_series_analysis-042817-PGM.00_22_38_14.Still001-sm.jpg",
          "title": "Let's Try It: Image Manipulation",
          "transcript": "",
          "vimeoId": "215994111"
        }
      ],
      "title": "NumPy"
    }
  ],
  "url": "numpy",
  "vLab": false
}
