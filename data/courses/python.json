{
  "description": "Having the correct tool for the job is a great way to be productive. If you find yourself keeping writing similar bits of code over and over again when programming in Python, then Python may already have the tool that you need to make your code more readable, more maintainable, and possible faster or memory efficient. Python has an extensive set of modules that are part of the standard library. If you want to know more about the power built into the Python Standard Library, then stay tuned!",
  "descriptionMD": "Having the correct tool for the job is a great way to be productive. If you find yourself keeping writing similar bits of code over and over again when programming in Python, then Python may already have the tool that you need to make your code more readable, more maintainable, and possible faster or memory efficient. Python has an extensive set of modules that are part of the standard library. If you want to know more about the power built into the Python Standard Library, then stay tuned!",
  "length": "18712",
  "name": "Dive into the Python Standard Library",
  "practiceExam": false,
  "subtitle": "All the tools you didn't know you already had",
  "tagUrl": "developer",
  "topics": [
    {
      "episodes": [
        {
          "description": "In this episode, Justin demonstrates the power of the glob module. This is part of the Python Standard Library. This module uses patterns to create a list, or iterator, of files and folders for iterating over providing a way to select files that satisfy a construct just like you would in Bash.",
          "length": "688",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-1-1-the_glob_module-032817-PGM.00_00_03_01.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-1-1-the_glob_module-032817-PGM.00_00_03_01.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-1-1-the_glob_module-032817-PGM.00_00_03_01.Still001-sm.jpg",
          "title": "the glob Module",
          "transcript": "",
          "vimeoId": "212583590"
        },
        {
          "description": "In this episode, Justin demonstrates the infinite iterators that are available in the itertools modules. These tools allow for the repeated consumption of values from it. Additionally, he outlines some potential 'gotchas' that you may experience.",
          "length": "669",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-1-the_itertools_modules_infinite_iterators-032817-PGM.00_11_04_03.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-1-the_itertools_modules_combinatronics-032817-PGM.00_10_10_00.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-1-the_itertools_modules_combinatronics-032817-PGM.00_10_10_00.Still001-sm.jpg",
          "title": "The itertools Module: Infinite Iterations",
          "transcript": "WEBVTT\n\n1\n00:00:00.025 --> 00:00:07.047\n[SOUND] Greetings everyone, welcome to\nanother exciting episode of ITProTV.\n\n2\n00:00:07.047 --> 00:00:09.138\nI'm Justin Dennison,\nand in today's episode,\n\n3\n00:00:09.138 --> 00:00:11.820\nwe're gonna start diving\ninto the itertools module.\n\n4\n00:00:11.820 --> 00:00:14.980\nIn particular, we're gonna be looking at\nthe infinite iterators that come out of\n\n5\n00:00:14.980 --> 00:00:16.390\nthe itertools module.\n\n6\n00:00:16.390 --> 00:00:18.650\nNow why would I care about\nthe itertools module?\n\n7\n00:00:18.650 --> 00:00:21.182\nWell, the standard library\nis incredibly powerful.\n\n8\n00:00:21.182 --> 00:00:22.564\nAnd you should always make use of it.\n\n9\n00:00:22.564 --> 00:00:26.210\nSo the itertools module provides\nus with a way of, well,\n\n10\n00:00:26.210 --> 00:00:29.290\nactually iterating through\nvarious collections and\n\n11\n00:00:29.290 --> 00:00:32.910\nproviding us helper methods\nthat just make those easier.\n\n12\n00:00:32.910 --> 00:00:36.736\nSo let's go ahead and take a look here at\nsome of these wonderful tools that make,\n\n13\n00:00:36.736 --> 00:00:40.244\nwell, they make my life a lot easier,\nhopefully they do yours, as well.\n\n14\n00:00:40.244 --> 00:00:43.617\nSo let's go ahead and\nhop into a REPL, I'm in Python 3.\n\n15\n00:00:43.617 --> 00:00:45.949\nAnd then I'm gonna say from itertools,\n\n16\n00:00:45.949 --> 00:00:48.974\nI'm just gonna import\neverything from itertools.\n\n17\n00:00:48.974 --> 00:00:51.710\nAnd then we'll talk about them,\nhow they come along.\n\n18\n00:00:51.710 --> 00:00:54.450\nSo the first one we're gonna\nlook at is called count.\n\n19\n00:00:54.450 --> 00:00:57.090\nNow it's kind of a weird term because,\nwell,\n\n20\n00:00:57.090 --> 00:00:58.910\nyou would think that it counts something.\n\n21\n00:00:58.910 --> 00:01:03.580\nBut in fact, it starts counting numbers,\nand it never ends.\n\n22\n00:01:03.580 --> 00:01:06.433\nWell, it's actually a generator,\nso let's take a look at count.\n\n23\n00:01:06.433 --> 00:01:10.190\nAnd if I say count,\nnotice it says count(0).\n\n24\n00:01:10.190 --> 00:01:11.190\nWhy does it do that?\n\n25\n00:01:11.190 --> 00:01:13.970\nBecause by default, count starts at 0.\n\n26\n00:01:13.970 --> 00:01:17.880\nAnd this is great if you need to graph or\nkeep an index of something.\n\n27\n00:01:17.880 --> 00:01:19.860\nAnd well, I need to start at the 0th one,\n\n28\n00:01:19.860 --> 00:01:23.940\nand there's the first element,\nthe first one, and the next element.\n\n29\n00:01:23.940 --> 00:01:28.010\nAnd if I say, count(3),\nwell, it starts at 3.\n\n30\n00:01:28.010 --> 00:01:30.549\nSo let's see this in use.\n\n31\n00:01:30.549 --> 00:01:34.750\nSo if I say numbers = count(),\nand then, well,\n\n32\n00:01:34.750 --> 00:01:38.483\nnext(numbers), well, there we go.\n\n33\n00:01:38.483 --> 00:01:41.960\nAnd then next(numbers) again,\nand it goes to 1.\n\n34\n00:01:41.960 --> 00:01:43.860\nSomething you should be\naware of with count,\n\n35\n00:01:43.860 --> 00:01:48.810\nthough, it never resets back to 0\nuntil you create a new count object.\n\n36\n00:01:48.810 --> 00:01:54.438\nBut not only can we count by 1\nstarting at 0, we can, again,\n\n37\n00:01:54.438 --> 00:02:00.084\nmake numbers and\nsay count(start=10, and step=5).\n\n38\n00:02:00.084 --> 00:02:02.218\nSo I can get a start and a step.\n\n39\n00:02:02.218 --> 00:02:08.590\nAnd now if I say next(numbers), well,\nI get 10 because that's our start.\n\n40\n00:02:08.590 --> 00:02:13.045\nAnd if I say next(numbers) again,\nwell, I get 15.\n\n41\n00:02:13.045 --> 00:02:16.410\nAnd that's handy also to go through.\n\n42\n00:02:16.410 --> 00:02:23.210\nSo let's see a very common issue here, and\nthat's creating points on a graph, right?\n\n43\n00:02:23.210 --> 00:02:28.210\nSo if I say x = count, and\nI'm gonna start at 0.5 because\n\n44\n00:02:28.210 --> 00:02:32.680\nI'm not limited to just integer\nvalues to whole numbers.\n\n45\n00:02:32.680 --> 00:02:37.847\nI can say step=0.25,\nand I can say the y =,\n\n46\n00:02:37.847 --> 00:02:43.526\nwell, let's just say [10, 20 30, 40].\n\n47\n00:02:43.526 --> 00:02:49.470\nNow x here is an infinite iterator,\nit goes on forever, and ever, and ever.\n\n48\n00:02:49.470 --> 00:02:50.544\nBe very, very careful.\n\n49\n00:02:50.544 --> 00:02:52.954\nIf you accidentally cast this to a list,\nwell,\n\n50\n00:02:52.954 --> 00:02:55.285\nit'll fill up your\nmemory on your computer.\n\n51\n00:02:55.285 --> 00:02:59.450\nIt'll lock up your computer unless you\nhit the Ctrl+C, Ctrl+D fast enough.\n\n52\n00:02:59.450 --> 00:03:01.752\nSo be careful,\nin these infinite iterators,\n\n53\n00:03:01.752 --> 00:03:03.470\nyou do not wanna put them as a list.\n\n54\n00:03:03.470 --> 00:03:05.380\nSo let's zoom in here a little bit.\n\n55\n00:03:05.380 --> 00:03:07.250\nNow what if I want points?\n\n56\n00:03:07.250 --> 00:03:15.289\nWell, I want to points = zip(x, y).\n\n57\n00:03:15.289 --> 00:03:19.780\nAnd now I'm gonna get x,\ny pairings that can create a scatter plot.\n\n58\n00:03:19.780 --> 00:03:20.998\nWhy would I want to use this?\n\n59\n00:03:20.998 --> 00:03:22.977\nMaybe as seed data or mock data for\n\n60\n00:03:22.977 --> 00:03:26.589\nsomething you're testing that\nrequires pairs of numbers.\n\n61\n00:03:26.589 --> 00:03:29.368\nI know I do a great deal\nof data manipulation, so\n\n62\n00:03:29.368 --> 00:03:31.321\nthis comes in handy a great deal.\n\n63\n00:03:31.321 --> 00:03:35.941\nAnd then if I say points,\nwell, it's a zip object, so\n\n64\n00:03:35.941 --> 00:03:39.067\nI can say points = list(points).\n\n65\n00:03:39.067 --> 00:03:44.182\nAnd notice I have 0.5 with 10,\n0.75 with 20,\n\n66\n00:03:44.182 --> 00:03:48.135\n1.0 with 30, and 1.25 with 40.\n\n67\n00:03:48.135 --> 00:03:52.530\nNow that x, it's not done.\n\n68\n00:03:52.530 --> 00:03:56.540\nI can continue to peel off values\nbecause it's always there.\n\n69\n00:03:56.540 --> 00:03:58.680\nIts going to go on for\nforever, and ever, and ever.\n\n70\n00:03:58.680 --> 00:04:00.900\nDon't make it a list, you'll be sorry.\n\n71\n00:04:00.900 --> 00:04:03.740\nNow what are some other infinite\niterators that come in handy?\n\n72\n00:04:03.740 --> 00:04:08.630\nWell, let's clear out this REPL and\nstart over here at the top.\n\n73\n00:04:10.120 --> 00:04:15.340\nAnd I'm in Python 3, so\nfrom itertools import *.\n\n74\n00:04:15.340 --> 00:04:16.930\nWell, I'm just importing *,\n\n75\n00:04:16.930 --> 00:04:20.640\nyou actually shouldn't do this, but\nwhat's another one that we can use?\n\n76\n00:04:20.640 --> 00:04:22.150\nAnd that's called cycle.\n\n77\n00:04:22.150 --> 00:04:27.130\nAnd what cycle does is it allows to\ngive an iterable, whether it's a string,\n\n78\n00:04:27.130 --> 00:04:30.120\na list of things, and\nit will cycle through.\n\n79\n00:04:30.120 --> 00:04:34.638\nSo let's see here, first_four,\n\n80\n00:04:34.638 --> 00:04:40.520\nI'm going to cycle through 1,2,3,4.\n\n81\n00:04:41.650 --> 00:04:46.324\nAnd if I look at first_four,\nbecause they are infinite in nature,\n\n82\n00:04:46.324 --> 00:04:51.083\nthey have to a generator-type objects or\niterator-type objects.\n\n83\n00:04:51.083 --> 00:04:54.502\nBecause if they're not, they'll just\nfill up memory in your computer, and\n\n84\n00:04:54.502 --> 00:04:55.566\nbad things can happen.\n\n85\n00:04:55.566 --> 00:05:00.548\nSo if I zip, Over the range of 10,\n\n86\n00:05:00.548 --> 00:05:03.567\nand that means I'm going\nto get 0 through 9.\n\n87\n00:05:03.567 --> 00:05:05.581\nAnd I'm going to pair\nthose with first_four.\n\n88\n00:05:08.387 --> 00:05:10.865\nWell, it gives me a zip object, but\n\n89\n00:05:10.865 --> 00:05:14.845\nif I look at the list representation,\nI get (0, 1).\n\n90\n00:05:14.845 --> 00:05:20.820\nAnd notice first_four,\n1, 2, 3, 4, 1, 2, 3, 4.\n\n91\n00:05:20.820 --> 00:05:24.560\nWell, that's nice, but\ndoes this only work with numbers?\n\n92\n00:05:24.560 --> 00:05:25.720\nYou've only showed us numbers.\n\n93\n00:05:25.720 --> 00:05:31.081\nWell, actually, let's just\n\n94\n00:05:31.081 --> 00:05:36.859\nsay abcd = cycle('abcd').\n\n95\n00:05:36.859 --> 00:05:44.310\nAnd I'm going to zip over the range(10),\nagain, 0 through 9.\n\n96\n00:05:44.310 --> 00:05:47.760\nAnd I'm casting it to a list so\nwe can actually see a printout.\n\n97\n00:05:47.760 --> 00:05:51.890\nAnd I'm going to give the cycle of abcd.\n\n98\n00:05:53.200 --> 00:05:57.970\nSo if I do that, I get a, b,\nc, d, and then it starts over.\n\n99\n00:05:57.970 --> 00:06:02.317\nSo this is infinite in the nature that I\nnever see an end to it, but I can have\n\n100\n00:06:02.317 --> 00:06:07.182\na finite collection that I just start\nover, and over, and over, and over again.\n\n101\n00:06:07.182 --> 00:06:11.258\nAnd that's nice because some\nthings like combinations or\n\n102\n00:06:11.258 --> 00:06:16.250\nvarious mappings actually have\nthis rotational nature to them.\n\n103\n00:06:16.250 --> 00:06:19.750\nYou can almost think of this as north,\nsouth, east, west, right?\n\n104\n00:06:19.750 --> 00:06:23.320\nYou're rotating through the directions\nevery time you turn around.\n\n105\n00:06:23.320 --> 00:06:28.518\nSo cycle can be wonderful for\nkind of seeding in data for us.\n\n106\n00:06:28.518 --> 00:06:32.810\nBut that's not our last infinite iterator,\nwe have repeat.\n\n107\n00:06:32.810 --> 00:06:35.350\nSo let's start over,\njust like we have before.\n\n108\n00:06:36.410 --> 00:06:43.170\nAnd from itertools, import repeat, and I\nbet you can guess what repeat's gonna do.\n\n109\n00:06:43.170 --> 00:06:45.695\nWell, it's gonna repeat, but\n\n110\n00:06:45.695 --> 00:06:50.740\nwe have to be careful because\nit can be finite in nature.\n\n111\n00:06:50.740 --> 00:06:54.084\nAnd we'll see in just a moment,\nI can make this infinite one, well,\n\n112\n00:06:54.084 --> 00:06:55.135\nI can make it finite.\n\n113\n00:06:55.135 --> 00:06:58.340\nAnd it is, well,\nit's little bit different.\n\n114\n00:06:58.340 --> 00:07:03.348\nSo if I can say repeat, let's say, nines.\n\n115\n00:07:03.348 --> 00:07:08.540\nAnd I was gonna say repeat(nine),\nokay, well, that's nice.\n\n116\n00:07:08.540 --> 00:07:13.291\nWell, what happens when I, well,\nI'm gonna zip it with a range(10).\n\n117\n00:07:13.291 --> 00:07:16.680\nAnd then that makes sure that I only get\n10 of them because this is infinite.\n\n118\n00:07:16.680 --> 00:07:19.990\nIf I accidentally put this as a list,\nfills up the memory,\n\n119\n00:07:19.990 --> 00:07:21.560\nall kinds of bad stuff.\n\n120\n00:07:21.560 --> 00:07:26.430\nSo I'm gonna say range(10), and nines.\n\n121\n00:07:26.430 --> 00:07:28.730\nSo I should get 0 through\n9 matched with a 9.\n\n122\n00:07:29.740 --> 00:07:34.020\nAnd I do, 9 is repeated over,\nand over, and over again.\n\n123\n00:07:34.020 --> 00:07:36.071\nAgain, this is great for seed data or\n\n124\n00:07:36.071 --> 00:07:40.250\nif you have repetitive constant values\nthat you just need to grab a hold of.\n\n125\n00:07:42.146 --> 00:07:46.952\nIt works, it's nice, but\nwhat about maybe if I wanna repeat for\n\n126\n00:07:46.952 --> 00:07:49.410\nsome number of times?\n\n127\n00:07:49.410 --> 00:07:54.100\nWell, let's say ten_a_x,\nand I'm gonna repeat,\n\n128\n00:07:56.726 --> 00:07:59.520\nThe letter a 10 times.\n\n129\n00:07:59.520 --> 00:08:03.710\nI can give a second argument that tells\nme how many times I'm gonna repeat this\n\n130\n00:08:03.710 --> 00:08:06.100\nuntil this iterator or\ngenerator is exhausted.\n\n131\n00:08:07.500 --> 00:08:10.755\nAnd actually,\nlet's make this an actual word.\n\n132\n00:08:10.755 --> 00:08:14.700\nten_a_x, let's change this to ten_a_s,\nall right?\n\n133\n00:08:14.700 --> 00:08:21.920\nSo if I zip(range(5) of ten_a_s,\n\n134\n00:08:21.920 --> 00:08:26.890\nso this is going to take 0 through 4 and\npair them with this repeat function.\n\n135\n00:08:28.430 --> 00:08:33.850\nAnd well, I gotta make it a list, so\nthe underscore just allows me to do that.\n\n136\n00:08:33.850 --> 00:08:37.320\nThen I get a repeated with a 0,\n1, 2, 3, and 4.\n\n137\n00:08:37.320 --> 00:08:45.092\nWell, what if I try this again\nwith range(30) and ten_a_s?\n\n138\n00:08:47.959 --> 00:08:54.010\nAnd that's, whoop, nope, there we go,\ncannot be interpreted as an integer.\n\n139\n00:08:54.010 --> 00:08:55.540\nLet's try that again,\n\n140\n00:08:55.540 --> 00:09:00.750\nI forgot a parenthesis here,\nand there we go, I think.\n\n141\n00:09:00.750 --> 00:09:06.440\nAll right, so a range(30), well,\nI only get 0 through 4 again, why is that?\n\n142\n00:09:07.862 --> 00:09:12.865\nWell, when I have a finite version\nof this, is it exhaustible?\n\n143\n00:09:12.865 --> 00:09:17.850\nOnce I get to how many times it should\nrepeat, it stops producing values.\n\n144\n00:09:17.850 --> 00:09:22.328\nAnd zip actually only consumes\nthe shortest iterable.\n\n145\n00:09:22.328 --> 00:09:27.210\nSo actually ten_a_s, since I've already\ntaken 5 of them, only had 5 left.\n\n146\n00:09:27.210 --> 00:09:30.090\nAnd there's no way to fulfill the 30.\n\n147\n00:09:30.090 --> 00:09:35.332\nAnd just to show you that is the case,\nI'm going to say zip(range(30).\n\n148\n00:09:35.332 --> 00:09:41.598\nBut I'm going to repeat('a', let's say,\n\n149\n00:09:41.598 --> 00:09:46.470\n35)) times, and there we go.\n\n150\n00:09:46.470 --> 00:09:48.850\nThat's the appropriate\namount of parentheses.\n\n151\n00:09:48.850 --> 00:09:52.410\nIt is not, but I added one, anyway.\n\n152\n00:09:52.410 --> 00:09:56.143\nSo I get 0 through 29 with a's with them.\n\n153\n00:09:56.143 --> 00:10:01.469\nAnd well, I've already consumed 30 of\nthe a's that are produced by this repeat.\n\n154\n00:10:01.469 --> 00:10:04.140\nAnd I only have 5 left.\n\n155\n00:10:04.140 --> 00:10:08.780\nSo these infinite iterators are incredibly\nhelpful for seeding date, producing\n\n156\n00:10:08.780 --> 00:10:13.610\nthe same value over, and over, and over\nagain without having to generate a list.\n\n157\n00:10:13.610 --> 00:10:15.980\nAnd that's where the power comes in.\n\n158\n00:10:15.980 --> 00:10:21.570\nI don't have to take up memory generating\n1,000 a's if I need the a over,\n\n159\n00:10:21.570 --> 00:10:25.960\nand over, and over again or\na 9 over and over again with repeat.\n\n160\n00:10:25.960 --> 00:10:28.430\nBut also,\nI don't have to cycle through, right?\n\n161\n00:10:28.430 --> 00:10:33.337\nIf I wanted abcd forever, right, I just\nwanted to pull the next value of that\n\n162\n00:10:33.337 --> 00:10:37.478\ncollection with a list,\nI would have to generate a list, well,\n\n163\n00:10:37.478 --> 00:10:40.413\nthat would take up as\nmany elements as I need.\n\n164\n00:10:40.413 --> 00:10:43.581\nBut since I'm getting these one at a time,\nthey're more memory efficient,\n\n165\n00:10:43.581 --> 00:10:46.620\nthey're pretty fast, and\nthey're already built in for you.\n\n166\n00:10:46.620 --> 00:10:52.520\nSo we've seen the first three iterators\nthat come out of the itertools module,\n\n167\n00:10:52.520 --> 00:10:57.300\nbut that takes us to,\nwhat comes next with the itertools module?\n\n168\n00:10:57.300 --> 00:11:00.790\nWell, I hope that you join us next\ntime as we continue our deep dive into\n\n169\n00:11:00.790 --> 00:11:02.470\nthe Python standard library.\n\n170\n00:11:02.470 --> 00:11:05.204\nI'm Justin Dennison, see you.\n\n171\n00:11:05.204 --> 00:11:08.660\n[SOUND]\n\n",
          "vimeoId": "212583880"
        },
        {
          "description": "In this episode, Justin demonstrates using combinatoric tools from the itertools module. These include product, permutations, combinations, and combinations_with_replacement. These tools are wonderful when you need to generate a relationship among the elements of an iterable or between the elements among multiple iterators.",
          "length": "615",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-1-the_itertools_modules_combinatronics-032817-PGM.00_10_10_00.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-1-the_itertools_modules_combinatronics-032817-PGM.00_10_10_00.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-1-the_itertools_modules_combinatronics-032817-PGM.00_10_10_00.Still001-sm.jpg",
          "title": "The itertools Module: Combinatorics",
          "transcript": "WEBVTT\n\n1\n00:00:00.025 --> 00:00:02.964\n[SOUND] Greetings everyone and\n\n2\n00:00:02.964 --> 00:00:07.908\nwelcome to another exciting\nepisode of ITProTV.\n\n3\n00:00:07.908 --> 00:00:08.821\nI'm Justin Dennison, and\n\n4\n00:00:08.821 --> 00:00:12.050\ntoday we're gonna finish up the itertools\nmodule from the Python Standard Library.\n\n5\n00:00:12.050 --> 00:00:15.750\nIn particular we're gonna be\nlooking at combinatoric generators.\n\n6\n00:00:15.750 --> 00:00:20.060\nAnd well what these allow us to to do is\nto create permutations, pairings, And,\n\n7\n00:00:20.060 --> 00:00:24.590\nwell some mathy type stuff, but\nthey actually have wonderful usage.\n\n8\n00:00:24.590 --> 00:00:27.620\nI use them actually\na great deal of the time.\n\n9\n00:00:27.620 --> 00:00:30.190\nSo let's go ahead and get started and\nsee what we're getting into.\n\n10\n00:00:30.190 --> 00:00:33.354\nSo I'm gonna hop on into a REPL here.\n\n11\n00:00:33.354 --> 00:00:38.253\nAnd so from itertools import *,\nand well these are the last few,\n\n12\n00:00:38.253 --> 00:00:42.189\nbut this is not exhaustive\nof the itertools module.\n\n13\n00:00:42.189 --> 00:00:46.593\nYou should definitely go check out the\nPython Standard Library Documentation and\n\n14\n00:00:46.593 --> 00:00:50.037\nsee, maybe there's something\nthere that isn't useful to me,\n\n15\n00:00:50.037 --> 00:00:53.830\nbut has just come up in new versions and\nhelps you a great deal.\n\n16\n00:00:53.830 --> 00:00:55.830\nSo what are we going to do first?\n\n17\n00:00:55.830 --> 00:00:58.790\nWell we need a, we need pairings, and\n\n18\n00:00:58.790 --> 00:01:03.820\nwe need every possible pairing, and\nthat actually is called the product.\n\n19\n00:01:03.820 --> 00:01:08.890\nSo, let's take a look here,\nif I have some numbers, and let's say\n\n20\n00:01:08.890 --> 00:01:12.790\nthese numbers are an input to a function,\nor I need to make some manipulation.\n\n21\n00:01:12.790 --> 00:01:16.033\nAnd 1 through 10, and\nI have some letters, and,\n\n22\n00:01:16.033 --> 00:01:20.980\nthere's abcdefghijk.\n\n23\n00:01:20.980 --> 00:01:23.140\nAlright, so there's numbers and letters.\n\n24\n00:01:23.140 --> 00:01:28.507\nWell product allows us, and we should\nadd a list there, keep in mind these\n\n25\n00:01:28.507 --> 00:01:33.716\ncan be incredibly large, but\ntypically they take finite generators.\n\n26\n00:01:33.716 --> 00:01:36.674\nSo you should, or excuse me,\nfinite iterables, so\n\n27\n00:01:36.674 --> 00:01:39.510\nyou should be okay with\nputting these into lists.\n\n28\n00:01:39.510 --> 00:01:43.216\nBut keep in mind if you're\nfeeding in infinite pieces to it,\n\n29\n00:01:43.216 --> 00:01:48.175\nyou may not get what you expect, or you\nmay lock up your machine and shenanigans.\n\n30\n00:01:48.175 --> 00:01:53.517\nSo, list of product, and\nproduct is from the itertools module,\n\n31\n00:01:53.517 --> 00:01:58.010\nnumbers, letters, and\nlet's see what we get, woo!\n\n32\n00:01:58.010 --> 00:01:59.280\nThat is a lot right there.\n\n33\n00:02:00.390 --> 00:02:01.688\nWhat has happened is,\n\n34\n00:02:01.688 --> 00:02:07.380\nfor every thing in numbers, I've paired\nit with every letter in letters.\n\n35\n00:02:07.380 --> 00:02:10.260\nSo 1, a, 1, b, 1, c.\n\n36\n00:02:10.260 --> 00:02:13.230\nAnd notice after I'm done with 1,\nI move on to 2.\n\n37\n00:02:13.230 --> 00:02:20.410\nSo I get every possible pairing, but am\nI limited to, just kind of one pairings?\n\n38\n00:02:21.620 --> 00:02:22.850\nWell let's see what the length of this is.\n\n39\n00:02:22.850 --> 00:02:28.006\nproduct(numbers, letters), and\n\n40\n00:02:28.006 --> 00:02:33.650\nI forgot a parenthesis there, a 108.\n\n41\n00:02:33.650 --> 00:02:34.428\nWell how did I get a 108?\n\n42\n00:02:34.428 --> 00:02:39.500\nWell they take len(numbers) that's 9,\n\n43\n00:02:39.500 --> 00:02:43.620\nand len(letters) that's 12.\n\n44\n00:02:43.620 --> 00:02:48.006\n9 times 12 is 108, so whatever your\ninput is, if you multiply those together\n\n45\n00:02:48.006 --> 00:02:51.048\nthe product, that's how many\nthings we're gonna get out.\n\n46\n00:02:51.048 --> 00:02:55.090\nBut the product's not only\nlimited to just two iterables.\n\n47\n00:02:55.090 --> 00:03:02.166\nI can say the products of letters,\nnumbers, letters, and let's just say 123,\n\n48\n00:03:02.166 --> 00:03:08.058\nwhich is a string representation\nof numbers, so a little different.\n\n49\n00:03:08.058 --> 00:03:09.745\nAnd what am I gonna get?\n\n50\n00:03:09.745 --> 00:03:12.690\nWell, an itertools product.\n\n51\n00:03:12.690 --> 00:03:16.530\nBut if I list,\nwe're gonna have to cross our fingers that\n\n52\n00:03:16.530 --> 00:03:18.550\nwe don't get ourselves\ninto some trouble here.\n\n53\n00:03:18.550 --> 00:03:24.300\nAnd notice how fast that was, but I have\nevery possible combination from letters,\n\n54\n00:03:24.300 --> 00:03:28.590\nnumbers, letters and\nthen that final numeric string.\n\n55\n00:03:28.590 --> 00:03:32.950\nSo if I have to have those combinations,\nwell,\n\n56\n00:03:32.950 --> 00:03:38.260\nall of those groupings if you will,\nproduct comes in handy and in great deal.\n\n57\n00:03:38.260 --> 00:03:44.279\nBut product also allows us\nto add a keyword argument,\n\n58\n00:03:44.279 --> 00:03:49.498\nand say list(product(letters, numbers,\n\n59\n00:03:49.498 --> 00:03:54.870\nand I want to repeat=2,\nand now what do I get?\n\n60\n00:03:56.010 --> 00:04:00.050\nWell, it's not quite what you anticipated.\n\n61\n00:04:00.050 --> 00:04:02.840\nThat's a lot,\nI'm gonna quite scrolling there.\n\n62\n00:04:02.840 --> 00:04:06.940\nBut notice I get a letter,\na number, a letter, and a number.\n\n63\n00:04:06.940 --> 00:04:11.300\nSo the repeat is actually\nthe iterables that are repeated,\n\n64\n00:04:11.300 --> 00:04:13.300\nhow many times we're getting pairs.\n\n65\n00:04:13.300 --> 00:04:17.710\nSo this is letters numbers letters\nnumbers, so if I need that grouping\n\n66\n00:04:17.710 --> 00:04:22.720\nrepeated over and over and over again, I\ncan get that out with that repeat keyword.\n\n67\n00:04:22.720 --> 00:04:26.347\nNow I've been saying the word combinations\nso don't get confused here in\n\n68\n00:04:26.347 --> 00:04:30.100\njust a little while when we actually\ntalk about, well, combinations.\n\n69\n00:04:30.100 --> 00:04:32.572\nBut before we do,\nlet's talk about permutations.\n\n70\n00:04:32.572 --> 00:04:37.255\nLet's see what is available to\nus in the itertools family.\n\n71\n00:04:37.255 --> 00:04:41.832\nSo from itertools import *, and\n\n72\n00:04:41.832 --> 00:04:45.758\nnow let's look at letters.\n\n73\n00:04:45.758 --> 00:04:50.260\nDifferent set of letters than before,\nABCDEF.\n\n74\n00:04:50.260 --> 00:04:56.450\nAnd now I have permutations, and\nwhat does permutations give to us?\n\n75\n00:04:56.450 --> 00:05:00.950\nWell if I just put letters in there,\nI get a permutations object.\n\n76\n00:05:00.950 --> 00:05:05.053\nThat means it can be consumed\nusing a four loop, or\n\n77\n00:05:05.053 --> 00:05:10.244\neven the list keyword, and\nnotice F, E, B, D, A, C, okay.\n\n78\n00:05:10.244 --> 00:05:15.189\nWell, F, E, what do I get,\nI get every possible kind of\n\n79\n00:05:15.189 --> 00:05:19.523\npermutation of the letters A,\nB, D, C, E, F.\n\n80\n00:05:19.523 --> 00:05:23.789\nAll right, well that's nice, but\nthere's a second argument for\n\n81\n00:05:23.789 --> 00:05:27.078\npermutations, and\nlet's see how that works out.\n\n82\n00:05:27.078 --> 00:05:32.967\nSo, permutations of the letters, but\nI'm gonna give it a second argument,\n\n83\n00:05:32.967 --> 00:05:38.560\nand it's a number, the number 2,\nand well let's see what happens.\n\n84\n00:05:38.560 --> 00:05:43.549\nI have to spell letters correctly\nnumber one, but now that every possible\n\n85\n00:05:43.549 --> 00:05:47.828\npermutation of a pair of letters,\nfrom the letters iterable.\n\n86\n00:05:47.828 --> 00:05:51.289\nWell, that kinda crazy, AB, AC, A, but\n\n87\n00:05:51.289 --> 00:05:56.790\nit is handy if I need that for\nsome kind of statistical math, right?\n\n88\n00:05:56.790 --> 00:06:00.850\nI'm showing this with letters, but\nmaybe you need groupings, every possible\n\n89\n00:06:00.850 --> 00:06:05.800\ngrouping, to find out your sample space\nfor some probabilistic determinations.\n\n90\n00:06:05.800 --> 00:06:09.078\nNow that's a very niche case, but\nit is built into the standard library, and\n\n91\n00:06:09.078 --> 00:06:11.762\nI have used during data analysis,\nso do know that it's there.\n\n92\n00:06:11.762 --> 00:06:14.634\nNow, there's a couple other ones for\n\n93\n00:06:14.634 --> 00:06:20.290\nthese combinatoric type things,\nand that is combinations.\n\n94\n00:06:20.290 --> 00:06:24.830\nAnd this is a choice, not like the\ncombinations from products where I just\n\n95\n00:06:24.830 --> 00:06:30.580\ngroup all of these things together, but\ncombinations in the statistical sense.\n\n96\n00:06:30.580 --> 00:06:34.064\nSo, let's kill out this REPL, clear,\n\n97\n00:06:34.064 --> 00:06:38.068\ncreate a new REPL,\nfrom itertools import *.\n\n98\n00:06:38.068 --> 00:06:43.510\nAnd let's bring those letters back,\nI'm bringing the letters back.\n\n99\n00:06:43.510 --> 00:06:47.480\nAnd I'm just gonna say size, okay, so\n\n100\n00:06:47.480 --> 00:06:51.880\ncombinations, What is that gonna give us?\n\n101\n00:06:51.880 --> 00:06:56.270\nIt's gonna take an iterable and\na size, this is required,\n\n102\n00:06:56.270 --> 00:06:59.390\nI have to put an iterable and a size,\nthat's not an optional argument.\n\n103\n00:07:00.870 --> 00:07:06.240\nI get a combinations object, so\nI can't consume it with a for loop, or\n\n104\n00:07:06.240 --> 00:07:11.150\nany type of thing that consumes\nan iterable, or I can give it the list.\n\n105\n00:07:11.150 --> 00:07:15.060\nNot notice, A, B, A, C, A, D, A, E, A, F.\n\n106\n00:07:15.060 --> 00:07:17.516\nB, C, why does it go to B, C?\n\n107\n00:07:17.516 --> 00:07:23.718\nWell that's because combinations, well,\nthey take away once they've consumed.\n\n108\n00:07:23.718 --> 00:07:29.930\nSo A, B is already there,\nB, A would be the same.\n\n109\n00:07:29.930 --> 00:07:36.350\nSo this gives me unique pairings, instead\nof B, A, well they consider that the same.\n\n110\n00:07:36.350 --> 00:07:41.026\nBut maybe that's not what you want,\nyou want combinations with replacement,\n\n111\n00:07:41.026 --> 00:07:44.253\nyou want all of the possible\ncombinations of size two.\n\n112\n00:07:44.253 --> 00:07:46.683\nAnd this size can be anything,\n\n113\n00:07:46.683 --> 00:07:52.211\nit can be up to the size with\nthe iterable, so if I say combinations 3,\n\n114\n00:07:53.429 --> 00:07:58.809\nNow I get all possible three combinations\nthat draw from this iterable A,\n\n115\n00:07:58.809 --> 00:08:03.170\nB, C, A, B, D, so\nwe've kinda done this things as a kid.\n\n116\n00:08:03.170 --> 00:08:06.085\nI remember doing this in elementary\nschool, middle school, and\n\n117\n00:08:06.085 --> 00:08:07.720\neven high school and college.\n\n118\n00:08:07.720 --> 00:08:09.840\nTrying to create all of this\ngroupings that I could,\n\n119\n00:08:09.840 --> 00:08:12.310\nit's built into itertools module.\n\n120\n00:08:12.310 --> 00:08:15.864\nBut, what if i want not necessarily A,\nB, C, and\n\n121\n00:08:15.864 --> 00:08:19.540\nthat's the same as,\nwell can we find C, B, A?\n\n122\n00:08:19.540 --> 00:08:24.690\nNo it's not there, because those are\nconsidered the same, without replacement.\n\n123\n00:08:24.690 --> 00:08:27.360\nWhat if I want with replacement?\n\n124\n00:08:27.360 --> 00:08:33.595\nWell, there's a change on that,\nit's called combinations_with_replacement\n\n125\n00:08:33.595 --> 00:08:39.315\nit takes the same arguments, letters,\nwhich is an iterable, and the size.\n\n126\n00:08:39.315 --> 00:08:43.429\nIt does give me\na combinations_with_replacement object,\n\n127\n00:08:43.429 --> 00:08:47.750\nwell that's important,\nthat can be consumed by the list.\n\n128\n00:08:47.750 --> 00:08:52.150\nBut notice now whenever it consumes\nthe letter, it puts it back.\n\n129\n00:08:52.150 --> 00:08:59.149\nSo A can pair with itself, B can pair\nwith itself, and well, I get A, B, but\n\n130\n00:08:59.149 --> 00:09:04.190\nit doesn't do B, A, right?\n\n131\n00:09:04.190 --> 00:09:10.100\nSo I get A, A, A, B, A, C, A,\nD, but I don't get the reverse.\n\n132\n00:09:10.100 --> 00:09:11.620\nAnd that's because well,\n\n133\n00:09:11.620 --> 00:09:16.480\nthis is about pairing with itself,\nI can chose the same thing multiple times.\n\n134\n00:09:16.480 --> 00:09:20.090\nBut as far as combinations are concerned,\nA, B and B,\n\n135\n00:09:20.090 --> 00:09:25.830\nA are the same, they are well,\nnot unique, so you only list them once.\n\n136\n00:09:25.830 --> 00:09:29.730\nSo as you can see the combination with\nreplacement, it gives us output very\n\n137\n00:09:29.730 --> 00:09:35.260\nsimilar to the combinations function\nwithin the itertools module.\n\n138\n00:09:35.260 --> 00:09:37.968\nBut I'm able to draw A twice,\n\n139\n00:09:37.968 --> 00:09:42.436\nright, I get that replacement of A, but\nI don't necessarily get the opposite.\n\n140\n00:09:42.436 --> 00:09:48.290\nSo, A, A, A, B, but there's no B,\nA because A, B and B, A, as far\n\n141\n00:09:48.290 --> 00:09:53.170\nas combinations are concerned, are exactly\nthe same and not unique combinations.\n\n142\n00:09:53.170 --> 00:09:56.130\nAs you can see,\nthe itertools module already has some\n\n143\n00:09:56.130 --> 00:10:00.680\nbuilt in statistical utility that you may\nbe able to make use of, not only just for\n\n144\n00:10:00.680 --> 00:10:04.160\nthe statistics portion, but\nin fact, through the iteration.\n\n145\n00:10:04.160 --> 00:10:07.050\nBut hopefully you'll join us back as we\ncontinue our deep dive into the Python\n\n146\n00:10:07.050 --> 00:10:07.811\nstandard library.\n\n147\n00:10:07.811 --> 00:10:13.666\nI've been Justin Dennison,\nsee you next time.\n\n148\n00:10:13.666 --> 00:10:14.494\n[SOUND]\n\n",
          "vimeoId": "212584163"
        },
        {
          "description": "In this episode, Justin demonstrates using iterators from the itertools modules that terminate on the shortest input such as tee, chain, chain.from_iterable, starmap, and compress. Though not exhaustive, Justin shows how to flatten iterables, make a selection of elements from an iterable, as well as how to manage iterables for function consumption.",
          "length": "1241",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-2-the_itertools_modules_shortest_input-032817-PGM.00_20_35_16.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-2-the_itertools_modules_shortest_input-032817-PGM.00_20_35_16.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-2-2-the_itertools_modules_shortest_input-032817-PGM.00_20_35_16.Still001-sm.jpg",
          "title": "The itertools Module: Shortest Input",
          "transcript": "WEBVTT\n\n1\n00:00:00.083 --> 00:00:03.162\n[MUSIC]\n\n2\n00:00:03.162 --> 00:00:06.740\nGreetings everyone and welcome to\nanother exciting episode of ITProTV.\n\n3\n00:00:06.740 --> 00:00:08.759\nI'm Justin Dennison and\nin today's episode,\n\n4\n00:00:08.759 --> 00:00:11.188\nwe're gonna continue our look\nat the itertools module.\n\n5\n00:00:11.188 --> 00:00:14.350\nIn particular we're gonna be\nlooking at itertools, well,\n\n6\n00:00:14.350 --> 00:00:17.750\niterators that terminate on\nthe shortest input sequence.\n\n7\n00:00:17.750 --> 00:00:19.850\nNow that's kind of\na mouthful to think about.\n\n8\n00:00:19.850 --> 00:00:23.493\nBut, all that means,\nis when I feed it multiple iterables, and\n\n9\n00:00:23.493 --> 00:00:26.407\niterables are things that\nyou can put in a for loop.\n\n10\n00:00:26.407 --> 00:00:30.260\nWell, the shortest one kinda\ndictates the behavior.\n\n11\n00:00:30.260 --> 00:00:34.172\nThere are a couple of exceptions to that,\nand I'll point those out as we come to it.\n\n12\n00:00:34.172 --> 00:00:39.144\nSo, let's go ahead and jump right in,\nand well, let's open up a repl, and\n\n13\n00:00:39.144 --> 00:00:41.259\nI'm gonna say from itertools.\n\n14\n00:00:41.259 --> 00:00:45.920\nWell, gotta spell that correctly,\nthat's important from itertools import *.\n\n15\n00:00:45.920 --> 00:00:49.259\nNow I'm doing this again\njust as a convenience.\n\n16\n00:00:49.259 --> 00:00:51.891\nTypically you want to import\njust the ones that you want and\n\n17\n00:00:51.891 --> 00:00:56.400\nnot everything into the namespace because\nyou may wanna reuse some of these names.\n\n18\n00:00:56.400 --> 00:00:59.454\nIn your own projects and\nyou don't wanna have some weird mix ups.\n\n19\n00:00:59.454 --> 00:01:02.644\nSo be careful about that\njust keep that in mind.\n\n20\n00:01:02.644 --> 00:01:05.060\nSo the first one we're gonna\nlook at is accumulate.\n\n21\n00:01:05.060 --> 00:01:09.967\nAnd accumulate is an iterable that\nkinda gives you an iterable back that\n\n22\n00:01:09.967 --> 00:01:11.111\nis a composite or\n\n23\n00:01:11.111 --> 00:01:16.119\nsome accumulation of the previous\nelements within the input iterable.\n\n24\n00:01:16.119 --> 00:01:18.930\nOr whether it be a list,\na string, or so forth.\n\n25\n00:01:18.930 --> 00:01:22.705\nThis is incredibly handy for\nlike moving averages or\n\n26\n00:01:22.705 --> 00:01:28.080\nsome kind of data analysis where you\nneed a moving total as you go along.\n\n27\n00:01:28.080 --> 00:01:29.834\nSo let's go ahead and\nsee how it plays out.\n\n28\n00:01:29.834 --> 00:01:32.619\nLet's get a couple of iterables in here.\n\n29\n00:01:32.619 --> 00:01:36.020\nI'm gonna say 10, 100, and 1,000 as data.\n\n30\n00:01:36.020 --> 00:01:41.890\nAnd then I'm gonna say letters,\nwell that's just a list of abcd.\n\n31\n00:01:41.890 --> 00:01:46.160\nAnd just as a reminder,\nthere's data and letters.\n\n32\n00:01:46.160 --> 00:01:48.223\nNow what does accumulate do?\n\n33\n00:01:48.223 --> 00:01:52.686\nWell as with all itertools module,\nfunction type things, right,\n\n34\n00:01:52.686 --> 00:01:56.980\nwhether they be objects or\nfunctions or generators.\n\n35\n00:01:56.980 --> 00:02:02.875\nThey typically return objects of some\nsort or generators in this case.\n\n36\n00:02:02.875 --> 00:02:06.830\nI can say, accumulate data but\nI get an object back.\n\n37\n00:02:06.830 --> 00:02:08.770\nWell, I wanna see what's in here.\n\n38\n00:02:08.770 --> 00:02:13.750\nBut be careful, if you feed this\nan infinite generator, right?\n\n39\n00:02:13.750 --> 00:02:17.650\nFrom somewhere else in the itertools or\na generator that you've written.\n\n40\n00:02:17.650 --> 00:02:21.210\nWell, you may get a list\nthat fills up memory and\n\n41\n00:02:21.210 --> 00:02:24.310\ncrashes your computer so be wary.\n\n42\n00:02:24.310 --> 00:02:28.110\nSo I'm gonna accumulate over the data and\nnotice that I start with 10.\n\n43\n00:02:28.110 --> 00:02:32.667\nWell, that's the same as what\nwas in data to begin with but\n\n44\n00:02:32.667 --> 00:02:36.948\nnow it's 110,\nwhich is the sum of 100 and 10.\n\n45\n00:02:36.948 --> 00:02:40.122\nAnd if I come here it's 1110.\n\n46\n00:02:40.122 --> 00:02:43.880\nAnd that is the sum of all of\nthe elements up until this point.\n\n47\n00:02:43.880 --> 00:02:49.195\nWell, that makes sense because,\nwell, that's how I see it.\n\n48\n00:02:49.195 --> 00:02:51.780\nBut does it work for just numbers?\n\n49\n00:02:51.780 --> 00:02:53.690\nWell, there's a quick hint there.\n\n50\n00:02:53.690 --> 00:02:58.200\nI've made some letters as an iterable so\nyou probably guess that it does not.\n\n51\n00:02:58.200 --> 00:03:05.450\nIf I say accumulate, and\nI say accumulate(letters) and\n\n52\n00:03:05.450 --> 00:03:09.840\nactually spell it right\nI get a ab abc abcd.\n\n53\n00:03:09.840 --> 00:03:13.990\nSo I get the summation up to that point.\n\n54\n00:03:13.990 --> 00:03:18.920\nNow be careful the default action for\naccumulate is to actually addition.\n\n55\n00:03:18.920 --> 00:03:22.430\nAnd that's the defined on strings and\non numbers but\n\n56\n00:03:22.430 --> 00:03:26.640\nmay not be defined on\nobjects that currently fill\n\n57\n00:03:26.640 --> 00:03:30.780\nwhatever's in the interables that\nyou pass such as letters or data.\n\n58\n00:03:30.780 --> 00:03:35.880\nBut there is a way to define whatever\nthat function being applied works out.\n\n59\n00:03:35.880 --> 00:03:41.810\nSo let's see, let's just try\nsomething kind of contrive here and\n\n60\n00:03:41.810 --> 00:03:47.140\nif I say list accumulate and\nI'm gonna accumulate over\n\n61\n00:03:48.530 --> 00:03:53.780\nletters and I'm gonna pass a func\nnow this is a keyword argument\n\n62\n00:03:53.780 --> 00:03:58.550\nthat's available for the reduction so\nhow am I going to get to the next element?\n\n63\n00:03:58.550 --> 00:04:02.767\nAnd it's going to be the function\nthat takes in x and y and that x and\n\n64\n00:04:02.767 --> 00:04:06.218\ny is going to be the first element and\nsecond element,\n\n65\n00:04:06.218 --> 00:04:10.899\nthen the second element and third\nelement and that would be index zero but\n\n66\n00:04:10.899 --> 00:04:14.533\nit's pair wize moving through\nwhat iterable you have.\n\n67\n00:04:14.533 --> 00:04:23.210\nAnd let's say times 2 + y times 2 and\nthere we go.\n\n68\n00:04:23.210 --> 00:04:24.320\nLet's see what happens.\n\n69\n00:04:24.320 --> 00:04:26.240\nNow I passed letters in here.\n\n70\n00:04:26.240 --> 00:04:27.730\nWe gotta be careful.\n\n71\n00:04:27.730 --> 00:04:32.980\nAnd well, it works because multiplication\nin Python is defined between a number and\n\n72\n00:04:32.980 --> 00:04:35.270\na letter and all it does it repeat.\n\n73\n00:04:35.270 --> 00:04:37.968\nSo I get a well I always\nget the same thing out at\n\n74\n00:04:37.968 --> 00:04:42.172\nthe beginning because there's\nnothing before that to combine with.\n\n75\n00:04:42.172 --> 00:04:44.868\nBut then when I have a and\nb I get aabb and\n\n76\n00:04:44.868 --> 00:04:50.370\nthat's because I multiplied by two and\nthen add those two together.\n\n77\n00:04:50.370 --> 00:04:52.797\nAnd notice this is growing very quickly.\n\n78\n00:04:52.797 --> 00:04:58.560\nBut if you can think about this if you\nneeded to find like the collection of.\n\n79\n00:04:58.560 --> 00:05:01.401\nHave a bunch of pair-wise\ntriangle hypotenuses,\n\n80\n00:05:01.401 --> 00:05:05.437\nI don't even know if that's a word,\nwe're gonna make it a word for now.\n\n81\n00:05:05.437 --> 00:05:11.612\nThen this would also apply on numbers,\nand just to show you then,\n\n82\n00:05:11.612 --> 00:05:17.227\nI'm going to change this from\nletters to instead data and,\n\n83\n00:05:17.227 --> 00:05:20.257\nwell, I get 10 as we expect but\n\n84\n00:05:20.257 --> 00:05:25.910\nthen 10 squared plus 100\nsquared is actually 220.\n\n85\n00:05:25.910 --> 00:05:32.554\nSo this is nice for that moving average or\nsome kind of moving aggregation function.\n\n86\n00:05:32.554 --> 00:05:37.869\nBut keep in mind, if I make this func\nundefined well, I get an unsupported\n\n87\n00:05:37.869 --> 00:05:43.380\ntype error and that because a string\nminus a string is not defined in Python.\n\n88\n00:05:43.380 --> 00:05:46.421\nSo be very carefull with your\ntypes even though they are not\n\n89\n00:05:46.421 --> 00:05:48.794\nexplicit we have to take\nthose into account.\n\n90\n00:05:48.794 --> 00:05:52.125\nNow the next two I'm actually\ngonna have to lamp together and\n\n91\n00:05:52.125 --> 00:05:55.470\nthis is the exception kind of as\nwe think about it to the rule.\n\n92\n00:05:55.470 --> 00:06:00.112\nSo I'm gonna clear this out And\nstart a new repo session and\n\n93\n00:06:00.112 --> 00:06:04.945\nsay from itertools, import chain,\nactually, not chain,\n\n94\n00:06:04.945 --> 00:06:10.300\n*, but we are gonna use chain,\nkinda shared my hand there.\n\n95\n00:06:10.300 --> 00:06:13.843\nAnd let's just say first = 'abcd'.\n\n96\n00:06:13.843 --> 00:06:19.760\nAnd second = the range from 1 to 5,\nnow five is not included,\n\n97\n00:06:19.760 --> 00:06:25.980\nso it's actually 1, 2, 3,\n4 this is a quick reminder.\n\n98\n00:06:25.980 --> 00:06:31.053\nAnd let's see here, so if I list\nthe chain of first and second well,\n\n99\n00:06:31.053 --> 00:06:37.016\nI get a, b, c, d, 1, 2, 3, 4, I like\nto think of chain as the flattened So\n\n100\n00:06:37.016 --> 00:06:42.089\nif I have a bunch of iterators, or\nexcuse me, a bunch of iterables or\n\n101\n00:06:42.089 --> 00:06:45.471\nsomething that have chunks\nof data in them and\n\n102\n00:06:45.471 --> 00:06:49.035\nI want them all in one I\ncan use chain to get that.\n\n103\n00:06:49.035 --> 00:06:53.934\nWhat happens though if I change this to,\nI don't know, 30 and\n\n104\n00:06:53.934 --> 00:06:57.860\nI run this same command well\nI still get all of them.\n\n105\n00:06:57.860 --> 00:07:00.890\nSo, what did I mean by shortest input?\n\n106\n00:07:00.890 --> 00:07:02.984\nIt ends after the inputs done.\n\n107\n00:07:02.984 --> 00:07:09.299\nIt doesn't fill in, I get all of first and\nthen I get all of second also.\n\n108\n00:07:09.299 --> 00:07:12.320\nSo this one's a little bit\ndifferent in that context.\n\n109\n00:07:12.320 --> 00:07:16.994\nBut what if I have lists and lists or\nstrings that are part of a list, and\n\n110\n00:07:16.994 --> 00:07:20.098\nI just wanna flatten\nthose out all to letters.\n\n111\n00:07:20.098 --> 00:07:22.476\nAnd well, let's see.\n\n112\n00:07:22.476 --> 00:07:27.586\nChain has a sub function\ncalled from iterable.\n\n113\n00:07:27.586 --> 00:07:31.656\nAnd I can say,\nwell we can just keep first and\n\n114\n00:07:31.656 --> 00:07:36.638\nsecond here, and\nI can say chain.from_iterable.\n\n115\n00:07:36.638 --> 00:07:43.337\nAnd well here we go, we can say,\nnotice I'm putting square brackets there,\n\n116\n00:07:43.337 --> 00:07:47.975\nbecause this is now a list\nthat contains a string, and\n\n117\n00:07:47.975 --> 00:07:52.732\nalso contains a range,\nwhich we can think of as a list.\n\n118\n00:07:52.732 --> 00:07:56.501\nIt's, in Python 3, it's not\ntechnically a list right off-hand.\n\n119\n00:07:56.501 --> 00:08:01.959\nAnd well, if I, I get that out, and\nnotice That now I get an object.\n\n120\n00:08:01.959 --> 00:08:05.701\nWell just like I would have before so\n\n121\n00:08:05.701 --> 00:08:10.590\nI want to list and\nI get the same thing out.\n\n122\n00:08:10.590 --> 00:08:15.060\nBut this is just in case I have\ndeeply nested structures such as\n\n123\n00:08:16.290 --> 00:08:20.790\nlist in list in list and actually let's\ntake a look at how that would work out.\n\n124\n00:08:22.600 --> 00:08:27.950\nSo, if I have my data, and that's going\nto be at least comprehension of range\n\n125\n00:08:29.110 --> 00:08:33.100\none to ten, so\nI get one through nine, for, and\n\n126\n00:08:33.100 --> 00:08:38.000\nI'm gonna throw that variable away,\nand one through five.\n\n127\n00:08:38.000 --> 00:08:43.650\nSo, let me make this list so\nwe can take a look at the data, List.\n\n128\n00:08:45.867 --> 00:08:47.710\nAnd list and there's data.\n\n129\n00:08:47.710 --> 00:08:52.010\nAnd if we look at data,\nnotice I have a nested set of lists.\n\n130\n00:08:52.010 --> 00:08:55.590\nBut really, I just want these numbers\nto be one right after the other.\n\n131\n00:08:55.590 --> 00:08:58.860\nI want one through nine,\none through nine, one through nine.\n\n132\n00:08:58.860 --> 00:09:02.150\nBut not as a list in lists,\nbut as a flat list.\n\n133\n00:09:02.150 --> 00:09:03.040\nSo I can say chain.\n\n134\n00:09:03.040 --> 00:09:05.690\nAnd I'm gonna print, this is as a list.\n\n135\n00:09:05.690 --> 00:09:08.248\nSo it prints out nicely.\n\n136\n00:09:08.248 --> 00:09:12.610\nFrom_iterable of data.\n\n137\n00:09:12.610 --> 00:09:16.520\nAnd notice I have flattened this\ninto a one-dimensional list,\n\n138\n00:09:16.520 --> 00:09:19.100\nwhich if you do any data science,\ndata manipulation,\n\n139\n00:09:19.100 --> 00:09:22.330\nit has to be operation that\nyou're always yearning for.\n\n140\n00:09:22.330 --> 00:09:26.260\nBut it's already built into\nthe Itter's tools modules.\n\n141\n00:09:26.260 --> 00:09:29.490\nThe Itter tools\nmodule--mixed up my s there.\n\n142\n00:09:29.490 --> 00:09:31.800\nSo definitely keep those in mind.\n\n143\n00:09:31.800 --> 00:09:34.550\nNow along the same way with data analysis,\n\n144\n00:09:34.550 --> 00:09:39.110\nlet's look at a couple more tools that\nend up being a wonderful friend of ours.\n\n145\n00:09:39.110 --> 00:09:42.920\nSo I'm going to clear out this ripple,\nstart a new one, and that's just so\n\n146\n00:09:42.920 --> 00:09:47.390\nwe can Keep things nice and tidy and\nnot always at the bottom of the screen.\n\n147\n00:09:47.390 --> 00:09:53.650\nSo from itertools,\nimport, star, all right.\n\n148\n00:09:53.650 --> 00:09:58.880\nFrom itertools we have a compress, and\nwell let's just see how compress works.\n\n149\n00:09:58.880 --> 00:10:03.420\nSo I'm going to data and I'm just going to\nsay A, B, C, D, E, F, G, H, I, J, K, L.\n\n150\n00:10:03.420 --> 00:10:07.520\nIt is just a string that contains\nthe letters in alphabetical\n\n151\n00:10:07.520 --> 00:10:11.800\norder that are capitalized and\nwell, let's see.\n\n152\n00:10:11.800 --> 00:10:16.270\nI am going to call this selection\nas a hint of what is going on and\n\n153\n00:10:17.600 --> 00:10:23.350\npercent two equals zero,\nfor i_ in enumerate.\n\n154\n00:10:23.350 --> 00:10:27.000\nNow I'm doing a lot of hand-waving here,\nbut it's just setting up the data so\n\n155\n00:10:27.000 --> 00:10:28.850\nthat we can what compress does.\n\n156\n00:10:28.850 --> 00:10:31.650\nAnd data, and here we go.\n\n157\n00:10:31.650 --> 00:10:34.880\nAnd if I look at selection,\nnotice I get true and false.\n\n158\n00:10:36.190 --> 00:10:41.070\nSo here's zero, that's true because\nthe index is actually an even number.\n\n159\n00:10:41.070 --> 00:10:43.610\nSo true false, true false.\n\n160\n00:10:43.610 --> 00:10:48.100\nBut now if I say compress,\nI can take the data in\n\n161\n00:10:49.310 --> 00:10:52.690\nthe selection and well,\nthat's not helpful.\n\n162\n00:10:52.690 --> 00:10:53.580\nLet's see it printed out.\n\n163\n00:10:56.299 --> 00:10:58.330\nI get A, C, E, G, I, K.\n\n164\n00:10:58.330 --> 00:11:03.313\nAnd that's because I've kind of\ncompressed this down to only the data\n\n165\n00:11:03.313 --> 00:11:05.006\nthat I want out of data.\n\n166\n00:11:05.006 --> 00:11:11.096\nAll right, so A, which is 0, C,\nwhich is index of 2 in the string,\n\n167\n00:11:11.096 --> 00:11:14.353\nI've got the even indexed letters.\n\n168\n00:11:14.353 --> 00:11:18.850\nWell this is a nice way\nof quickly pulling out.\n\n169\n00:11:18.850 --> 00:11:23.370\nAnd if I don't cast this to a list, I can\ndo this very quickly and iterate through.\n\n170\n00:11:23.370 --> 00:11:26.570\nSo compress is wonderful for\ndata analysis as well.\n\n171\n00:11:26.570 --> 00:11:32.910\nAlong those same lines, well if you\never use list, you've used slices.\n\n172\n00:11:32.910 --> 00:11:35.280\nWell in the iter tools module,\n\n173\n00:11:35.280 --> 00:11:40.170\nit provides a way of slicing up, like\ngenerators or iterators, which typically\n\n174\n00:11:40.170 --> 00:11:45.420\ndo not support the slice context\nbecause they are not already in memory.\n\n175\n00:11:45.420 --> 00:11:50.340\nHas no way of determining what is\nthe 0th to the 5th going by twos,\n\n176\n00:11:50.340 --> 00:11:55.380\nso let's see how itertools makes\nour life a little bit easier here.\n\n177\n00:11:55.380 --> 00:11:58.845\nSo I'm gonna clear,\nstart another ripple, and\n\n178\n00:11:58.845 --> 00:12:05.240\nfrom itertools import *,\nall right, well this is iSlice,\n\n179\n00:12:05.240 --> 00:12:10.520\nso let's go numbers and\na range of 1 to 100.\n\n180\n00:12:10.520 --> 00:12:13.740\nAnd that's because well a range\nis not technically not a list,\n\n181\n00:12:13.740 --> 00:12:18.550\nif I try to say numbers and\nI get (1:5), okay.\n\n182\n00:12:18.550 --> 00:12:23.100\nIt gives me a range two to six but\nit doesn't, that's kinda weird, right?\n\n183\n00:12:23.100 --> 00:12:24.884\nI don't know what I need.\n\n184\n00:12:24.884 --> 00:12:30.830\nIt is not giving me what\nI thought as a list.\n\n185\n00:12:30.830 --> 00:12:35.560\nBut let's see elements_needed.\n\n186\n00:12:35.560 --> 00:12:37.820\nI need the first 10 elements of this.\n\n187\n00:12:39.070 --> 00:12:41.020\nOkay, so elements needed is 10.\n\n188\n00:12:41.020 --> 00:12:45.526\nAnd then I can say list,\nislice(number, and\n\n189\n00:12:45.526 --> 00:12:52.100\nnumbers being the range, of\nthe elements_needed, and that would be 10.\n\n190\n00:12:52.100 --> 00:12:53.530\nAnd I get 1 through 10.\n\n191\n00:12:53.530 --> 00:12:57.226\nNow I'm actually getting,\nwell what am I getting?\n\n192\n00:12:57.226 --> 00:13:01.590\nIf I don't list,\nif I don't cast that to a list but\n\n193\n00:13:01.590 --> 00:13:04.230\ninstead remove these parentheses and\njust do i slice.\n\n194\n00:13:07.170 --> 00:13:09.060\nI'm getting an i slice object,\n\n195\n00:13:09.060 --> 00:13:13.810\nwhich is itself a generator that is going\nto gie me these values one at a time.\n\n196\n00:13:13.810 --> 00:13:15.480\nNotice I get one through ten there.\n\n197\n00:13:15.480 --> 00:13:17.610\nNow I'm just mocking this with range.\n\n198\n00:13:17.610 --> 00:13:22.630\nBut it could be that, you know,\nfrom count in a previous episode where\n\n199\n00:13:22.630 --> 00:13:25.380\nwe saw that count just provides\nnumbers over and over and over again.\n\n200\n00:13:25.380 --> 00:13:27.250\nYou just need the next ten numbers, right?\n\n201\n00:13:27.250 --> 00:13:29.240\nWell you can't slice that.\n\n202\n00:13:29.240 --> 00:13:31.090\nBut you can islice it.\n\n203\n00:13:31.090 --> 00:13:35.500\nNow, not only that, but\nyou can islice by steps.\n\n204\n00:13:35.500 --> 00:13:37.200\nSo let's see how that works.\n\n205\n00:13:37.200 --> 00:13:43.090\nAnd I'm going to islice,\nnumbers, the next 10.\n\n206\n00:13:43.090 --> 00:13:46.100\nSo that's elements needed and\nI'm doing this just to shorten.\n\n207\n00:13:46.100 --> 00:13:49.600\nBut I'm going to step by 15, okay?\n\n208\n00:13:49.600 --> 00:13:50.756\nLet's see what happens.\n\n209\n00:13:50.756 --> 00:13:54.770\nHm, that's kinda weird.\n\n210\n00:13:54.770 --> 00:13:59.881\nI'm not stepping, I'm actually going\n\n211\n00:13:59.881 --> 00:14:06.206\nfrom start to stop just\nlike a normal slice would.\n\n212\n00:14:06.206 --> 00:14:08.076\nBut what if I wanted to go to,\nI don't know, 75 by 5.\n\n213\n00:14:08.076 --> 00:14:15.020\nWell, 11, 16, 21 26 and,\nwell that's nice, right.\n\n214\n00:14:15.020 --> 00:14:18.950\nI'm getting from 10 to 75, and notice that\neven though I said the element's needed,\n\n215\n00:14:18.950 --> 00:14:24.780\nit's the same number but\nit doesn't have the same context.\n\n216\n00:14:24.780 --> 00:14:28.540\nI'm starting at ten, I'm going to 75 and\nI'm going up to five.\n\n217\n00:14:28.540 --> 00:14:31.510\nWhy does this start at 11?\n\n218\n00:14:31.510 --> 00:14:37.856\nWell I've already consume some of those\noriginal numbers so keep that in mind.\n\n219\n00:14:37.856 --> 00:14:42.950\nSo it's left exclusive.\n\n220\n00:14:42.950 --> 00:14:49.030\nSo that islice I get the same\nslicy goodness with iterators and\n\n221\n00:14:49.030 --> 00:14:53.300\ngenerators that I would with list, but\nI just have to use the iter tools module.\n\n222\n00:14:53.300 --> 00:14:56.140\nThere's a couple other ones that\ncome up that are really helpful.\n\n223\n00:14:57.150 --> 00:14:59.920\nAnd one of them, well let's just see.\n\n224\n00:14:59.920 --> 00:15:01.460\nI'm sure you've had this happen before.\n\n225\n00:15:01.460 --> 00:15:05.000\nLet's say python3, and\nlet's make a function.\n\n226\n00:15:05.000 --> 00:15:07.820\nLet's call it string_repeater.\n\n227\n00:15:07.820 --> 00:15:11.190\nAnd it takes characters and\nthe number of repeats.\n\n228\n00:15:13.840 --> 00:15:19.290\nAnd all that's gonna do is\nreturn chars times repeats.\n\n229\n00:15:19.290 --> 00:15:26.110\nNow let's see how this\nworks string_repeater and\n\n230\n00:15:26.110 --> 00:15:33.080\nthat's gonna say I don't know cheese and\nI give it 10 well gives me\n\n231\n00:15:33.080 --> 00:15:36.540\ncheesecheesecheesecheese is actually just\nthe repeater the word cheese ten times.\n\n232\n00:15:37.800 --> 00:15:41.510\nBut when I'm doing data analysis,\nsometimes I get these in pairs, right?\n\n233\n00:15:41.510 --> 00:15:45.717\nI get these arguments as tuples,\n\n234\n00:15:45.717 --> 00:15:51.736\ninstead of as chars and\nrepeats, separately.\n\n235\n00:15:51.736 --> 00:15:59.560\nSo in itertools, I actually get\na wonderful function called starmap.\n\n236\n00:15:59.560 --> 00:16:03.154\nSo, from itertools import *.\n\n237\n00:16:03.154 --> 00:16:05.208\nFrom itertools you gotta\nspell it correctly.\n\n238\n00:16:05.208 --> 00:16:06.709\nimport *.\n\n239\n00:16:06.709 --> 00:16:10.880\nAnd, now, if I have a set of data, or\n\n240\n00:16:10.880 --> 00:16:15.090\na set of parameters in this case that\nhave come from some outside source.\n\n241\n00:16:15.090 --> 00:16:18.620\nAnd let's make these two pulls of cheese.\n\n242\n00:16:18.620 --> 00:16:24.890\nAnd 10 since we have already\nseen how that one works,\n\n243\n00:16:24.890 --> 00:16:29.250\nand bacon, and 3, and the letter A,\n\n244\n00:16:29.250 --> 00:16:33.882\nyou have to make sure that is a two tuple,\n\n245\n00:16:33.882 --> 00:16:38.000\nand the letter A, and 10 as well.\n\n246\n00:16:38.000 --> 00:16:41.907\nAnd if I say parameters,\nwe'll notice this is the chars, or\n\n247\n00:16:41.907 --> 00:16:45.750\nthe characters, and the number of repeats.\n\n248\n00:16:45.750 --> 00:16:52.140\nWell, I could just pull these apart\nthrough manipulation, but since I have\n\n249\n00:16:52.140 --> 00:16:57.440\nstarmap, I can say,\n\n250\n00:16:57.440 --> 00:17:02.710\nstarmap, and I can say,\nstring _repeater the function,\n\n251\n00:17:02.710 --> 00:17:10.210\nand the parameters for that function as\na set of tuples I get a starmap object,\n\n252\n00:17:10.210 --> 00:17:15.380\nbut let's list that out and\nnotice I get the result as I list.\n\n253\n00:17:15.380 --> 00:17:19.670\nSo, I get an iterator of the results\nof that function being called\n\n254\n00:17:19.670 --> 00:17:22.360\non these set of parameter inputs.\n\n255\n00:17:22.360 --> 00:17:23.200\nOne quick aside, though.\n\n256\n00:17:23.200 --> 00:17:24.880\nYou have to be very careful.\n\n257\n00:17:24.880 --> 00:17:29.330\nIf you don't provide everything\nthat's needed for the function, well,\n\n258\n00:17:29.330 --> 00:17:32.490\nyou're gonna get some\nnasty little output there.\n\n259\n00:17:32.490 --> 00:17:34.670\nIt will just say, nope, sorry.\n\n260\n00:17:34.670 --> 00:17:39.944\nAnd then one final iterator that is\nhelpful from iterator tools module,\n\n261\n00:17:39.944 --> 00:17:41.414\nand that is, well,\n\n262\n00:17:41.414 --> 00:17:46.463\nfrom the shortest input portion of\nthe iterator tools module, is T.\n\n263\n00:17:46.463 --> 00:17:50.860\nAnd what T does is it takes an iterable\nwhether it be string, list, or\n\n264\n00:17:50.860 --> 00:17:56.520\nsome other iterator, and a number,\nand it gives you that many copies.\n\n265\n00:17:56.520 --> 00:18:01.472\nSo, let see how this works,\nso from itertools,\n\n266\n00:18:04.652 --> 00:18:12.455\nImport star, and\nlet consider letters equal ''ABCDEF'',\n\n267\n00:18:12.455 --> 00:18:18.968\nand copies equals work for\ncopies correctly, = 2.\n\n268\n00:18:18.968 --> 00:18:24.028\nAnd, now,\nlet's just see what happens when I say,\n\n269\n00:18:24.028 --> 00:18:27.260\n(tee(letters, copies)).\n\n270\n00:18:27.260 --> 00:18:31.950\nWell, I get a list of tee objects back.\n\n271\n00:18:31.950 --> 00:18:36.750\nWell, that's kind of interesting,\nI get an iterator of iterators.\n\n272\n00:18:36.750 --> 00:18:40.420\nWell, let's see how this plays out.\n\n273\n00:18:40.420 --> 00:18:46.290\nNow, I'm gonna unpack these, and\nI'm gonna say, tee of letters and copies.\n\n274\n00:18:46.290 --> 00:18:50.630\nAnd, because copies is a finite number,\nI can always unpack, and\n\n275\n00:18:50.630 --> 00:18:55.120\nI know that the top level\niterator is going to be finite.\n\n276\n00:18:55.120 --> 00:18:58.680\nSo, first and second, I can do this,\nbecause copies is two.\n\n277\n00:18:58.680 --> 00:19:01.240\nAnd I go look at first,\nwell, that's an object.\n\n278\n00:19:01.240 --> 00:19:03.680\nIf I look at second,\nthat's also an object.\n\n279\n00:19:04.940 --> 00:19:07.241\nBut what does that led us to?\n\n280\n00:19:07.241 --> 00:19:09.320\nWell, I can say first.\n\n281\n00:19:09.320 --> 00:19:15.590\nIf I try that again, it's nothing,\nbecause I've consumed that copy.\n\n282\n00:19:15.590 --> 00:19:18.850\nAnd that's the thing about iterators and\ngenerators, you have to be careful.\n\n283\n00:19:18.850 --> 00:19:23.520\nIf they're finite, once they're\nconsumed is all over you're done, but\n\n284\n00:19:23.520 --> 00:19:28.410\nI have a second copy that I can use,\nand let's say I just to join these back\n\n285\n00:19:29.470 --> 00:19:33.890\ninto a single string, well,\nI've joined second, but\n\n286\n00:19:33.890 --> 00:19:38.310\nnow I no longer have the ability to\nconsume this, so if I need to go through.\n\n287\n00:19:38.310 --> 00:19:42.670\nSeveral times, T is a way to make\na copy of a generator that I\n\n288\n00:19:42.670 --> 00:19:47.290\nmay need more than once,\nthat way I can consume it multiple times.\n\n289\n00:19:47.290 --> 00:19:49.970\nBut here's the one point\nyou need to remember.\n\n290\n00:19:51.080 --> 00:19:55.560\nOnce you make a T,\nno longer touch the original iterable.\n\n291\n00:19:55.560 --> 00:19:59.810\nWhether it be letters, or\ndata of numbers, or whatever.\n\n292\n00:19:59.810 --> 00:20:04.370\nBecause if you advanced that,\nthen these can get off kilter and\n\n293\n00:20:04.370 --> 00:20:07.870\nstart doing weird things, so don't touch\nletters once you make a T of it and\n\n294\n00:20:07.870 --> 00:20:10.420\nyou start working with first,\nand second in this case.\n\n295\n00:20:10.420 --> 00:20:15.480\nSo, as we've seen with these itertools,\nshortest input sequences, right?\n\n296\n00:20:15.480 --> 00:20:19.353\nThey consume, there's some handy\nfunctions, such as the ability to flatten.\n\n297\n00:20:19.353 --> 00:20:23.998\nThe ability to map a function over a set\nof parameters that are in a list as well\n\n298\n00:20:23.998 --> 00:20:26.990\nas to get copies back that\nwe can continue to use.\n\n299\n00:20:26.990 --> 00:20:28.814\nNow, we are not done with\nthe intertools module.\n\n300\n00:20:28.814 --> 00:20:32.255\nSo, I definitely hope that you\nwill come back, and join us for\n\n301\n00:20:32.255 --> 00:20:34.385\nmore on the Python Standard Library.\n\n302\n00:20:34.385 --> 00:20:35.563\nI have been Justin Denison.\n\n303\n00:20:35.563 --> 00:20:36.732\nSee ya.\n\n304\n00:20:36.732 --> 00:20:40.060\n[SOUND]\n\n",
          "vimeoId": "212584401"
        },
        {
          "description": "In this episode, Justin demonstrates the use of the collections' module namedtuple. This factory function allows one to create lightweight tuples that have named field access as well as the zero-based index referencing that are available in tuples from the beginning. If you need a quick, lightweight replacement to a class, then stay tuned.",
          "length": "759",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-1-the_collections_module_namedtuple-032917-PGM.00_12_33_04.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-1-the_collections_module_namedtuple-032917-PGM.00_12_33_04.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-1-the_collections_module_namedtuple-032917-PGM.00_12_33_04.Still001-sm.jpg",
          "title": "The collections Module: namedtuple",
          "transcript": "WEBVTT\n\n1\n00:00:00.025 --> 00:00:06.848\n[NOISE] Greetings everyone and welcome\nto another exciting episode of ITPRO.TV.\n\n2\n00:00:06.848 --> 00:00:10.061\nI'm Justin Dennison and in today's\nepisode we're gonna start looking at\n\n3\n00:00:10.061 --> 00:00:13.860\nthe collections module, which is,\nwonderfully, part of the standard library.\n\n4\n00:00:13.860 --> 00:00:16.590\nIn particular,\nwe're gonna be looking at named tuples.\n\n5\n00:00:16.590 --> 00:00:18.140\nNow, why named tuples?\n\n6\n00:00:18.140 --> 00:00:21.504\nWell, if you've programmed in Python for\nany length of time,\n\n7\n00:00:21.504 --> 00:00:25.387\nyou've noticed that tuples start\nbecoming a little nicer to work with.\n\n8\n00:00:25.387 --> 00:00:29.588\nTheyre small, they take a little\nspace at first they are mutable and\n\n9\n00:00:29.588 --> 00:00:33.643\nsometimes you need that but\nyou do have the positional indexing,\n\n10\n00:00:33.643 --> 00:00:38.390\nright, I mean the zero's index of\nthese two pole, that's an issue.\n\n11\n00:00:38.390 --> 00:00:43.930\nAlso use, some times need the ability\nto create a class like object,\n\n12\n00:00:43.930 --> 00:00:48.900\nbut you want something as a little smaller\nin nature than a full blown class, and\n\n13\n00:00:48.900 --> 00:00:50.800\nthat's where the name tuple comes in.\n\n14\n00:00:50.800 --> 00:00:54.500\nSo, let's go ahead and take a look at\nthe collections module's name tuple and\n\n15\n00:00:54.500 --> 00:00:55.690\nsee how things goes.\n\n16\n00:00:55.690 --> 00:00:57.580\nSo if we take a look at my screen here.\n\n17\n00:00:57.580 --> 00:00:59.162\nAnd I'm just in a command prompt.\n\n18\n00:00:59.162 --> 00:01:01.210\nI'm gonna open up a repple, and\n\n19\n00:01:01.210 --> 00:01:04.730\nwe're just going to work within the repple\njust to see how name tuples work.\n\n20\n00:01:04.730 --> 00:01:07.930\nSo, this is part of the Python\nstandard library, it's been around for\n\n21\n00:01:07.930 --> 00:01:12.870\nawhile do keep in mind, I'm in python3,\na couple of things that will come up\n\n22\n00:01:12.870 --> 00:01:17.170\nfrom the collections module are only\navailable from two, seven, and onward.\n\n23\n00:01:17.170 --> 00:01:20.550\nSo, if you're on an older version\nof Python, do keep that in mind.\n\n24\n00:01:20.550 --> 00:01:24.060\nI recommend upgrading to 3536,\nsomething there.\n\n25\n00:01:24.060 --> 00:01:28.140\nSo from collections,\nI'm going to import namedtuple.\n\n26\n00:01:29.510 --> 00:01:33.700\nNow okay, I have it available to me,\nbut what does it do?\n\n27\n00:01:33.700 --> 00:01:37.460\nWell, let's say that I need to\nmanipulate a bunch of users.\n\n28\n00:01:37.460 --> 00:01:41.956\nAnd my user system requires a name,\nan age and an email.\n\n29\n00:01:41.956 --> 00:01:46.860\nI could write a class that has a name,\nage and email as part of the dunder init.\n\n30\n00:01:46.860 --> 00:01:48.620\nBut those are a little bulky.\n\n31\n00:01:48.620 --> 00:01:51.280\nIt's almost like I could\nhave a tuple like this,\n\n32\n00:01:52.500 --> 00:01:57.740\nwhere I have the user John,\nand there's his name.\n\n33\n00:01:57.740 --> 00:02:02.536\nThe age is 31, and the email is\n\n34\n00:02:02.536 --> 00:02:07.161\nsome@where.here, right.\n\n35\n00:02:07.161 --> 00:02:11.409\nSo I could have that tuple and\nthat would be nice, but\n\n36\n00:02:11.409 --> 00:02:16.252\nnow if I want the name I have\nto remember that is user[0].\n\n37\n00:02:16.252 --> 00:02:19.131\nI would really like to be able\nto do something like this,\n\n38\n00:02:19.131 --> 00:02:23.241\nuser.name because that's more readable,\nit's easier to reason about, and\n\n39\n00:02:23.241 --> 00:02:25.907\nrequires less commenting\nto keep things in order.\n\n40\n00:02:27.050 --> 00:02:31.440\nSo I'm gonna hop out of this\nrep over here real quick, and\n\n41\n00:02:31.440 --> 00:02:33.330\nnotice that it gives me an error there.\n\n42\n00:02:33.330 --> 00:02:36.570\nStart up another one just so we can have\nthings not at the bottom of the screen.\n\n43\n00:02:36.570 --> 00:02:38.090\nWe'll have to deal with that a little bit,\n\n44\n00:02:38.090 --> 00:02:41.190\nbut we'll try to avoid\nit as much as possible.\n\n45\n00:02:41.190 --> 00:02:42.430\nSo how can I do that?\n\n46\n00:02:42.430 --> 00:02:45.120\nWell, notice that I upper-cased User here,\nand\n\n47\n00:02:45.120 --> 00:02:46.670\nthere's a very particular reason for that.\n\n48\n00:02:48.110 --> 00:02:51.524\nI gotta import named\ntuple from collections\n\n49\n00:02:54.030 --> 00:02:57.240\nimport namedtuple or tuple.\n\n50\n00:02:57.240 --> 00:02:58.270\nSome people say tuple.\n\n51\n00:02:58.270 --> 00:03:01.740\nSo if I'm saying it and\nyou're like, it's called tuple,\n\n52\n00:03:01.740 --> 00:03:04.890\nthen I recognize that is\na valid pronunciation, so.\n\n53\n00:03:04.890 --> 00:03:07.970\nI just like the name tuple,\nit rolls off the tongue.\n\n54\n00:03:07.970 --> 00:03:13.080\nSo, notice I have an uppercase User here,\nand\n\n55\n00:03:13.080 --> 00:03:17.330\nthat gives me a denotation,\nsomething that I can hang onto that\n\n56\n00:03:17.330 --> 00:03:21.090\nmakes me think programmatically,\nthis behaves like a class, right?\n\n57\n00:03:21.090 --> 00:03:23.320\nThis is a class based naming.\n\n58\n00:03:23.320 --> 00:03:25.690\nSo, I'm gonna say namedtuple.\n\n59\n00:03:25.690 --> 00:03:28.480\nAnd what is the type of this namedtuple?\n\n60\n00:03:28.480 --> 00:03:30.960\nIt is User., notice that's a string.\n\n61\n00:03:30.960 --> 00:03:33.385\nAnd we'll see how that comes\ninto play in just a moment.\n\n62\n00:03:33.385 --> 00:03:36.190\nAnd there's a couple of\nways I can define this.\n\n63\n00:03:36.190 --> 00:03:40.646\nI can give it a space separated\nstring of attributes so\n\n64\n00:03:40.646 --> 00:03:45.900\nname, age, email, and\nwell, it actually worked.\n\n65\n00:03:45.900 --> 00:03:50.070\nLet's see what's stored in User, and\nnotice it constructs like class but\n\n66\n00:03:50.070 --> 00:03:53.220\nthe class is a subclass of tuple.\n\n67\n00:03:53.220 --> 00:03:57.833\nIt's a lot more straightforward, or\nnot necessarily straight forward but\n\n68\n00:03:57.833 --> 00:04:01.805\na lot quicker if I need something small,\na little more on a quick.\n\n69\n00:04:01.805 --> 00:04:06.738\nAnd provides the tuple like\nwonderfulness that I've grown to loved,\n\n70\n00:04:06.738 --> 00:04:11.922\nbut also it provides name fields instead\nof use those position of fields,\n\n71\n00:04:11.922 --> 00:04:15.340\ncouldn't get that out there for a moment.\n\n72\n00:04:15.340 --> 00:04:16.700\nBut how I can construct a User?\n\n73\n00:04:16.700 --> 00:04:22.670\nSo let's construct some_user, and\nnotice I'm using this capital U, User,\n\n74\n00:04:22.670 --> 00:04:27.910\nand I can do either positional arguments,\nwhich are based on the positions here.\n\n75\n00:04:29.010 --> 00:04:33.160\nSo, the first argument that I give\nwouldn't mat to the name field.\n\n76\n00:04:33.160 --> 00:04:36.690\nSo, John, but\nI would also do keyword arguments.\n\n77\n00:04:36.690 --> 00:04:40.180\nAnd this is my recommendation\nbecause it helps you remember.\n\n78\n00:04:40.180 --> 00:04:44.450\nAs you're looking through your code\nwhat's that a name and age or an email.\n\n79\n00:04:44.450 --> 00:04:48.330\nAnd also,\nyou can mix those up if you need to.\n\n80\n00:04:48.330 --> 00:04:55.360\nSo I'm gonna say age=31,\nemail='some@where.here').\n\n81\n00:04:55.360 --> 00:04:58.960\nSo, this is just like we had in\ntuple just a moment ago, but\n\n82\n00:04:58.960 --> 00:05:04.670\nnow if I run if I say some_user,\nwell it gives me a list\n\n83\n00:05:04.670 --> 00:05:09.780\nthat has named attributes, so\nhow I can get at those attributes?\n\n84\n00:05:09.780 --> 00:05:13.693\nWell, I can say some_user.name and\n\n85\n00:05:13.693 --> 00:05:17.848\nit gives me the name in that user object,\n\n86\n00:05:17.848 --> 00:05:22.994\nwell that's a lot nicer\nthan some_user [0].\n\n87\n00:05:22.994 --> 00:05:24.716\nBut here's the nice thing,\n\n88\n00:05:24.716 --> 00:05:29.168\nif you have existing code that already\nuses those positional arguments,\n\n89\n00:05:29.168 --> 00:05:33.110\nlike the 0 thing in a tuple, or\na tuple, then this still works.\n\n90\n00:05:33.110 --> 00:05:37.240\nSo, you get that 0 based indexing,\nbut you also get named fields.\n\n91\n00:05:37.240 --> 00:05:43.350\nIf I want some_user.age, well I can get\nbent but what if I try to change it?\n\n92\n00:05:45.380 --> 00:05:48.060\nLet's say 34, cannot set attribute and\n\n93\n00:05:48.060 --> 00:05:50.490\nthat's because tuples\nare immutable by nature.\n\n94\n00:05:50.490 --> 00:05:56.640\nBut, that leads us to an issue,\nif I need to modify some_user, right?\n\n95\n00:05:56.640 --> 00:05:57.918\nHow do I do that?\n\n96\n00:05:57.918 --> 00:06:01.680\nWell, main tuples come\nwith a few helper methods\n\n97\n00:06:01.680 --> 00:06:04.110\nto help us get these things in order.\n\n98\n00:06:04.110 --> 00:06:08.970\nSo, if I say\nsome_user._replace now in most\n\n99\n00:06:08.970 --> 00:06:13.220\nPython this means you shouldn't using this\nmethod but in the collections module under\n\n100\n00:06:13.220 --> 00:06:18.790\nname tuple, well this is available to us\nand it's recommended to documentation.\n\n101\n00:06:18.790 --> 00:06:22.090\nSo, let's say that it's been a year and\n\n102\n00:06:22.090 --> 00:06:26.200\nJohn has aged one year,\nso I need to replace that\n\n103\n00:06:27.710 --> 00:06:30.960\nbecause I'm going to use this to save to\na database or something of that nature.\n\n104\n00:06:32.010 --> 00:06:39.080\nSo, if I notice here, I get a user with a\nname John, age=32, email- some@where.here.\n\n105\n00:06:39.080 --> 00:06:40.660\nEverything looks the same.\n\n106\n00:06:40.660 --> 00:06:42.800\nWell it just, you said it was unmutable.\n\n107\n00:06:42.800 --> 00:06:48.690\nAnd in fact, what happens when you call\nunderscore replace, is I get a new one.\n\n108\n00:06:48.690 --> 00:06:53.382\nSo, I can use this kinda as a template for\n\n109\n00:06:53.382 --> 00:06:59.040\nanother user and\nsay some_user._replace and\n\n110\n00:06:59.040 --> 00:07:03.044\nI'm gonna say name equals Alice.\n\n111\n00:07:03.044 --> 00:07:08.290\nLet's just assume this is a whoopsy daisy,\nan entry mishap.\n\n112\n00:07:08.290 --> 00:07:11.800\nI know I need to update a couple of\nthe fields before you save it again.\n\n113\n00:07:13.000 --> 00:07:16.950\nI can say Alice and\nthe age is actually 27.\n\n114\n00:07:16.950 --> 00:07:19.450\nNotice I did not change the email.\n\n115\n00:07:19.450 --> 00:07:23.790\nBecause the email let's just pretend\nit should be the same email.\n\n116\n00:07:23.790 --> 00:07:31.192\nAnd another_user, well that is\nAlice age=27 with the same email.\n\n117\n00:07:31.192 --> 00:07:33.270\nBut what about some_user.\n\n118\n00:07:33.270 --> 00:07:34.329\nAnd that's still John.\n\n119\n00:07:34.329 --> 00:07:38.140\nAnd that's the wonderful\npart of having two pulls.\n\n120\n00:07:38.140 --> 00:07:40.650\nThey're immutable,\nthey're small, they're simple.\n\n121\n00:07:40.650 --> 00:07:42.350\nAnd now you get named fields.\n\n122\n00:07:42.350 --> 00:07:43.532\nSo if you want another user.\n\n123\n00:07:45.922 --> 00:07:48.640\nAnother_user.age.\n\n124\n00:07:48.640 --> 00:07:54.530\nWell, you can used named properties to\ngrab those attributes off of there.\n\n125\n00:07:54.530 --> 00:07:57.275\nAnd that makes your code\na great deal more readable.\n\n126\n00:07:57.275 --> 00:08:02.385\nBut, sometimes you're like the name tuple,\nor tuples were great ideas.\n\n127\n00:08:02.385 --> 00:08:06.865\nHow do I, there should be some\nway that I can inspect these,\n\n128\n00:08:06.865 --> 00:08:08.895\nunderstand these a little more.\n\n129\n00:08:08.895 --> 00:08:16.330\nAnd well, let's say some_user and I want\nit as a dictionary, as key value pairs.\n\n130\n00:08:16.330 --> 00:08:21.350\nAnd this is great if, for instance,\nyou need to create JSON from this name\n\n131\n00:08:21.350 --> 00:08:26.360\ntuple through a web server or some kind\nof web response that you're constructing.\n\n132\n00:08:26.360 --> 00:08:30.995\nWell, name tuple provides\nan asdict method,\n\n133\n00:08:30.995 --> 00:08:34.950\n_asdict, and\nif I do that I get an OrderedDict back.\n\n134\n00:08:34.950 --> 00:08:38.131\nAnd the reason being is,\norder matters here.\n\n135\n00:08:38.131 --> 00:08:40.876\nAnd we'll talk more about\nOrderedDicts in another episode.\n\n136\n00:08:40.876 --> 00:08:47.590\nSo I get name, John, age,\n31, email, somewhere.here.\n\n137\n00:08:47.590 --> 00:08:50.500\nSo I get a dictionary,\nand if I really wanted to,\n\n138\n00:08:50.500 --> 00:08:54.412\nI could make this a standard\ndictionary by saying\n\n139\n00:08:54.412 --> 00:08:59.170\n_asdict and\npassing that to the dictionary function.\n\n140\n00:08:59.170 --> 00:09:04.080\nAnd then I get 'name' : 'John',\n'age' : 31, 'email' : 'some@where.here.\n\n141\n00:09:04.080 --> 00:09:09.151\nSo I get those two, they're pretty nice\nmethods just for quick manipulation\n\n142\n00:09:09.151 --> 00:09:13.763\nof these tuples but finally,\nwhat if I just wanna list of attributes.\n\n143\n00:09:13.763 --> 00:09:15.943\nI wanna see how does this data look.\n\n144\n00:09:15.943 --> 00:09:17.777\nHow does it behave?\n\n145\n00:09:17.777 --> 00:09:24.404\nAnd if I say some_user._fields()\n\n146\n00:09:24.404 --> 00:09:29.632\nNot tuple ._fields, yeah.\n\n147\n00:09:29.632 --> 00:09:34.985\nFields.\nSo some_user._fields.\n\n148\n00:09:34.985 --> 00:09:39.650\nTuple object is not callable,\nwell that's odd.\n\n149\n00:09:39.650 --> 00:09:41.220\nWhy would that happen?\n\n150\n00:09:41.220 --> 00:09:46.570\nWell, it's actually not a method,\nit is instead just a property of tuple,\n\n151\n00:09:46.570 --> 00:09:51.270\nand notice tis coincide\nwith our original creation.\n\n152\n00:09:51.270 --> 00:09:56.660\nSo, be very careful because you\nare used to use _replace, _as date and\n\n153\n00:09:56.660 --> 00:10:00.390\nyou are like, field, this is gonna\ngive me a list of fields and a lot of\n\n154\n00:10:00.390 --> 00:10:05.490\nother places on Python that will be normal\nbut _fields is actually behind the scenes.\n\n155\n00:10:05.490 --> 00:10:08.170\nJust a tuple that gives you the names.\n\n156\n00:10:08.170 --> 00:10:12.500\nWell, just as a reminder,\nwhere did that come from again?\n\n157\n00:10:13.520 --> 00:10:19.860\nUser name age email, it's odd that it's\nput as a tuple, right, or a tuple.\n\n158\n00:10:19.860 --> 00:10:24.420\nName, age, and email and that's because\nnot only can you give it a space\n\n159\n00:10:24.420 --> 00:10:29.250\nseparated string but you can give\nit an iterable whether be tuple or\n\n160\n00:10:29.250 --> 00:10:32.320\nlist the hands seems that\nmakes this transformation.\n\n161\n00:10:32.320 --> 00:10:37.580\nSo I can say age, wait a minute,\nname cuz order matters\n\n162\n00:10:39.260 --> 00:10:43.510\nage and email and if I do that then User.\n\n163\n00:10:43.510 --> 00:10:45.660\nWell, everything looks fine.\n\n164\n00:10:45.660 --> 00:10:52.816\nAnd if I create another\nuser = user(name='Bob',\n\n165\n00:10:52.816 --> 00:11:02.130\nage=13, email='bob@bob.bob\nVery unique email there.\n\n166\n00:11:04.150 --> 00:11:06.790\nUser, gotta make sure you put\na capital letter in there.\n\n167\n00:11:08.050 --> 00:11:12.860\nThat's important and\nnotice that is a sign to the variable that\n\n168\n00:11:12.860 --> 00:11:17.730\nwe create with this name tuple\nconstructor or factory method.\n\n169\n00:11:17.730 --> 00:11:23.300\nAnd now if I say User, well I get name,\nage, and email Bob@bob.bob.\n\n170\n00:11:23.300 --> 00:11:26.300\nSo I can give it either\nan iterable of fields, or\n\n171\n00:11:26.300 --> 00:11:28.750\nI can give it a space separated string.\n\n172\n00:11:28.750 --> 00:11:33.840\nAnd behind the scenes that is stored\nin the underscore fields property.\n\n173\n00:11:33.840 --> 00:11:38.890\nSo as we've seen, name tuples allow\nus to name not only with space\n\n174\n00:11:38.890 --> 00:11:43.240\nseparated strings the fields, but also any\ntype of iterable trhat names the fields,\n\n175\n00:11:43.240 --> 00:11:48.040\nwhether it be a tuple or\na list, or something list like.\n\n176\n00:11:48.040 --> 00:11:51.270\nSo, that's a wonderful little\nlook into name tuples.\n\n177\n00:11:51.270 --> 00:11:54.700\nBut remember, we still have that\n0 based indexing that well,\n\n178\n00:11:54.700 --> 00:11:58.070\nyou've probably made use of if you\nuse tuples anywhere in your code.\n\n179\n00:11:58.070 --> 00:12:03.540\nBut also we have name fields, so user.name\nprovides us with, well the user name.\n\n180\n00:12:03.540 --> 00:12:08.510\nIn addition to we can look at _asdict and\n_replace as those little\n\n181\n00:12:08.510 --> 00:12:12.610\nhelper methods that get us either a new\nrepresentation of our name tuple or\n\n182\n00:12:12.610 --> 00:12:15.140\ncreate a new tuple with replacements.\n\n183\n00:12:15.140 --> 00:12:19.750\nAnd don't forget the _fields, just in\ncase you forget all of the properties\n\n184\n00:12:19.750 --> 00:12:23.100\nthat name tuples have originally\nbeen constructed with.\n\n185\n00:12:23.100 --> 00:12:25.690\nBut right now we're out of time.\n\n186\n00:12:25.690 --> 00:12:28.990\nDo join us for more into\nthe Python Standard Library, but for\n\n187\n00:12:28.990 --> 00:12:32.230\nnow, signing off for ITPro.TV,\nI'm Justin Dennison.\n\n188\n00:12:33.520 --> 00:12:35.477\nSee you next time.\n\n189\n00:12:35.477 --> 00:12:39.109\n[SOUND]\n\n",
          "vimeoId": "210978978"
        },
        {
          "description": "In this episode, Justin continues looking at the collections module with a special look into the defaultdict structure. The defaultdict allows you to create a default value when a key is addeded to the dictionary. Justin demonstrates how to use this structure to make partitioning of data more maintainable and readable.",
          "length": "925",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-2-the_collections_module_defaultdict-032917-PGM.00_15_19_27.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-2-the_collections_module_defaultdict-032917-PGM.00_15_19_27.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-2-the_collections_module_defaultdict-032917-PGM.00_15_19_27.Still001-sm.jpg",
          "title": "The collections Module: defaultdict",
          "transcript": "WEBVTT\n\n1\n00:00:00.025 --> 00:00:06.063\n[SOUND] Greetings, everyone, and welcome\nto another exciting episode of ITProTV.\n\n2\n00:00:06.063 --> 00:00:07.293\nI'm Justin Dennison, and\n\n3\n00:00:07.293 --> 00:00:11.230\nin today's episode we're gonna continue\nour look into the collections module.\n\n4\n00:00:11.230 --> 00:00:13.440\nIn particular, the default dict.\n\n5\n00:00:13.440 --> 00:00:16.470\nNow that's kind of a weird term.\n\n6\n00:00:16.470 --> 00:00:18.560\nAnd you've used this pattern\na little bit before,\n\n7\n00:00:18.560 --> 00:00:22.770\neven if you didn't know that the\ncollections module had this ability to it.\n\n8\n00:00:22.770 --> 00:00:25.480\nSo I think the best way to\nsee a solution to the problem\n\n9\n00:00:25.480 --> 00:00:27.360\nis to look at a problem first.\n\n10\n00:00:27.360 --> 00:00:31.105\nSo let's go ahead and take a look at my\nscreen, do a little bit of setup and then\n\n11\n00:00:31.105 --> 00:00:36.895\nwe'll use the default dict to make our\nlife easier and that's what's important.\n\n12\n00:00:36.895 --> 00:00:41.335\nSo I'm gonna hop onto my desktop and\nI have this collections module.\n\n13\n00:00:41.335 --> 00:00:46.430\nAnd within that I have some data and\nso I have three files.\n\n14\n00:00:46.430 --> 00:00:49.730\nAnd let's just take a look\nat what those files are.\n\n15\n00:00:49.730 --> 00:00:53.480\nSo I have commented words,\nheart rate log and words.txt.\n\n16\n00:00:53.480 --> 00:00:56.060\nAnd well what are we gonna do?\n\n17\n00:00:57.310 --> 00:01:01.000\nLet's look at words here and\nit's kind of formatted oddly.\n\n18\n00:01:01.000 --> 00:01:06.000\nBut all it is, is well a bunch of random\nletters that I've called words across and\n\n19\n00:01:06.000 --> 00:01:08.180\nthen new lines at the end.\n\n20\n00:01:08.180 --> 00:01:11.750\nOkay, how do I figure this out?\n\n21\n00:01:11.750 --> 00:01:12.530\nWhat do I want to do?\n\n22\n00:01:12.530 --> 00:01:16.190\nLet's say that I wanted to do\na frequency analysis on this and\n\n23\n00:01:16.190 --> 00:01:20.530\nI wanted to find the count of all\nof the letters on this page, right?\n\n24\n00:01:20.530 --> 00:01:24.640\nI wanna know how many Vs, how many As,\nhow many Fs are on the page.\n\n25\n00:01:24.640 --> 00:01:28.369\nAnd I'm gonna consider that uppercase and\nlowercase are different.\n\n26\n00:01:29.400 --> 00:01:31.420\nNow you may not have done\nthis in particular, but\n\n27\n00:01:31.420 --> 00:01:33.200\nwe'll look at another\nexample in just a moment.\n\n28\n00:01:34.780 --> 00:01:35.720\nHow do we do that?\n\n29\n00:01:35.720 --> 00:01:40.940\nWell let's take a look at the normal\nsolution using regular dictionaries, and\n\n30\n00:01:40.940 --> 00:01:46.030\nsee how our life gets a little more\ncomplicated then it should be.\n\n31\n00:01:46.030 --> 00:01:48.040\nSo I'm in data so I can make use of that.\n\n32\n00:01:48.040 --> 00:01:52.950\nI'm gonna look at python 3,\nI'm staying in 3 and\n\n33\n00:01:52.950 --> 00:01:57.040\nyou shouldn't hop into Python3\nif you're not already upgraded,\n\n34\n00:01:57.040 --> 00:01:58.880\nunless you have constraints\nwhere you can't.\n\n35\n00:01:58.880 --> 00:02:00.460\nThat's understandable.\n\n36\n00:02:00.460 --> 00:02:04.870\nSo I have with open.\n\n37\n00:02:06.100 --> 00:02:07.250\nAnd what was that called?\n\n38\n00:02:07.250 --> 00:02:09.700\nThat was called words.txt.\n\n39\n00:02:09.700 --> 00:02:12.540\nWords.txt.\n\n40\n00:02:12.540 --> 00:02:19.120\nAnd this is going to be a read as f, and\nI'm just gonna say letters equals list,\n\n41\n00:02:19.120 --> 00:02:24.432\nuh-oh, gotta make sure that's equals,\nlist(f.read).\n\n42\n00:02:27.357 --> 00:02:29.650\nAnd let's look at letters.\n\n43\n00:02:29.650 --> 00:02:32.440\nAnd well,\nit has now pulled apart of the letters.\n\n44\n00:02:32.440 --> 00:02:35.450\nSo I have a list of all\nthe letters in that document.\n\n45\n00:02:35.450 --> 00:02:36.200\nWell, that's nice.\n\n46\n00:02:36.200 --> 00:02:40.090\nHow do I get a count of all the As,\nall the Bs, all the Cs, upper and\n\n47\n00:02:40.090 --> 00:02:41.640\nlowercase being different?\n\n48\n00:02:41.640 --> 00:02:46.770\nWell, typically what people will do is\nsay something like char_count equals\n\n49\n00:02:46.770 --> 00:02:47.450\nempty dictionary.\n\n50\n00:02:47.450 --> 00:02:51.630\nAnd then start looping through for\nletter in letters.\n\n51\n00:02:53.770 --> 00:02:58.370\nIf the letter is not in char_count, and\n\n52\n00:02:58.370 --> 00:03:03.630\nwe have to do this because our dictionary\ncurrently has no keys available to it.\n\n53\n00:03:03.630 --> 00:03:09.500\nIf it's not already in char_count, and you\nhave to spell it right, that's important.\n\n54\n00:03:09.500 --> 00:03:14.325\nIf not letter in char_count,\nthen what do I wanna do?\n\n55\n00:03:14.325 --> 00:03:18.990\nI wanna say char_count[letter] = 1.\n\n56\n00:03:18.990 --> 00:03:21.593\nAnd that's because I've found\nthe first letter, right?\n\n57\n00:03:21.593 --> 00:03:23.870\nI've found the first a or the first b.\n\n58\n00:03:23.870 --> 00:03:26.204\nSo I'm starting that at one.\n\n59\n00:03:26.204 --> 00:03:32.600\nOtherwise, char_count[letter]\n\n60\n00:03:32.600 --> 00:03:37.680\n+= 1,\nI want to increment every time I find one.\n\n61\n00:03:37.680 --> 00:03:41.850\nAnd well,\nI think that'll actually solve our case.\n\n62\n00:03:41.850 --> 00:03:44.350\nIf you spell letter correctly.\n\n63\n00:03:44.350 --> 00:03:46.370\nWow, I'm just full of typos today.\n\n64\n00:03:46.370 --> 00:03:51.820\nSo that is the downside\nof typing very quickly.\n\n65\n00:03:51.820 --> 00:03:59.468\nSo char_count(letter) = 1 Otherwise,\n\n66\n00:04:02.253 --> 00:04:06.154\nchar_count[letter] +=1.\n\n67\n00:04:06.154 --> 00:04:11.068\nAnd, well,\nlet's see what char_count is now.\n\n68\n00:04:11.068 --> 00:04:15.120\nChar_count, well,\nI have 178 lowercase v's,\n\n69\n00:04:15.120 --> 00:04:20.580\n194 lowercase r's, 194 upper case f's and\n\n70\n00:04:20.580 --> 00:04:25.630\nthis works, it solves our problem but\nin a more complex\n\n71\n00:04:25.630 --> 00:04:32.130\nsituation where you are trying to divvy up\npieces, do like a partition or a count.\n\n72\n00:04:32.130 --> 00:04:36.700\nIf not letter and char_count, this check,\nthat's kind of weird because what do want?\n\n73\n00:04:36.700 --> 00:04:41.580\nWe want this to default to an integer,\neven if it's not there.\n\n74\n00:04:41.580 --> 00:04:46.690\nSo if the key is there then increment it,\nif it's not there it should be an integer,\n\n75\n00:04:46.690 --> 00:04:50.720\nand I have to set this to one to make\nsure that my count works appropriately,\n\n76\n00:04:50.720 --> 00:04:53.980\ncuz after I found the first one\nI have to already count that.\n\n77\n00:04:55.490 --> 00:04:59.840\nSo how do we make this\nwork a little better?\n\n78\n00:04:59.840 --> 00:05:01.630\nSo in the collections module,\n\n79\n00:05:01.630 --> 00:05:07.410\nthere is a national data\nstructure called the default dict.\n\n80\n00:05:07.410 --> 00:05:11.820\nAnd what it allows us to do,\nis create a default factory, for\n\n81\n00:05:11.820 --> 00:05:15.820\nwhat's going to be associated\nwith the key, if it's not there.\n\n82\n00:05:15.820 --> 00:05:19.520\nNow, that's mouthful, let's actually\nsee how this works in real time.\n\n83\n00:05:19.520 --> 00:05:20.020\nFrom collections.\n\n84\n00:05:23.062 --> 00:05:26.250\nImport defaultdict.\n\n85\n00:05:26.250 --> 00:05:28.760\nAnd, well, let's create the defaultdict.\n\n86\n00:05:28.760 --> 00:05:32.310\nI'm gonna create char_count, so\n\n87\n00:05:32.310 --> 00:05:36.500\nI'm overriding the previous char_count,\nand I'm gonna say defaultdict(.\n\n88\n00:05:36.500 --> 00:05:41.020\nAnd then this takes some kind of structure\n\n89\n00:05:41.020 --> 00:05:46.090\nthat just did the default representation\nfor a key when it's added.\n\n90\n00:05:46.090 --> 00:05:49.010\nI'm gonna say an int,\nbecause I want to do a count.\n\n91\n00:05:49.010 --> 00:05:53.390\nSo by default, when I add the first a,\nthat's going to go into 0.\n\n92\n00:05:53.390 --> 00:05:56.490\nOr if it's not there and\nI try to access it,\n\n93\n00:05:56.490 --> 00:06:02.430\nit will put a 0, a = 0, so\nthe key value pair is a and 0.\n\n94\n00:06:02.430 --> 00:06:05.950\nAnd then I can just well,\nI can just go about my business.\n\n95\n00:06:05.950 --> 00:06:07.030\nSo there's char_count.\n\n96\n00:06:07.030 --> 00:06:09.640\nLet's look at that to see what it says.\n\n97\n00:06:09.640 --> 00:06:10.770\nDefaultdict.\n\n98\n00:06:10.770 --> 00:06:13.805\nIt takes an integer, and\nit is empty right now.\n\n99\n00:06:13.805 --> 00:06:19.970\nOkay, well, let's just do a quick assign,\nto see how this works.\n\n100\n00:06:19.970 --> 00:06:23.700\nSo char_count.\n\n101\n00:06:23.700 --> 00:06:26.090\nAnd well, there's no A in there, right?\n\n102\n00:06:27.540 --> 00:06:29.269\nAnd I want to say += 1.\n\n103\n00:06:29.269 --> 00:06:33.136\nI didn't get an error, I would have\ngotten this in a regular dictionary.\n\n104\n00:06:33.136 --> 00:06:35.863\nAnd if I say char_count now,\n\n105\n00:06:35.863 --> 00:06:41.310\nnotice that I have an A of one,\nI plus equaled nothing.\n\n106\n00:06:41.310 --> 00:06:42.280\nHow did I get that?\n\n107\n00:06:42.280 --> 00:06:46.700\nThat's because the integers says I'm\ngonna give you the base, the zero,\n\n108\n00:06:46.700 --> 00:06:51.980\nthe nothing portion of what\nan integer is and now I get a+=1.\n\n109\n00:06:51.980 --> 00:06:56.180\nSo you can already start to see this is\ngonna make our life a little bit easier.\n\n110\n00:06:56.180 --> 00:07:00.770\nAnd now I'm just going to restart\nchar_count to nothing and\n\n111\n00:07:00.770 --> 00:07:03.278\ngo back and resolve our same problem.\n\n112\n00:07:03.278 --> 00:07:06.110\nSo there's char_count,\nthere's nothing in there.\n\n113\n00:07:06.110 --> 00:07:11.292\nAnd now if I can say for\nletter in letters,\n\n114\n00:07:11.292 --> 00:07:14.704\nchar_count[letter].\n\n115\n00:07:17.079 --> 00:07:18.760\nPlus equals 1.\n\n116\n00:07:18.760 --> 00:07:26.360\nWell letters well that's still letters,\nbut what about char_count?\n\n117\n00:07:26.360 --> 00:07:32.360\nAnd notice I have 178 V's,\n194 lower case r's, 194 upper case F's.\n\n118\n00:07:32.360 --> 00:07:35.010\nI get the exact same output as I did,\n\n119\n00:07:35.010 --> 00:07:38.670\nlet me see if I can get it after\nI put all these letters here.\n\n120\n00:07:38.670 --> 00:07:39.800\nI don't know if I can.\n\n121\n00:07:41.670 --> 00:07:44.020\nAnd let me scroll up, there it is.\n\n122\n00:07:44.020 --> 00:07:48.260\nAnd I get the exact same thing as I\ndid with the regular dictionary, but\n\n123\n00:07:48.260 --> 00:07:53.390\nnotice way less code, and\na great deal more readable.\n\n124\n00:07:54.890 --> 00:07:58.746\nBecause all I had was for\nletter in letters,\n\n125\n00:07:58.746 --> 00:08:03.860\nchar_count[letter] += 1,\nand that was easy.\n\n126\n00:08:03.860 --> 00:08:09.040\nNow I've double counted those now,\nso I'm kind of in a whoopsy daisy.\n\n127\n00:08:09.040 --> 00:08:10.970\nBut this is a lot less air prone.\n\n128\n00:08:10.970 --> 00:08:13.230\nA lot easier to reason about.\n\n129\n00:08:13.230 --> 00:08:15.630\nBut this is not the only\nthing that solves.\n\n130\n00:08:15.630 --> 00:08:17.630\nLet's take a look at a little\nbit different problem.\n\n131\n00:08:17.630 --> 00:08:19.648\nAnd this is where the default dict shines.\n\n132\n00:08:19.648 --> 00:08:23.290\nBecause as we'll find out the collections\nmodule has a couple of other tools that\n\n133\n00:08:23.290 --> 00:08:27.760\nmay solve this particular problem that\nwe just solved a little better, but\n\n134\n00:08:27.760 --> 00:08:29.600\nit's a good first approximation.\n\n135\n00:08:29.600 --> 00:08:33.574\nSo I'm gonna clear, hop back into Python3,\nand say from collections.\n\n136\n00:08:35.902 --> 00:08:37.150\nImport the defaultdict.\n\n137\n00:08:38.530 --> 00:08:42.500\nWell with open, and instead of words,\n\n138\n00:08:42.500 --> 00:08:47.610\nI'm gonna hop over here and\ntake a look at, well, commented words.\n\n139\n00:08:47.610 --> 00:08:49.540\nNow what is commented words?\n\n140\n00:08:49.540 --> 00:08:52.980\nWell, if you've ever had\nto process information,\n\n141\n00:08:52.980 --> 00:08:56.120\nsometimes you'll see this little\ncharacter at the beginning.\n\n142\n00:08:56.120 --> 00:08:59.530\nIn Python it's a lot of times\nan octothorpe, or a hashtag, or\n\n143\n00:08:59.530 --> 00:09:00.235\na pound symbol.\n\n144\n00:09:00.235 --> 00:09:04.840\n[LAUGH] Those are all the same names for\nthe same thing, or all different names for\n\n145\n00:09:04.840 --> 00:09:05.400\nthe same thing.\n\n146\n00:09:05.400 --> 00:09:07.480\nThat's an important distinction.\n\n147\n00:09:07.480 --> 00:09:10.220\nThat means ignore this, right.\n\n148\n00:09:10.220 --> 00:09:15.090\nWell, it would be nice if I could\npartition those into individual pieces.\n\n149\n00:09:16.890 --> 00:09:17.610\nRight?\n\n150\n00:09:17.610 --> 00:09:22.680\nI need all the commented lines over here,\nall the uncommented lines over here.\n\n151\n00:09:22.680 --> 00:09:25.780\nAnd, well, I can do something\nsimilar that I did with the count.\n\n152\n00:09:25.780 --> 00:09:31.150\nWhere I could say if it's not there and\nit starts with hashtag, then do this.\n\n153\n00:09:31.150 --> 00:09:34.180\nOtherwise, do this.\n\n154\n00:09:34.180 --> 00:09:39.120\nSo that, we start to end up with those\nnested pieces of logic that just\n\n155\n00:09:39.120 --> 00:09:42.920\nmake our problem a lot more interprone,\na lot harder to reason about, but\n\n156\n00:09:42.920 --> 00:09:47.770\nthe default dict allows us to, well,\nit allows us to simplify that.\n\n157\n00:09:47.770 --> 00:09:49.355\nSo, let's see.\n\n158\n00:09:49.355 --> 00:09:54.112\nSo with commented_words,\nI think that's what\n\n159\n00:09:54.112 --> 00:09:58.651\nit's called yep, commented_words.txt.\n\n160\n00:09:58.651 --> 00:10:03.500\nI'm going to read and\nthis one's gonna be a little bit different\n\n161\n00:10:03.500 --> 00:10:07.120\nbecause I don't wanna read in letter by\nletter, I wanna read in line by line.\n\n162\n00:10:08.760 --> 00:10:15.120\nSo let's see if I can get\nlines = f.readlines().\n\n163\n00:10:15.120 --> 00:10:17.500\nAnd well let's see lines there we go.\n\n164\n00:10:17.500 --> 00:10:22.300\nNow I have a new line character at\nthe end of every line as you see.\n\n165\n00:10:22.300 --> 00:10:23.770\nI can filter that out.\n\n166\n00:10:23.770 --> 00:10:26.480\nWe're not gonna worry about it for\nthis exercise.\n\n167\n00:10:26.480 --> 00:10:28.110\nSo what do I want?\n\n168\n00:10:28.110 --> 00:10:32.530\nI want the partition,\nthe commented words partition.\n\n169\n00:10:32.530 --> 00:10:35.280\nOr better yet\nlet's just call it the words partition,\n\n170\n00:10:35.280 --> 00:10:38.140\nand you'll see what I\nmean in just a moment.\n\n171\n00:10:38.140 --> 00:10:41.950\nSo default dict, that's gonna take a list.\n\n172\n00:10:41.950 --> 00:10:43.560\nAnd what does that mean?\n\n173\n00:10:43.560 --> 00:10:47.040\nIt means if I don't have\nsomething already there.\n\n174\n00:10:47.040 --> 00:10:47.830\nRight?\n\n175\n00:10:47.830 --> 00:10:50.440\nIf it's not, if it's not already there,\n\n176\n00:10:51.790 --> 00:10:56.180\nthen create a list and\nI can do list type operations.\n\n177\n00:10:56.180 --> 00:11:04.180\nSo if I look at words_partition,\nwell there's a class of list.\n\n178\n00:11:04.180 --> 00:11:09.288\nAnd I can do things like this,\nwords Partition\n\n179\n00:11:09.288 --> 00:11:17.761\n['commented'].append ( # blah, blah).\n\n180\n00:11:17.761 --> 00:11:23.550\nAnd notice I'm calling .append because\nby default I'm going to get a list\n\n181\n00:11:23.550 --> 00:11:25.700\nobject back when I call this key.\n\n182\n00:11:25.700 --> 00:11:27.620\nEven though it's not already there.\n\n183\n00:11:27.620 --> 00:11:28.995\nIf I look at words_partition now.\n\n184\n00:11:31.904 --> 00:11:35.337\nI will see that commented has\na list associated with it,\n\n185\n00:11:35.337 --> 00:11:38.080\nwith the commented word there.\n\n186\n00:11:38.080 --> 00:11:41.810\nNow, I'm gonna reset this,\nand lets sequester.\n\n187\n00:11:41.810 --> 00:11:42.750\nI want commented and\n\n188\n00:11:42.750 --> 00:11:47.440\nuncommented pieces kind of pulled apart,\nand well I think we're good to go.\n\n189\n00:11:47.440 --> 00:11:51.550\nSo for line in lines\n\n190\n00:11:54.320 --> 00:11:59.866\nIf line.starts_with, I think that's right.\n\n191\n00:11:59.866 --> 00:12:02.238\nHashtag.\n\n192\n00:12:02.238 --> 00:12:12.065\nThen words_partition commented.\n\n193\n00:12:12.065 --> 00:12:18.349\nAppend line, else,\n\n194\n00:12:18.349 --> 00:12:24.630\nwords partition.\n\n195\n00:12:24.630 --> 00:12:25.490\nGotta spell it right.\n\n196\n00:12:26.650 --> 00:12:34.560\nUncommented, or\nlet's just call that normal.append(line).\n\n197\n00:12:34.560 --> 00:12:36.740\nAnd notice this logic's\nfairly easy to follow.\n\n198\n00:12:36.740 --> 00:12:42.990\nIf it starts with an underscore, or\nexcuse me, hashtag then put it here and\n\n199\n00:12:42.990 --> 00:12:48.370\nif it starts with, well, anything\nelse let's just say that it's normal.\n\n200\n00:12:48.370 --> 00:12:51.650\nAnd string object has no\nattributes starts with.\n\n201\n00:12:51.650 --> 00:12:57.410\nLet's do a quick inspection of string,\nand starts with starts up.\n\n202\n00:12:57.410 --> 00:13:00.070\nNo underscore, whoopsy daisy.\n\n203\n00:13:00.070 --> 00:13:02.670\nSo there we go for lines and lines.\n\n204\n00:13:03.700 --> 00:13:06.660\nIf line dot, no underscore there.\n\n205\n00:13:06.660 --> 00:13:08.410\nImportant distinction.\n\n206\n00:13:08.410 --> 00:13:09.780\nWe can't all be infallible.\n\n207\n00:13:10.860 --> 00:13:12.760\nThen I want to put that in the commented.\n\n208\n00:13:14.320 --> 00:13:17.600\nOtherwise I want to put\nthis in the normal.\n\n209\n00:13:17.600 --> 00:13:24.620\nWell let's see what words_partition,\n\n210\n00:13:24.620 --> 00:13:29.320\nand while it's kind of hard to see,\nbut if we scroll up here,\n\n211\n00:13:30.610 --> 00:13:34.050\nnotice I have a commented list, and\n\n212\n00:13:34.050 --> 00:13:42.520\nI can say words_partition(commented),\nand I get a list.\n\n213\n00:13:43.850 --> 00:13:46.027\nOkay let's look at this last\nword to see if it's different.\n\n214\n00:13:46.027 --> 00:13:53.422\nIt starts e k h and\nif I say words_partition normal.\n\n215\n00:13:53.422 --> 00:13:58.140\nI hit a fat fingered enter there.\n\n216\n00:13:58.140 --> 00:14:01.550\nNotice normal aren't all the normal words.\n\n217\n00:14:01.550 --> 00:14:04.050\nSo we're then able to\nsequester that apart.\n\n218\n00:14:04.050 --> 00:14:08.800\nNow this is a very simple example but\nyou can see the power in this if I need to\n\n219\n00:14:08.800 --> 00:14:13.310\nstart pulling pieces apart like things\nthat are divisible by one, two and three.\n\n220\n00:14:13.310 --> 00:14:14.610\nWell, not divisible.\n\n221\n00:14:14.610 --> 00:14:17.940\nBut what is the remainder\nwhen divided by three?\n\n222\n00:14:17.940 --> 00:14:19.750\nEither zero, one or two.\n\n223\n00:14:19.750 --> 00:14:24.150\nSo I can start segregating\nthese into different piles, and\n\n224\n00:14:24.150 --> 00:14:27.010\nthis is a great way because\nit simplifies the logic.\n\n225\n00:14:27.010 --> 00:14:30.570\nSo if you haven't used the default dict,\nyou should definitely check it out.\n\n226\n00:14:30.570 --> 00:14:34.270\nSo let's review about\nwhat our problems were.\n\n227\n00:14:34.270 --> 00:14:40.110\nWe had to figure out, well, if I use\na regular dictionary, I have to input that\n\n228\n00:14:40.110 --> 00:14:43.870\nkey and handle whether it's there or not\nbecause otherwise I would get a key error.\n\n229\n00:14:43.870 --> 00:14:47.010\nWith the default dict,\nI can give a default data structure.\n\n230\n00:14:47.010 --> 00:14:52.910\nSo just a list, an int, or maybe even\na string, and I get the base level.\n\n231\n00:14:52.910 --> 00:14:54.240\nFor a list, I get an empty list.\n\n232\n00:14:54.240 --> 00:14:55.980\nFor an int, I get zero.\n\n233\n00:14:55.980 --> 00:14:58.980\nFor a float, I would get 0.0, so on and so\n\n234\n00:14:58.980 --> 00:15:01.990\nforth and\nnow I can start this partitioning.\n\n235\n00:15:01.990 --> 00:15:04.250\nAnd that's incredibly powerful.\n\n236\n00:15:04.250 --> 00:15:06.500\nSo definitely check out default deck.\n\n237\n00:15:06.500 --> 00:15:10.630\nIt's made my life a great deal easier,\nbut definitely stay tuned as\n\n238\n00:15:10.630 --> 00:15:14.860\nwe continue our look into the collections\nmodule and into the standard library.\n\n239\n00:15:14.860 --> 00:15:17.587\nBut for now, signing off for\nITProTV, I'm Justin Dennison.\n\n240\n00:15:17.587 --> 00:15:19.554\nWe'll see you next time.\n\n241\n00:15:19.554 --> 00:15:23.708\n[SOUND]\n\n",
          "vimeoId": "210977670"
        },
        {
          "description": "In this episode, Justin takes a closer look at the Counter structure for creating a distribution of frequency of elements from an iterable. The Counter provides additional methods to find the most common elements as well as interacting with multiple Counter instances.",
          "length": "661",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-3-the_collections_module_counter-032917-PGM.00_11_21_21.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-3-the_collections_module_counter-032917-PGM.00_11_21_21.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-3-3-the_collections_module_counter-032917-PGM.00_11_21_21.Still001-sm.jpg",
          "title": "The collections Module: Counter",
          "transcript": "WEBVTT\n\n1\n00:00:00.025 --> 00:00:02.533\n[MUSIC]\n\n2\n00:00:02.533 --> 00:00:06.582\nGreetings, everyone, and welcome to\nanother exciting episode of ITProTV,\n\n3\n00:00:06.582 --> 00:00:08.060\nI'm Justin Dennison.\n\n4\n00:00:08.060 --> 00:00:11.750\nAnd in today's episode we are continuing\nour look at the collections module because\n\n5\n00:00:11.750 --> 00:00:13.550\nwell, it's chocked full of tools.\n\n6\n00:00:13.550 --> 00:00:16.248\nIf you ever looked at some\nof those other episodes,\n\n7\n00:00:16.248 --> 00:00:19.400\nthen definitely go check out\ndefaultdict and namedtuple.\n\n8\n00:00:19.400 --> 00:00:21.860\nOr a name, tuple,\nhowever you wanna say it.\n\n9\n00:00:21.860 --> 00:00:25.550\nBut in the default dict episode\nwe actually saw frequency counts,\n\n10\n00:00:25.550 --> 00:00:27.080\nhow I can count things.\n\n11\n00:00:27.080 --> 00:00:30.930\nAnd this is such a common pattern\nthat in the collections module you\n\n12\n00:00:30.930 --> 00:00:32.440\nkinda get this utility for free.\n\n13\n00:00:32.440 --> 00:00:35.890\nAnd what's amazing is it\nbehaves just like a dictionary.\n\n14\n00:00:35.890 --> 00:00:38.670\nBut provides some wonderful methods for\nus.\n\n15\n00:00:38.670 --> 00:00:41.186\nAnd it's actually called\nthe counter data structure.\n\n16\n00:00:41.186 --> 00:00:44.508\nSo let's go ahead and take a look,\nlet's take a look on my screen here and\n\n17\n00:00:44.508 --> 00:00:46.640\ndo a little bit of setup,\nand see where we are.\n\n18\n00:00:46.640 --> 00:00:50.910\nSo we're still in this data file,\nand commented_words, heatrate_log.\n\n19\n00:00:50.910 --> 00:00:52.858\nWell let's take a look at what those are.\n\n20\n00:00:52.858 --> 00:00:57.394\nWell here's commented_words, and I'm not\ngonna worry about it this time round but\n\n21\n00:00:57.394 --> 00:00:59.476\nlet's take a look at heartrate_log.\n\n22\n00:00:59.476 --> 00:01:06.629\nAnd all it is, is on new lines in a by\nsecond, excuse me, by minute heartrate.\n\n23\n00:01:06.629 --> 00:01:08.943\nSo 648104, so I get numbers,\n\n24\n00:01:08.943 --> 00:01:13.809\nthese are technically represented in\nthe strings because they are in a file.\n\n25\n00:01:14.990 --> 00:01:19.341\nBut also I have this words, and\nthat's just, I call them words.\n\n26\n00:01:19.341 --> 00:01:24.035\nIt's just a bunch of letters strewn\nacross of equal length on new lines.\n\n27\n00:01:24.035 --> 00:01:27.100\nWell I wanna do a frequency\nanalysis on this.\n\n28\n00:01:27.100 --> 00:01:31.910\nIf you do any type of cryptography or\nsecurity you've heard of this\n\n29\n00:01:31.910 --> 00:01:34.870\nfrequency analysis technique\nwhere I can count numbers and\n\n30\n00:01:34.870 --> 00:01:37.120\nfind out the distribution of those.\n\n31\n00:01:37.120 --> 00:01:40.380\nOr count letters and find out\nthe distribution within a document and\n\n32\n00:01:40.380 --> 00:01:45.360\nmake reasonable guesses about what letter\nthat has been, what plain text letter,\n\n33\n00:01:45.360 --> 00:01:46.970\nthe cypher text relates to.\n\n34\n00:01:46.970 --> 00:01:49.720\nSo this is a common use case and\n\n35\n00:01:49.720 --> 00:01:52.130\nwe've already seen this in\nthe default dict episode.\n\n36\n00:01:52.130 --> 00:01:55.270\nBut let's see how this changes\nnow with this new data structure.\n\n37\n00:01:55.270 --> 00:01:56.264\nSo I'm gonna say Python3.\n\n38\n00:01:56.264 --> 00:02:02.770\nI'm in a ruffle and\nfrom collections import Counter.\n\n39\n00:02:02.770 --> 00:02:07.160\nWell, I didn't get any errors,\nso looks like I'm good to go.\n\n40\n00:02:07.160 --> 00:02:11.559\nAnd with open words.txt,\n\n41\n00:02:11.559 --> 00:02:15.007\nI'm gonna read as f.\n\n42\n00:02:15.007 --> 00:02:17.718\nAnd, well, what do I want?\n\n43\n00:02:17.718 --> 00:02:22.870\nI want the frequency, and this is\nhow it's gonna differ a little bit.\n\n44\n00:02:22.870 --> 00:02:27.191\nThis is gonna be the counter of f.read.\n\n45\n00:02:27.191 --> 00:02:32.310\nSo I'm just reading in, and it's gonna\nread in as a giant string, as the content.\n\n46\n00:02:34.020 --> 00:02:36.600\nAnd now, well let's see what frequency is.\n\n47\n00:02:37.890 --> 00:02:41.059\nFrequency is the count of those letters.\n\n48\n00:02:41.059 --> 00:02:43.650\nAnd let's see here.\n\n49\n00:02:43.650 --> 00:02:45.250\nLet's find the lowercase v.\n\n50\n00:02:45.250 --> 00:02:48.801\nWell the wonderful thing about the\ncounter, these are in a different order\n\n51\n00:02:48.801 --> 00:02:52.620\nthan they were in the previous episode,\nso I wanna compare these.\n\n52\n00:02:52.620 --> 00:02:56.400\nI know that the just\nlike uppercase F was 194.\n\n53\n00:02:56.400 --> 00:03:01.170\nIt behaves just like dictionary because\ntechnically behind the scenes it\n\n54\n00:03:01.170 --> 00:03:05.820\nis a subclass of the standard\ndict data structure.\n\n55\n00:03:05.820 --> 00:03:09.600\nSo, frequency and\nI can use dictionary type methods on it,\n\n56\n00:03:11.000 --> 00:03:13.940\nsuch as the key value lookup.\n\n57\n00:03:13.940 --> 00:03:19.944\nBut also like get('F'),\nwhere I can define a default fallback,\n\n58\n00:03:19.944 --> 00:03:25.014\nso it gives me that, but\nif I use something that I know is not\n\n59\n00:03:25.014 --> 00:03:30.002\nin that file, like the asterisk,\nnotice I return None.\n\n60\n00:03:30.002 --> 00:03:32.941\nSo I get those whatever you've\ndone with a dictionary before,\n\n61\n00:03:32.941 --> 00:03:36.945\nyou can still use Because of the counter\nbecause technically they are dictionaries.\n\n62\n00:03:36.945 --> 00:03:38.945\nThey are a type of dictionaries.\n\n63\n00:03:38.945 --> 00:03:44.135\nBut what counter provides for\nus are interesting methods, right?\n\n64\n00:03:44.135 --> 00:03:49.183\nSo if I say frequency + frequency so\nif I run two different processes and\n\n65\n00:03:49.183 --> 00:03:52.296\nI'm doing counts on two\ndifferent files and\n\n66\n00:03:52.296 --> 00:03:56.416\nthen I just want to aggregate\nthose counts I can use plus and\n\n67\n00:03:56.416 --> 00:04:01.570\nit will actually add all of the counts\ntogether and give me a new counter.\n\n68\n00:04:01.570 --> 00:04:06.310\nThat's incredibly powerful because\nwell this is a great time for\n\n69\n00:04:06.310 --> 00:04:10.130\nlike map reduce jobs where I just get\na count back as a data structure,\n\n70\n00:04:10.130 --> 00:04:13.900\nput them together and\nboom I have an aggregate.\n\n71\n00:04:13.900 --> 00:04:17.970\nIn addition to I can say\nfrequency- frequency,\n\n72\n00:04:19.290 --> 00:04:23.120\nand I get an empty counter, because\nit's the exact same thing, I get zero.\n\n73\n00:04:23.120 --> 00:04:26.240\nSo plus and minus work,\nwhich is kinda crazy.\n\n74\n00:04:26.240 --> 00:04:28.320\nYou can't do this with\na normal dictionary,\n\n75\n00:04:28.320 --> 00:04:30.190\nyou have to do some other machinations.\n\n76\n00:04:30.190 --> 00:04:36.156\nIn addition to, I just wanna know, well I\njust wanna know the five most frequent or\n\n77\n00:04:36.156 --> 00:04:41.100\nmost common things, then well most\ncommon is a method on a counter.\n\n78\n00:04:41.100 --> 00:04:45.290\nSo if we look at frequency.most_common.\n\n79\n00:04:45.290 --> 00:04:49.360\nThey allowed you to use this on\nvarious games and game shows.\n\n80\n00:04:49.360 --> 00:04:51.300\nYou might be at an unfair advantage.\n\n81\n00:04:51.300 --> 00:04:52.400\nSo if I look at most common,\n\n82\n00:04:52.400 --> 00:04:57.090\nit will actually return this\nas a list of tuples or tuples.\n\n83\n00:04:58.290 --> 00:05:02.693\nSo P is 213 and thats because\nwell you can get similar type\n\n84\n00:05:02.693 --> 00:05:07.361\nthings out of a dictionary but\nwhat if I want the five most common.\n\n85\n00:05:07.361 --> 00:05:11.664\nWell it gives me the five most\ncommon based on the count associated\n\n86\n00:05:11.664 --> 00:05:13.100\nwith this key.\n\n87\n00:05:13.100 --> 00:05:17.640\nAnd now my frequency analysis\nhas become a great deal easier.\n\n88\n00:05:17.640 --> 00:05:22.720\nIf I do however want to know just\na little bit more about frequency.\n\n89\n00:05:22.720 --> 00:05:27.048\nThen I can say, elements and\nit gives me a chain object.\n\n90\n00:05:27.048 --> 00:05:29.580\nAnd let's just list that out.\n\n91\n00:05:29.580 --> 00:05:31.249\nIter tools chain is an iterator.\n\n92\n00:05:31.249 --> 00:05:34.560\nIf you haven't checked out the iter tools\nepisodes, definitely go check those out.\n\n93\n00:05:34.560 --> 00:05:38.050\nI talked about chain and\nhow useful it can be.\n\n94\n00:05:38.050 --> 00:05:43.116\nAnd boom, it actually gives me back\nevery instance in the collection.\n\n95\n00:05:43.116 --> 00:05:47.198\nAnd if I'm not mistaken,\nI could be wrong here what it does is it\n\n96\n00:05:47.198 --> 00:05:52.330\ntakes the count and just repeats that\nelement that many times in the list.\n\n97\n00:05:52.330 --> 00:05:53.834\nAnd this is incredibly powerful.\n\n98\n00:05:53.834 --> 00:05:57.177\nSo we've seen that we can add,\nsubtract, but\n\n99\n00:05:57.177 --> 00:06:01.035\nhow does this help us\nin In different times.\n\n100\n00:06:01.035 --> 00:06:03.025\nWell, let's look at a little\nbit different problem.\n\n101\n00:06:03.025 --> 00:06:06.605\nLet's say you're doing it from data\nanalysis or PhD dissertation or\n\n102\n00:06:06.605 --> 00:06:11.095\nsome medical research or you're just doing\nsome health monitoring, so to speak.\n\n103\n00:06:11.095 --> 00:06:15.425\nSo I'm gonna clear out of this repo open\na new one and make sure I'm in Python 3.\n\n104\n00:06:15.425 --> 00:06:19.045\nThis has been around I\nthink since Python 2.7.\n\n105\n00:06:19.045 --> 00:06:24.435\nDon't quote me on that, but\nit is available in Python 3, all versions.\n\n106\n00:06:24.435 --> 00:06:32.537\nSo from collections import Counter and\nwith open.\n\n107\n00:06:32.537 --> 00:06:34.666\nI wanna read in that heartrate.\n\n108\n00:06:34.666 --> 00:06:39.170\nLet me make sure heartrate_log.txt.\n\n109\n00:06:39.170 --> 00:06:42.468\nheartrate_log.txt.\n\n110\n00:06:42.468 --> 00:06:46.470\nAnd this is a read as f.\n\n111\n00:06:46.470 --> 00:06:47.440\nAnd what do I want?\n\n112\n00:06:47.440 --> 00:06:54.460\nWell I want all of the lines there, and\nthose are going to be measurements.\n\n113\n00:06:54.460 --> 00:07:01.168\nSo measurements = f.read.\n\n114\n00:07:01.168 --> 00:07:05.840\nAnd I could use read lines here, but I'm\ngoing to split on the new line character,\n\n115\n00:07:05.840 --> 00:07:10.870\njust so I can strip those off the back end\nbecause I want these to be pure numbers.\n\n116\n00:07:10.870 --> 00:07:17.570\nAnd if we look at measurements,\nWell there's all of my numbers.\n\n117\n00:07:17.570 --> 00:07:20.300\nAnd well, that's, that's a lot of numbers.\n\n118\n00:07:20.300 --> 00:07:23.304\nI've been taking measurements about\nmy heartrate for a long time.\n\n119\n00:07:23.304 --> 00:07:29.660\nBut now I want to know, what is the most\ncommon aspect of my heart rate?\n\n120\n00:07:29.660 --> 00:07:32.613\nOr how many times is it\n60 beats per minute, and\n\n121\n00:07:32.613 --> 00:07:37.512\nhow many times, what is the distribution,\nso to speak, so I can start knowing,\n\n122\n00:07:37.512 --> 00:07:39.334\nis my health good or is it bad?\n\n123\n00:07:39.334 --> 00:07:44.826\nSo, I can say heartrate = Counter and\n\n124\n00:07:44.826 --> 00:07:49.080\ngive it the measurements.\n\n125\n00:07:49.080 --> 00:07:52.640\nI can give this any iterable\nthat can be counted.\n\n126\n00:07:52.640 --> 00:07:53.590\nIt has to be iterable.\n\n127\n00:07:53.590 --> 00:07:57.220\nSo I can give it a string, a list or\nany other type of iterable and\n\n128\n00:07:57.220 --> 00:07:59.180\nit will try its best to\ndo these collections.\n\n129\n00:07:59.180 --> 00:08:01.990\nYou may run into some issues\nof If it's not supported or\n\n130\n00:08:01.990 --> 00:08:05.070\nthere's no way to what's\ncalled hash the values.\n\n131\n00:08:05.070 --> 00:08:09.720\nThere's no way to determine uniqueness so\nbe careful about that.\n\n132\n00:08:09.720 --> 00:08:13.634\nSo here's my heartrate, and there we go.\n\n133\n00:08:13.634 --> 00:08:20.020\nFor 93 beats per minute, it's happened 23\ntimes since I've been collecting these.\n\n134\n00:08:20.020 --> 00:08:24.607\nIf I wanna know the five most\ncommon heartrates that I've\n\n135\n00:08:24.607 --> 00:08:27.006\nencountered over this time.\n\n136\n00:08:27.006 --> 00:08:30.540\nWell 93's happened 23 times.\n\n137\n00:08:30.540 --> 00:08:32.270\n84 has happened 19 times.\n\n138\n00:08:32.270 --> 00:08:35.230\nAnd now I can start to\nsee that distribution.\n\n139\n00:08:35.230 --> 00:08:37.690\nAnd that's incredibly powerful.\n\n140\n00:08:37.690 --> 00:08:40.960\nAddition to,\nyou could use this to aggregate and\n\n141\n00:08:40.960 --> 00:08:44.080\nmanipulate and look at other measurements.\n\n142\n00:08:44.080 --> 00:08:49.392\nAnd we've seen that strings, and\niterables of strings, those work nice,\n\n143\n00:08:49.392 --> 00:08:54.040\nbut what happens if I have an unhashable\ntype such as a list as a key?\n\n144\n00:08:54.040 --> 00:09:00.861\nSo let's say I have something,\nand it is a list of list,\n\n145\n00:09:00.861 --> 00:09:06.524\nso I'm just gonna make\na list comprehension,\n\n146\n00:09:06.524 --> 00:09:12.623\na list(range(1, 10)) for _range(1,\n\n147\n00:09:12.623 --> 00:09:20.075\n10) I'm gonna get ten lists\nof the numbers 1 through 9.\n\n148\n00:09:20.075 --> 00:09:21.370\nBecause 10 is not included.\n\n149\n00:09:23.000 --> 00:09:26.475\nAnd you actually have to put\nthe appropriate syntax in here,\n\n150\n00:09:26.475 --> 00:09:28.938\nand if if I look at something, something.\n\n151\n00:09:28.938 --> 00:09:32.183\nThen I have a list of lists.\n\n152\n00:09:32.183 --> 00:09:37.040\nLet's see what happens when we feed\nthis to the counter and see what we get.\n\n153\n00:09:37.040 --> 00:09:42.090\nSo I'm just gonna call this numbers\nCounter and I wanna feed it something.\n\n154\n00:09:44.280 --> 00:09:45.470\nAnd un-hashable type.\n\n155\n00:09:45.470 --> 00:09:48.750\nAnd that's because behind the scenes\nin order for dictionaries to work\n\n156\n00:09:48.750 --> 00:09:52.890\nthey have to be hashable objects\nhas the keys, which mean I can\n\n157\n00:09:52.890 --> 00:09:57.760\nguarantee uniqueness based on pumping\nthis through a function behind the scene.\n\n158\n00:09:57.760 --> 00:10:02.770\nSo if ever see this It's because you're\ntype is not hashable, which means it can't\n\n159\n00:10:02.770 --> 00:10:06.810\nstored in a dictionary, can't be stored\nin a dictionary with key value pairs.\n\n160\n00:10:06.810 --> 00:10:10.054\nAnd what I mean as the key,\nthen the counter won't work.\n\n161\n00:10:10.054 --> 00:10:14.309\nSo let's review kind of what\nproblem the counter solves for us.\n\n162\n00:10:14.309 --> 00:10:18.014\nWell we saw with default dit in\nprevious episode that we can make easy\n\n163\n00:10:18.014 --> 00:10:20.104\ncounts of frequency distributions.\n\n164\n00:10:20.104 --> 00:10:24.960\nBut here a counter, well, it has feed it\nthe data and it does that sequencing and\n\n165\n00:10:24.960 --> 00:10:28.510\ncounting for\nyou cuz this is a very common pattern.\n\n166\n00:10:28.510 --> 00:10:32.350\nIn addition too,\nit's a great way to take measurements and\n\n167\n00:10:32.350 --> 00:10:37.520\nfind out distribution counts of them,\nso it's a very common pattern.\n\n168\n00:10:37.520 --> 00:10:40.010\nAnd it's so common it's part\nof the collections module.\n\n169\n00:10:40.010 --> 00:10:42.917\nIf you find yourself rolling your own, you\nshould definitely check out the counter.\n\n170\n00:10:42.917 --> 00:10:46.930\nBut please join us as we continue our\nlook into the Python standard library.\n\n171\n00:10:46.930 --> 00:10:50.170\nIn particular, we're gonna look at a few\nmore of the collections modules as well as\n\n172\n00:10:50.170 --> 00:10:51.270\nsome other ones.\n\n173\n00:10:51.270 --> 00:10:54.615\nBut for now, signing off for\nITProTV, I'm Justin Dennison.\n\n174\n00:10:54.615 --> 00:10:56.167\nSee you next time.\n\n175\n00:10:56.167 --> 00:11:01.201\n[MUSIC]\n\n",
          "vimeoId": "210978467"
        },
        {
          "description": "In this episode, Justin demonstrates the lru_cache decorator function from the functools module. If you need speed up a time intensive operation that gives the same output repeatedly, then take a look.",
          "length": "448",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-1-the_functools_module_la_cache-040417-PGM.00_07_24_02.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-1-the_functools_module_la_cache-040417-PGM.00_07_24_02.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-1-the_functools_module_la_cache-040417-PGM.00_07_24_02.Still001-sm.jpg",
          "title": "the functools Module: Iru_cache",
          "transcript": "WEBVTT\n\n1\n00:00:00.075 --> 00:00:06.913\n[SOUND] Greetings everyone and welcome\nto another exciting episode of ITProTV.\n\n2\n00:00:06.913 --> 00:00:08.081\nI'm Justin Dennison, and\n\n3\n00:00:08.081 --> 00:00:12.280\nin today's episode we're going to continue\nour look into the Python standard library.\n\n4\n00:00:12.280 --> 00:00:15.310\nMainly we're going to start looking\nat the functools module well and\n\n5\n00:00:15.310 --> 00:00:19.100\nit provides wonderful sets of\nfunctionality that make our life a little\n\n6\n00:00:19.100 --> 00:00:22.240\nbit easier, particularly when\nwe're dealing with functions.\n\n7\n00:00:22.240 --> 00:00:24.050\nSo, that kind of makes sense, right?\n\n8\n00:00:24.050 --> 00:00:26.860\nNow, let me set the stage for\nyou just for a moment.\n\n9\n00:00:26.860 --> 00:00:31.240\nHave you ever been in, you've been\nprogramming, you write a function and\n\n10\n00:00:31.240 --> 00:00:32.460\nit's exactly what you need.\n\n11\n00:00:32.460 --> 00:00:36.111\nHowever, it takes a really\nlong time to execute.\n\n12\n00:00:36.111 --> 00:00:40.055\nAnd you're like, but I only need it for\nthese five set of values, but\n\n13\n00:00:40.055 --> 00:00:42.140\nit's slowing down your program.\n\n14\n00:00:42.140 --> 00:00:46.285\nIf only there was some way to cache or\nmemoize that.\n\n15\n00:00:46.285 --> 00:00:47.640\nAnd, well, if you're like me,\n\n16\n00:00:47.640 --> 00:00:51.690\nI started searching on the internet and\nlooked up a bunch of custom solutions.\n\n17\n00:00:51.690 --> 00:00:52.620\nBut guess what?\n\n18\n00:00:52.620 --> 00:00:55.982\nIn the functools module,\nthere's something that can help us.\n\n19\n00:00:55.982 --> 00:00:59.240\nThe lru_cache decorator, and so\n\n20\n00:00:59.240 --> 00:01:03.080\nlet's go ahead and take a look here\non my screen and see how that's used.\n\n21\n00:01:03.080 --> 00:01:05.710\nLet's setup that scenario a little bit.\n\n22\n00:01:05.710 --> 00:01:08.820\nI'm gonna hop into repl here, and\n\n23\n00:01:08.820 --> 00:01:14.250\nI'm going to import time just to simulate,\nwell a very slow calculation.\n\n24\n00:01:14.250 --> 00:01:18.890\nNow, this is very contrived, but\nthis is about the lru_cache decorator,\n\n25\n00:01:18.890 --> 00:01:22.620\nnot necessarily about is\nthis a realistic example.\n\n26\n00:01:22.620 --> 00:01:27.880\nSo I'm gonna import time, and I'm going\nto create a function called, wait for it,\n\n27\n00:01:27.880 --> 00:01:33.410\nyep, awesome_, Calculation.\n\n28\n00:01:33.410 --> 00:01:36.170\nYeah, it is going to be fantastic.\n\n29\n00:01:36.170 --> 00:01:37.810\nAnd what is it going to do?\n\n30\n00:01:37.810 --> 00:01:45.990\nWell, when I pass in some number, x,\nit is going to sleep for three seconds.\n\n31\n00:01:45.990 --> 00:01:49.126\nNow, lets think about when would\nthis sleep actually occur?\n\n32\n00:01:49.126 --> 00:01:52.313\nTypically nowhere, but\nif you're making a call to a database or\n\n33\n00:01:52.313 --> 00:01:55.334\nyou actually have to do a bunch\nof number crunching, right.\n\n34\n00:01:55.334 --> 00:01:58.798\nYou're actually doing some data\nanalytics those operations may take\n\n35\n00:01:58.798 --> 00:02:00.230\na great deal of time.\n\n36\n00:02:00.230 --> 00:02:04.830\nAnd well, you just wanna do them once and\nthen be able to recall them quickly, and\n\n37\n00:02:04.830 --> 00:02:07.920\nthen return whatever the result is.\n\n38\n00:02:07.920 --> 00:02:12.774\nSo, and let's make this a little\nmore complicated than that, so\n\n39\n00:02:12.774 --> 00:02:14.374\n3 * x + 4, right?\n\n40\n00:02:14.374 --> 00:02:17.610\nSo 3 * x + 4, and there's our function.\n\n41\n00:02:17.610 --> 00:02:20.620\nNow let's actually call this function,\nand see what happens.\n\n42\n00:02:20.620 --> 00:02:23.759\nSo if I say awesome_calculation, and\n\n43\n00:02:23.759 --> 00:02:28.645\nI pass in the number 3,\nthat would be 3 times 3, awesome.\n\n44\n00:02:28.645 --> 00:02:33.080\nYou got to spell awesome_calculation\nexactly the same way\n\n45\n00:02:33.080 --> 00:02:34.500\nas you did the other time.\n\n46\n00:02:34.500 --> 00:02:36.793\nAnd I forgot an L here,\nso that's important.\n\n47\n00:02:36.793 --> 00:02:42.075\nI'm not infallible here, that's all right,\n\n48\n00:02:42.075 --> 00:02:47.761\nso time.sleep(3), and return, 3 * x + 4.\n\n49\n00:02:47.761 --> 00:02:52.710\nNow let's actually try to call that, and\nit will take an additional three seconds,\n\n50\n00:02:52.710 --> 00:02:55.460\nfrom whatever the computation time is.\n\n51\n00:02:55.460 --> 00:02:57.412\nAnd here we have, the number 13.\n\n52\n00:02:57.412 --> 00:02:59.050\nWell, let's run it again.\n\n53\n00:02:59.050 --> 00:03:01.840\nIf we make that call again,\nthis is a database call or\n\n54\n00:03:01.840 --> 00:03:05.130\nsome kind of calculation,\nit again takes three seconds.\n\n55\n00:03:05.130 --> 00:03:07.430\nWell, this is not what I want, right?\n\n56\n00:03:07.430 --> 00:03:11.630\nI want this to return quickly,\nthis is important to my application.\n\n57\n00:03:11.630 --> 00:03:13.440\nHow can I make this faster?\n\n58\n00:03:13.440 --> 00:03:17.850\nWell, I know that the number 13 is\na very small piece of information, and\n\n59\n00:03:17.850 --> 00:03:20.680\nit would probably be nice if I\ncould just store it somewhere and\n\n60\n00:03:20.680 --> 00:03:22.790\njust make a recall from a dictionary.\n\n61\n00:03:22.790 --> 00:03:25.780\nAnd if you look up custom\nsolutions that's what will happen.\n\n62\n00:03:25.780 --> 00:03:31.670\nBut lru_cache is the least\nrecently used cache.\n\n63\n00:03:31.670 --> 00:03:33.220\nKind of an odd name, but\n\n64\n00:03:33.220 --> 00:03:36.740\nyou can think of it's the last\nthings that you've used, right.\n\n65\n00:03:36.740 --> 00:03:38.490\nSo let's redefine this function.\n\n66\n00:03:38.490 --> 00:03:42.940\nSo I'm gonna get out of this repo, and\nclear the screen and start a new repl.\n\n67\n00:03:42.940 --> 00:03:48.430\nWe're gonna do the exact same thing\nexcept we're gonna import time,\n\n68\n00:03:48.430 --> 00:03:54.880\nbut from functools,\nI'm going to import lru.cache.\n\n69\n00:03:54.880 --> 00:03:59.255\nNow, this is a decorator, this is maybe\nyour first time seeing a decorator.\n\n70\n00:03:59.255 --> 00:04:02.920\nWe'll definitely check out some\nother videos on the library to\n\n71\n00:04:02.920 --> 00:04:05.460\nsee what are our decorators,\nhow are they used?\n\n72\n00:04:05.460 --> 00:04:07.900\nBut what that means is this\nwill take a function and\n\n73\n00:04:07.900 --> 00:04:09.920\nreturn a new version of that function.\n\n74\n00:04:09.920 --> 00:04:16.570\nSo lru_cache and lru_cache can take\na couple of arguments, maxsize, and\n\n75\n00:04:16.570 --> 00:04:23.222\nthat means how many values need to\nbe cached, well by default it's 128.\n\n76\n00:04:23.222 --> 00:04:27.990\nAnd then, do you want it to worry\nabout the types of arguments?\n\n77\n00:04:27.990 --> 00:04:31.565\nSo in the case of our\nawesome calculation 1 and\n\n78\n00:04:31.565 --> 00:04:34.450\n1.0, well one is an int and\none is a float.\n\n79\n00:04:34.450 --> 00:04:39.710\nThose would be different if typed was\nTrue, but by default, it is False.\n\n80\n00:04:39.710 --> 00:04:44.018\nSo 1 and\n1.0 would be treated exactly the same.\n\n81\n00:04:44.018 --> 00:04:48.520\nNow, you can get into some hairy\ndetails there, definitely be careful.\n\n82\n00:04:48.520 --> 00:04:49.800\nSo, what do I want to do?\n\n83\n00:04:49.800 --> 00:04:57.280\nI want to say awesome_calculation,\nexact same function, and time.sleep.\n\n84\n00:04:57.280 --> 00:05:04.160\nAnd we're going to sleep 3 seconds,\nand return 3 * x + 4.\n\n85\n00:05:04.160 --> 00:05:11.100\nOkay, everything looks the same let me\nrun awesome_calculation and pass in 3.\n\n86\n00:05:11.100 --> 00:05:14.916\nWe should get 13, and you'll notice\nthe first time I call this well,\n\n87\n00:05:14.916 --> 00:05:20.540\nit still took 3 additional seconds from\nwhat ever the calculation time was.\n\n88\n00:05:20.540 --> 00:05:21.420\nBut if I hit up and\n\n89\n00:05:21.420 --> 00:05:27.510\nhit it again it's an instantaneous return,\nI've actually cached that calculation.\n\n90\n00:05:27.510 --> 00:05:31.568\nSo it takes account of the function\nname and the set of arguments for\n\n91\n00:05:31.568 --> 00:05:35.423\nthe function and then it does\na look up and it stores that value.\n\n92\n00:05:35.423 --> 00:05:38.730\nNow how do you know\nwhat values are stored?\n\n93\n00:05:38.730 --> 00:05:44.090\nWell, whenever you add\nthis lru_cache decorator,\n\n94\n00:05:44.090 --> 00:05:51.290\nyou can now call the function\ncalculation.cache_info(),\n\n95\n00:05:51.290 --> 00:05:54.630\nand it will tell you how many hits,\n\n96\n00:05:54.630 --> 00:05:58.280\nhow many misses, what's the current size,\nand what is the max size.\n\n97\n00:05:58.280 --> 00:06:03.050\nSo it is storing one value\nout of a possible 128.\n\n98\n00:06:03.050 --> 00:06:05.630\nNow what happens if you\ngo over that max size\n\n99\n00:06:05.630 --> 00:06:10.610\nwell it starts moving the oldest\nout to put the newest in okay.\n\n100\n00:06:10.610 --> 00:06:14.990\nSo whatever you haven't used in\nthe long time gets shifted out,\n\n101\n00:06:14.990 --> 00:06:19.180\nor when I say a long time it's kind of,\nit's little more complicated in that but\n\n102\n00:06:19.180 --> 00:06:20.850\nthat's a good mental model.\n\n103\n00:06:20.850 --> 00:06:26.370\nAnd then what if we want to well, I know\nI've updated some things in my database or\n\n104\n00:06:26.370 --> 00:06:31.830\nthis calculation, I had to change it, so I\nneed to clear that but rerun this, right?\n\n105\n00:06:31.830 --> 00:06:34.888\nI'm in a repl, now this wouldn't happen\nif you were running a Python script from\n\n106\n00:06:34.888 --> 00:06:37.940\nthe command line, or\nyou're restarting a web application.\n\n107\n00:06:37.940 --> 00:06:40.610\nBut what if I'm in the repl,\nand I've made a change and\n\n108\n00:06:40.610 --> 00:06:43.260\nthen I wanna make sure I clear this out,\neverything is good.\n\n109\n00:06:44.640 --> 00:06:51.136\nAnd I can say awesome_calculation, calcu,\nI have a real hard time spelling that.\n\n110\n00:06:51.136 --> 00:06:56.611\ncache_clear(), and now if I look at\nCacheInfo well we see we have 0 hits,\n\n111\n00:06:56.611 --> 00:07:02.001\n0 misses, the maxsize is still 128,\nbut the currentsize is back to 0,\n\n112\n00:07:02.001 --> 00:07:06.150\nand that's because we've\ncleared the cache.\n\n113\n00:07:06.150 --> 00:07:10.130\nAnd if we were to make that calculation\nagain, call awesome_calculation again, for\n\n114\n00:07:10.130 --> 00:07:12.990\nwhatever number,\nwe would start caching new values.\n\n115\n00:07:12.990 --> 00:07:16.240\nNow, we've seen the power of lru_cache,\n\n116\n00:07:16.240 --> 00:07:19.010\nbut there is still more to\ncome in the functools module.\n\n117\n00:07:19.010 --> 00:07:23.100\nSo please stay tuned as we continue our\ndeep dive into the standard library.\n\n118\n00:07:23.100 --> 00:07:23.705\nSee you next time.\n\n119\n00:07:23.705 --> 00:07:28.054\n[SOUND]\n\n",
          "vimeoId": "212911391"
        },
        {
          "description": "In this episode, Justin demonstrates the total_ordering decorator function from the functools module. Tired of spending time implementing all of the comparison special methods of a class just to prototype and idea? Join Justin as he wields the power of the Python Standard Library to overcome those slowdowns.",
          "length": "707",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-2-the_functools_module_total_ordering-040417-PGM.00_11_43_06.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-2-the_functools_module_total_ordering-040417-PGM.00_11_43_06.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-2-the_functools_module_total_ordering-040417-PGM.00_11_43_06.Still001-sm.jpg",
          "title": "The functools Module: total_ordering",
          "transcript": "",
          "vimeoId": "214173830"
        },
        {
          "description": "In this episode, Justin demonstrates the partial function from the the functools module. Tired of typing the same function arguments over and over only to change a one or two of the values? Join Justin as he overcomes those nuisances with the Python Standard Library?",
          "length": "674",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-3-the_functools_module_partial-040417-PGM.00_11_25_13.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-3-the_functools_module_partial-040417-PGM.00_11_25_13.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-4-3-the_functools_module_partial-040417-PGM.00_11_25_13.Still001-sm.jpg",
          "title": "The functools Module: partial",
          "transcript": "",
          "vimeoId": "214173980"
        },
        {
          "description": "In this episode, Justin demonstrates the reduce function from the the functools module. Whether you are interested in functional programming or need a way to write custom functions that combine the elements of a collection, reduce is an effective function to know.",
          "length": "704",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-4-4-the_functools_module_reduce-042117-high.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-4-4-the_functools_module_reduce-042117-high-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-4-4-the_functools_module_reduce-042117-high-sm.jpg",
          "title": "The functools Module: reduce",
          "transcript": "",
          "vimeoId": "243858417"
        },
        {
          "description": "In this episode, Justin demonstrates the usage of the json module for converting between Python data structures and valid JSON strings.",
          "length": "663",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-1-the_json_module_read_and_write-042017-PGM.00_10_57_18.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-1-the_json_module_read_and_write-042017-PGM.00_10_57_18.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-1-the_json_module_read_and_write-042017-PGM.00_10_57_18.Still001-sm.jpg",
          "title": "The json Module: Reading & Writing",
          "transcript": "",
          "vimeoId": "243857818"
        },
        {
          "description": "In this episode, Justin demonstrates using custom serialization and deserialization functions with the json module to handle objects that are not by default handled by the json module.",
          "length": "679",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-2-the_json_module_function_encoder_and_decode-PGM.00_11_14_01.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-2-the_json_module_function_encoder_and_decode-PGM.00_11_14_01.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-2-the_json_module_function_encoder_and_decode-PGM.00_11_14_01.Still001-sm.jpg",
          "title": "The json Module: Function Encode & Decode",
          "transcript": "",
          "vimeoId": "243857334"
        },
        {
          "description": "In this episode, Justin demonstrates using class based encoding and decoding of JSON with the json module.",
          "length": "663",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-3-the_json_module_class_encode_and_decode-042117-PGM.00_10_58_17.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-3-the_json_module_class_encode_and_decode-042117-PGM.00_10_58_17.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-5-3-the_json_module_class_encode_and_decode-042117-PGM.00_10_58_17.Still001-sm.jpg",
          "title": "The json Module: Class Encode & Decode",
          "transcript": "",
          "vimeoId": "243858316"
        },
        {
          "description": "In this episode, Justin demonstrates the power of the csv module in the standard library for reading and parsing data that is transmitted using csv file format.",
          "length": "852",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-6-1-the_csv_module_csv_reading_and_writing-042117-PGM.00_14_06_27.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-6-1-the_csv_module_csv_reading_and_writing-042117-PGM.00_14_06_27.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-6-1-the_csv_module_csv_reading_and_writing-042117-PGM.00_14_06_27.Still001-sm.jpg",
          "title": "The csv Module: CSV Reading & Writing",
          "transcript": "",
          "vimeoId": "243858172"
        },
        {
          "description": "In this episode, Justin demonstrates the DictReader and DictWriter objects in the csv module to produce a different representation of the data found in a comma separated file.",
          "length": "873",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-6-2-the_csv_module_csv_dictreader_and_dictwriter-042117-PGM.00_14_28_12.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-6-2-the_csv_module_csv_dictreader_and_dictwriter-042117-PGM.00_14_28_12.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-deveintothestandardlibrary-6-2-the_csv_module_csv_dictreader_and_dictwriter-042117-PGM.00_14_28_12.Still001-sm.jpg",
          "title": "The csv Module: DictReader and DictWriter",
          "transcript": "",
          "vimeoId": "243858057"
        },
        {
          "description": "In this episode, Justin demonstrates some of the common actions that you use to create valid system level paths using the Python standard library.",
          "length": "714",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-7-1-the_os_path_module-081117-PGM.00_00_43_17.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-7-1-the_os_path_module-081117-PGM.00_00_43_17.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-7-1-the_os_path_module-081117-PGM.00_00_43_17.Still001-sm.jpg",
          "title": "The os.path Module",
          "transcript": "",
          "vimeoId": "243858516"
        },
        {
          "description": "In this episode, Justin explores building a tcp server using the standard libraries socket module primitives.",
          "length": "572",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-1-the_socket_module_tcp_server-081117.00_00_05_15.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-1-the_socket_module_tcp_server-081117.00_00_05_15.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-1-the_socket_module_tcp_server-081117.00_00_05_15.Still001-sm.jpg",
          "title": "The socket Module: TCP Server",
          "transcript": "",
          "vimeoId": "243858636"
        },
        {
          "description": "In this episode, Justin uses the Python Standard library to create a TCP client akin to netcat.",
          "length": "588",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-2-the_socket_module_tcp_client-081117.00_00_05_22.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-2-the_socket_module_tcp_client-081117.00_00_05_22.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-2-the_socket_module_tcp_client-081117.00_00_05_22.Still001-sm.jpg",
          "title": "The socket Module: TCP Client",
          "transcript": "",
          "vimeoId": "243858724"
        },
        {
          "description": "In this episode, Justin creates a UDP server using the socket module primitives from the Python standard library.",
          "length": "354",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-3-the_socket_module_udp_server-081117.00_00_05_15.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-3-the_socket_module_udp_server-081117.00_00_05_15.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-3-the_socket_module_udp_server-081117.00_00_05_15.Still001-sm.jpg",
          "title": "The socket Module: UDP Server",
          "transcript": "",
          "vimeoId": "243858826"
        },
        {
          "description": "In this episode, Justin demonstrates the utilization of the socket module primitives to create a UDP client similar to the UDP version of netcat.",
          "length": "426",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-4-the_socket_module_udp_client-081117.00_00_05_16.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-4-the_socket_module_udp_client-081117.00_00_05_16.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-8-4-the_socket_module_udp_client-081117.00_00_05_16.Still001-sm.jpg",
          "title": "The socket Module: UDP Client",
          "transcript": "",
          "vimeoId": "243856979"
        },
        {
          "description": "In this episode, Justin demonstrates the use of a datetime object's strftime method to create a formatted string representation of a datetime.",
          "length": "566",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-9-1-1-datetime_strftime-112117-PGM.00_09_23_16.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-9-1-1-datetime_strftime-112117-PGM.00_09_23_16.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-9-1-1-datetime_strftime-112117-PGM.00_09_23_16.Still001-sm.jpg",
          "title": "datetime strftime",
          "transcript": "",
          "vimeoId": "244098903"
        },
        {
          "description": "In this episode, Justin demonstrates the using the strptime function to parse datetimes from strings.",
          "length": "494",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-9-2-1-datetime_strptime-112117_PGM.00_08_10_29.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-9-2-1-datetime_strptime-112117_PGM.00_08_10_29.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-9-2-1-datetime_strptime-112117_PGM.00_08_10_29.Still001-sm.jpg",
          "title": "datetime strptime",
          "transcript": "",
          "vimeoId": "244098823"
        },
        {
          "description": "In this episode, Justin demonstrates the use of the submit function using a ThreadPoolExecutor. Additionally, he highlights how the submit method compares to the map method on the executor.",
          "length": "1005",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-10-3-1-concurrent_futures_threadpool_executor_submit-112917-high.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-10-3-1-concurrent_futures_threadpool_executor_submit-112917-high-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-10-3-1-concurrent_futures_threadpool_executor_submit-112917-high-sm.jpg",
          "title": "concurrent.futures ThreadPoolExecutor submit",
          "transcript": "",
          "vimeoId": "245255173"
        },
        {
          "description": "In this episode, Justin dives into using the ProcessPoolExecutor submit method to add the ability to perform concurrent work.",
          "length": "1029",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-10-4-1-concurrent_futures_processpool_executor_submit-112917-high.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-10-4-1-concurrent_futures_processpool_executor_submit-112917-high-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/techskills-diveintothestandardlibrary/techskills-diveintothestandardlibrary-10-4-1-concurrent_futures_processpool_executor_submit-112917-high-sm.jpg",
          "title": "concurrent.futures ProcessPoolExecutor submit",
          "transcript": "",
          "vimeoId": "245255557"
        }
      ],
      "title": "Dive into the Python Standard Library"
    }
  ],
  "url": "python",
  "vLab": false
}
