{
  "description": "This course introduces viewers to Microsoft Transact-SQL, the language used to input and retrieve data from Microsoft SQL servers. The series is designed for viewers of all experience levels as it walks through running your very first query all the way through crafting advanced server-side stored procedures.",
  "descriptionMD": "This course introduces viewers to Microsoft Transact-SQL, the language used to input and retrieve data from Microsoft SQL servers. The series is designed for viewers of all experience levels as it walks through running your very first query all the way through crafting advanced server-side stored procedures.",
  "length": "67089",
  "name": "Microsoft SQL Server 2016: Querying Data with Transact-SQL - 70-761",
  "practiceExam": true,
  "subtitle": "Microsoft SQL Server 2016",
  "tagUrl": "microsoft-technical",
  "topics": [
    {
      "episodes": [
        {
          "description": "This course introduces viewers to Microsoft Transact-SQL, the language used to input and retrieve data from Microsoft SQL servers. The series is designed for viewers of all experience levels as it walks through running your very first query all the way through crafting advanced server-side stored procedures.",
          "length": "496",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-0-0-0-overivew-111317-PGM.00_00_05_15.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-0-0-0-overivew-111317-PGM.00_00_05_15.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-0-0-0-overivew-111317-PGM.00_00_05_15.Still001-sm.jpg",
          "title": "Overview",
          "transcript": "WEBVTT\n\n1\n00:00:00.000 --> 00:00:03.386\n[MUSIC]\n\n2\n00:00:03.386 --> 00:00:07.822\n[SOUND] Hello, thank you for\nchoosing ITProTV.\n\n3\n00:00:07.822 --> 00:00:13.240\nWe're talking about Querying Data\nwith Transact-SQL, with Don Pezet.\n\n4\n00:00:13.240 --> 00:00:15.580\nDon, tell us about Transact-SQL.\n\n5\n00:00:15.580 --> 00:00:16.830\nSo Transact-SQL,\n\n6\n00:00:16.830 --> 00:00:20.810\nit's actually an abbreviation for\nTransact Structured Query Language.\n\n7\n00:00:20.810 --> 00:00:23.400\nIt is a language that we\nuse to talk to databases.\n\n8\n00:00:23.400 --> 00:00:25.940\nSo if you have a relational database,\n\n9\n00:00:25.940 --> 00:00:27.480\nthere's a ton of great\ninformation in there.\n\n10\n00:00:27.480 --> 00:00:29.190\nYou have to be able to get it out.\n\n11\n00:00:29.190 --> 00:00:32.330\nAnd one of the most common ways\nto do that is through SQL, or\n\n12\n00:00:32.330 --> 00:00:33.890\nthe Structured Query Language.\n\n13\n00:00:33.890 --> 00:00:38.740\nWell, Transact-SQL is Microsoft's\nimplementation of SQL.\n\n14\n00:00:38.740 --> 00:00:40.750\nAnd it's what they use on\ntheir server products.\n\n15\n00:00:40.750 --> 00:00:45.662\nSo if you're using Microsoft SQL Server,\nwell, really, all the way back, or a long\n\n16\n00:00:45.662 --> 00:00:48.190\ntime, since their earliest versions of SQL\nServer, but all the way to the newer ones\n\n17\n00:00:48.190 --> 00:00:50.935\nlike 2016, which is what we're\ngonna be using here in this show.\n\n18\n00:00:50.935 --> 00:00:55.580\nTransact-SQL is how you're going to\ntalk to that server, so in this series,\n\n19\n00:00:55.580 --> 00:00:57.360\nthat's one of the things that\nwe're going to learn is,\n\n20\n00:00:57.360 --> 00:01:01.110\nif I've got a Microsoft SQL Server 2016,\nHow do I talk to it?\n\n21\n00:01:01.110 --> 00:01:04.760\nNow the cool part is that most\nof this is standards based, so\n\n22\n00:01:04.760 --> 00:01:10.630\nwhat you learn in this series can apply\nto SQL 2014, SQL 2012, SQL 2000, SQL 6.\n\n23\n00:01:10.630 --> 00:01:12.470\nI mean, it just goes way, way back.\n\n24\n00:01:12.470 --> 00:01:16.290\nThese languages, they haven't changed\nall that much in all these years.\n\n25\n00:01:16.290 --> 00:01:19.337\nNow, the way the databases optimized\ntheir performance, the way they work.\n\n26\n00:01:19.337 --> 00:01:22.415\nThe volumes of data that they can handle,\nhave gotten much larger and\n\n27\n00:01:22.415 --> 00:01:23.840\nevolved quite a bit.\n\n28\n00:01:23.840 --> 00:01:26.040\nBut by having a standard language,\n\n29\n00:01:26.040 --> 00:01:28.020\nit gives us the ability\nto do something awesome.\n\n30\n00:01:28.020 --> 00:01:32.130\nWhich is to learn how to talk to the\ndatabase service in a consistent manner.\n\n31\n00:01:32.130 --> 00:01:34.210\nAnd that's what this course is all about.\n\n32\n00:01:34.210 --> 00:01:36.037\n&gt;&gt; You already got me excited\nabout the whole thing, but\n\n33\n00:01:36.037 --> 00:01:37.850\nwho is this show targeted towards?\n\n34\n00:01:37.850 --> 00:01:39.010\n&gt;&gt; All right, well,\n\n35\n00:01:39.010 --> 00:01:44.110\nit's really targeted to anybody who\nneeds to get data out of the database.\n\n36\n00:01:44.110 --> 00:01:46.218\nNow, I could kinda trim\nthat down a little bit,\n\n37\n00:01:46.218 --> 00:01:48.410\nlike if you don't really\ncare about database.\n\n38\n00:01:48.410 --> 00:01:52.213\nYou just want the data, there's plenty of\nthird party graphic utilities you can use.\n\n39\n00:01:52.213 --> 00:01:55.395\nThere's things like Microsoft Access\nthat gives you a little Wizard that\n\n40\n00:01:55.395 --> 00:01:58.250\nyou can walk through, but\nif you're trying to go to scale.\n\n41\n00:01:58.250 --> 00:02:01.390\nIf you're trying to be able to handle\nany kind of high volume transactions.\n\n42\n00:02:01.390 --> 00:02:05.510\nThose hand holding type programs,\nthey don't work.\n\n43\n00:02:05.510 --> 00:02:08.990\nWe actually have to get in and\ntalk to the database server.\n\n44\n00:02:08.990 --> 00:02:12.410\nBe able to get that information and\nput information in, and\n\n45\n00:02:12.410 --> 00:02:13.960\nthat's where SQL comes in.\n\n46\n00:02:13.960 --> 00:02:17.550\nSo if your job responsibility involves\nthat, this is what you want to learn.\n\n47\n00:02:17.550 --> 00:02:20.170\nNow what types of jobs would do that,\ndevelopers.\n\n48\n00:02:20.170 --> 00:02:23.740\nDevelopers often times have to store data\nfor their applications in a database.\n\n49\n00:02:23.740 --> 00:02:25.230\nAnd be able to get the data back out for\n\n50\n00:02:25.230 --> 00:02:28.570\ntheir application uses,\nso they need to know SQL.\n\n51\n00:02:28.570 --> 00:02:33.410\nWe also have DevOps, people that\nare standing up their own database server,\n\n52\n00:02:33.410 --> 00:02:34.070\nright?\n\n53\n00:02:34.070 --> 00:02:36.000\nThey still need to be able to talk to it.\n\n54\n00:02:36.000 --> 00:02:37.710\nWe also have system administrators.\n\n55\n00:02:37.710 --> 00:02:39.857\nIf you're a system administrator and\nyou're responsible for\n\n56\n00:02:39.857 --> 00:02:40.755\nstanding up a SQL Server.\n\n57\n00:02:40.755 --> 00:02:43.103\nWell, some people just have\nto install the server and\n\n58\n00:02:43.103 --> 00:02:45.910\nthen they turn it over to the dev team and\nthat's it.\n\n59\n00:02:45.910 --> 00:02:48.730\nBut more often than not,\nwe're gonna need to be able to monitor and\n\n60\n00:02:48.730 --> 00:02:49.870\nmaintain that database.\n\n61\n00:02:49.870 --> 00:02:52.720\nAnd the way we do that is\nby querying against it.\n\n62\n00:02:52.720 --> 00:02:54.470\nSending it commands,\nseeing how it responds,\n\n63\n00:02:54.470 --> 00:02:56.220\nthat's how we know it's up and active.\n\n64\n00:02:56.220 --> 00:02:58.270\nJust because the server's powered\non doesn't mean it's working.\n\n65\n00:02:58.270 --> 00:03:01.900\nWe need to know,\ncan I actually get data out of it?\n\n66\n00:03:01.900 --> 00:03:06.080\nSo if you fall into any of those roles,\ndeveloper, DevOps, system administrator.\n\n67\n00:03:06.080 --> 00:03:09.930\nOr just somebody who wants to learn\nmore about the way the databases work.\n\n68\n00:03:09.930 --> 00:03:13.612\nLearning SQL is a great way to find\nout how to talk to talk to it.\n\n69\n00:03:13.612 --> 00:03:15.103\nAnd learning Transact-SQL,\n\n70\n00:03:15.103 --> 00:03:18.185\nis a great way to learn how to\ntalk to Microsoft's SQL Servers.\n\n71\n00:03:18.185 --> 00:03:21.070\n&gt;&gt; Wow, that sounds fantastic, is there\na certification available for the show?\n\n72\n00:03:21.070 --> 00:03:25.260\n&gt;&gt; Absolutely this is actually\nthe first step in becoming like\n\n73\n00:03:25.260 --> 00:03:27.100\na Microsoft Certified SQL Engineer.\n\n74\n00:03:27.100 --> 00:03:30.360\nSo the first certification that we\nstart with is called the MCSA, and\n\n75\n00:03:30.360 --> 00:03:32.470\nI've got Microsoft's page pulled up here.\n\n76\n00:03:32.470 --> 00:03:35.930\nThe MCSA for SQL Server 2016,\nif you look at it.\n\n77\n00:03:35.930 --> 00:03:39.630\nThe very first course in that journey\nis right here, course number one.\n\n78\n00:03:39.630 --> 00:03:44.860\nIt's exam 70-761, and\nthat's what our show is being based on.\n\n79\n00:03:44.860 --> 00:03:48.120\nSo, in this show we're going to cover\neach of the topics that are a part of\n\n80\n00:03:48.120 --> 00:03:49.150\nthat exam.\n\n81\n00:03:49.150 --> 00:03:52.080\nSo that we can learn what we\nneed to know to go and pass it.\n\n82\n00:03:52.080 --> 00:03:54.986\nNow, by itself, that's not enough, but\n\n83\n00:03:54.986 --> 00:03:59.763\nif you complete the next course or\nnext exam, the 70-762 exam.\n\n84\n00:03:59.763 --> 00:04:05.620\nWhen you pas both of those,\nyou get your MCSA in SQL Server 2016.\n\n85\n00:04:05.620 --> 00:04:08.860\nAnd from there you can even move on and\nthere's an MCSE that you can get.\n\n86\n00:04:08.860 --> 00:04:10.810\nAnd there's several specializations for\n\n87\n00:04:10.810 --> 00:04:13.290\nbig data and cloud databases,\nand all of that.\n\n88\n00:04:13.290 --> 00:04:17.764\nBut they all start right here\nwith this one, with this show,\n\n89\n00:04:17.764 --> 00:04:21.560\n70-761, which is for SQL Server 2016.\n\n90\n00:04:21.560 --> 00:04:24.510\nBe aware that there are other ones for\nthe previous versions,\n\n91\n00:04:24.510 --> 00:04:26.445\nlike SQL Server 2012 and 2014.\n\n92\n00:04:26.445 --> 00:04:31.021\nThey shared a different exam, 70-741,\nif that's the one you're looking for.\n\n93\n00:04:31.021 --> 00:04:32.675\nWell, we have a whole\nseparate show film for\n\n94\n00:04:32.675 --> 00:04:34.650\nthat because there's\na different user interface.\n\n95\n00:04:34.650 --> 00:04:38.130\nThings look different, so\nwe filmed it specifically for that.\n\n96\n00:04:38.130 --> 00:04:39.830\nHere though, things look different enough,\n\n97\n00:04:39.830 --> 00:04:42.590\nthat we actually got the dedicated\ncourse specifically for it.\n\n98\n00:04:42.590 --> 00:04:44.471\nAnd that's exactly what\nwe're gonna be learning.\n\n99\n00:04:44.471 --> 00:04:48.130\n&gt;&gt; A good IT pro is always learning, and\nwhat topics are covered in this show?\n\n100\n00:04:48.130 --> 00:04:51.450\nAlright, well, it really all starts kinda,\nfrom a beginner's perspective.\n\n101\n00:04:51.450 --> 00:04:55.840\nSo what is Transact-SQL, what does it\nlook like, how do I type in the commands?\n\n102\n00:04:55.840 --> 00:04:58.280\nAnd then,\nonce I know how to input commands,\n\n103\n00:04:58.280 --> 00:05:01.190\nwhat are the commands to even use?\n\n104\n00:05:01.190 --> 00:05:04.043\nAnd if we drill into that exam,\nlet me pull it up here.\n\n105\n00:05:04.043 --> 00:05:06.104\nSo I'm going to pull up\nthat 70-761 exam and\n\n106\n00:05:06.104 --> 00:05:08.590\nI'll pull up the details\nhere from Microsoft.\n\n107\n00:05:08.590 --> 00:05:10.740\nThey basically divide\nthings into three areas,\n\n108\n00:05:10.740 --> 00:05:13.640\nnow in the show we divided\nit up into a lot more areas.\n\n109\n00:05:13.640 --> 00:05:16.460\nBecause this is, it's a lot to take\nin just in three chunks, right?\n\n110\n00:05:16.460 --> 00:05:19.900\nSo I think we actually divide it into,\nI can't remember, like 10 or\n\n111\n00:05:19.900 --> 00:05:21.080\n11 different areas.\n\n112\n00:05:21.080 --> 00:05:22.030\nBut when you look inside,\n\n113\n00:05:22.030 --> 00:05:24.340\nfirst off we start with Managing\ndata with Transact-SQL.\n\n114\n00:05:24.340 --> 00:05:26.850\nNotice that that's almost half the exam.\n\n115\n00:05:26.850 --> 00:05:30.210\nA large part of the exam is based,\njust on managing that data.\n\n116\n00:05:30.210 --> 00:05:32.320\nActually interacting\nwith the database server,\n\n117\n00:05:32.320 --> 00:05:34.790\nwhat Transact SQL is all about, right?\n\n118\n00:05:34.790 --> 00:05:38.120\nAnd if you break that apart you'll see\nit's things like using SELECT queries.\n\n119\n00:05:38.120 --> 00:05:40.414\nWhich are the most\ncommon types of queries,\n\n120\n00:05:40.414 --> 00:05:43.339\nthat's how we request\ninformation from the database.\n\n121\n00:05:43.339 --> 00:05:46.108\nHow we combine data between\ntables using joins,\n\n122\n00:05:46.108 --> 00:05:48.610\nhow we aggregate data using functions.\n\n123\n00:05:48.610 --> 00:05:51.460\nThat's all interacting with the database.\n\n124\n00:05:51.460 --> 00:05:55.900\nThen we get into doing advanced queries,\nthese are queries that not everybody uses.\n\n125\n00:05:55.900 --> 00:05:59.080\nThe ones up here in the first section,\neverybody uses these.\n\n126\n00:05:59.080 --> 00:06:01.710\nYou use these everyday,\njust going to a website,\n\n127\n00:06:01.710 --> 00:06:03.885\ncoming to our website and\nclicking on the course library.\n\n128\n00:06:03.885 --> 00:06:05.370\nYou're running these queries\nin the background and\n\n129\n00:06:05.370 --> 00:06:06.210\nyou don't even know it, right?\n\n130\n00:06:06.210 --> 00:06:10.060\nThese happen everyday, the advance\nqueries aren't in every day things.\n\n131\n00:06:10.060 --> 00:06:11.820\nThese are more like an edge case or\n\n132\n00:06:11.820 --> 00:06:15.660\na corner case, where you can actually\nget some great benefits by using these.\n\n133\n00:06:15.660 --> 00:06:18.510\nDoing things like grouping sets,\nand pivots, and unpivots.\n\n134\n00:06:18.510 --> 00:06:22.168\nSo you can change the data that you're\ngetting back from the database servers.\n\n135\n00:06:22.168 --> 00:06:24.820\nSo we'll get a chance to see that, that\nmakes up a smaller portion of the exam.\n\n136\n00:06:24.820 --> 00:06:28.070\nAnd then the smallest portion\nis right down here at the end,\n\n137\n00:06:28.070 --> 00:06:31.350\nprogramming databases\nby using Transact SQL.\n\n138\n00:06:31.350 --> 00:06:34.590\nIf you're given access to a SQL Server,\nit has nothing on it.\n\n139\n00:06:34.590 --> 00:06:38.900\nIt doesn't have a database, has no tables,\nhow do you get that set up?\n\n140\n00:06:38.900 --> 00:06:41.410\nSo we focus on the infrastructure side,\nhow do I create the database?\n\n141\n00:06:41.410 --> 00:06:44.280\nHow do I create the tables,\nhow do I deal with data types.\n\n142\n00:06:44.280 --> 00:06:47.150\nAnd actually work with that information,\ninside of those tables?\n\n143\n00:06:47.150 --> 00:06:51.350\nUntil we run through that process of being\nable to maintain the integrity of our data\n\n144\n00:06:51.350 --> 00:06:52.340\non the server.\n\n145\n00:06:52.340 --> 00:06:55.190\nIt's a great way to see some of\nthe neat tools that are a part\n\n146\n00:06:55.190 --> 00:06:56.220\nof Microsoft SQL Server.\n\n147\n00:06:56.220 --> 00:06:58.875\nThat set it apart from other\ncompetitors that are out there.\n\n148\n00:06:58.875 --> 00:07:00.749\nSo that's kind of a rundown of it,\n\n149\n00:07:00.749 --> 00:07:04.703\nnow do be aware that this last section\nhere where programing databases.\n\n150\n00:07:04.703 --> 00:07:07.830\nIt's not as super-crazy in depth,\nthat if you're not a developer,\n\n151\n00:07:07.830 --> 00:07:08.890\ndon't worry, right?\n\n152\n00:07:08.890 --> 00:07:11.230\nIt's something that everybody can tackle.\n\n153\n00:07:11.230 --> 00:07:15.073\nThere's actually another course,\nif we look down the little list here.\n\n154\n00:07:15.073 --> 00:07:18.130\nYou'll see this,\nProvisioning SQL Databases.\n\n155\n00:07:18.130 --> 00:07:22.730\nAnd that goes far more in-depth,\ninto all the different case scenarios for\n\n156\n00:07:22.730 --> 00:07:23.670\ndeploying a database.\n\n157\n00:07:23.670 --> 00:07:26.570\nLike doing it in the cloud or\nlocally or with replication, and\n\n158\n00:07:26.570 --> 00:07:28.300\nall these other crazy solutions.\n\n159\n00:07:28.300 --> 00:07:30.970\nAnd there is another course\nthat's out there, this one.\n\n160\n00:07:30.970 --> 00:07:34.970\nDeveloping SQL Data Models, and\nImplementing a SQL Data Warehouse.\n\n161\n00:07:34.970 --> 00:07:40.474\nThose two as well go far more in-depth,\nin how to get things set up.\n\n162\n00:07:40.474 --> 00:07:43.400\nSo here in 70-761 we're really\nfocusing on the bare minimum.\n\n163\n00:07:43.400 --> 00:07:45.724\nWhat's the minimum it takes to\nget a database up and running?\n\n164\n00:07:45.724 --> 00:07:48.830\nAnd to get a table in place and\nto be able to share some data with it?\n\n165\n00:07:48.830 --> 00:07:51.200\nBut those are the topics that we're\ngonna be covering as we move the course.\n\n166\n00:07:51.200 --> 00:07:54.610\nSo by the time we're done, you'll be\nable to complete each of these tasks.\n\n167\n00:07:54.610 --> 00:07:57.593\n&gt;&gt; Fantastic, well, if this sounds like\nsomething you'd be interested in, and\n\n168\n00:07:57.593 --> 00:07:58.134\nit should be.\n\n169\n00:07:58.134 --> 00:08:01.750\nThen Querying Data with\nTransact-SQL is for you.\n\n170\n00:08:01.750 --> 00:08:05.502\nSo make sure you catch every single\nepisode, and thanks for watching ITProTV.\n\n171\n00:08:05.502 --> 00:08:10.513\n[SOUND]\n\n",
          "vimeoId": "242964325"
        },
        {
          "description": "In this episode, Don provides the viewers with background on Transact-SQL and the differences between it and the ANSI standard Structured Query Language (SQL). He also introduces the three categories of T-SQL statements that will be explored throughout the remainder of the series.",
          "length": "1134",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-1-1-introduction_to_transact_sql-111317-PGM.00_18_41_11.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-1-1-introduction_to_transact_sql-111317-PGM.00_18_41_11.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-1-1-introduction_to_transact_sql-111317-PGM.00_18_41_11.Still001-sm.jpg",
          "title": "Introduction to Transact-SQL",
          "transcript": "WEBVTT\n\n1\n00:00:00.240 --> 00:00:06.055\nWelcome to ITPro TV, I'm your host,\n\n2\n00:00:06.055 --> 00:00:10.728\n[CROSSTALK]\n&gt;&gt; You're watching ITPro TV.\n\n3\n00:00:10.728 --> 00:00:13.980\n&gt;&gt; Hello and thank you for\nchoosing ITPro TV.\n\n4\n00:00:13.980 --> 00:00:16.850\nEmpowering the world\nwho engage in learning.\n\n5\n00:00:16.850 --> 00:00:17.853\nI'm your host Zack Memos.\n\n6\n00:00:17.853 --> 00:00:22.862\nAs we move into querying data with\nTransact-SQL and this episode it's\n\n7\n00:00:22.862 --> 00:00:28.130\nintroduction to Transact-SQL and\nwe've ask Don Pezet to show us the way.\n\n8\n00:00:28.130 --> 00:00:30.852\nBecause he is such a nice fellow\nhe thought he'd drop in and\n\n9\n00:00:30.852 --> 00:00:31.750\nhelp us out there.\n\n10\n00:00:31.750 --> 00:00:32.380\nHey Don, how are you doing?\n\n11\n00:00:32.380 --> 00:00:33.712\n&gt;&gt; I am doing great Zack.\n\n12\n00:00:33.712 --> 00:00:36.336\nReady to dive into the world\nof Transact-SQL and\n\n13\n00:00:36.336 --> 00:00:40.370\nthen get a chance to see a little bit\nabout how we talk to databases, right.\n\n14\n00:00:40.370 --> 00:00:44.460\nThis is the language we are gonna be\nusing throughout this whole series, so\n\n15\n00:00:44.460 --> 00:00:45.689\nwe are gonna learn a lot of the ins and\n\n16\n00:00:45.689 --> 00:00:48.280\nouts, the various commands that we\ncan use, and how we do that talk.\n\n17\n00:00:48.280 --> 00:00:51.966\nBut before we get that far, I thought it\nwould be a good idea to do an introduction\n\n18\n00:00:51.966 --> 00:00:54.617\nshow, to just talk about why\nwe even have this langauge?\n\n19\n00:00:54.617 --> 00:00:55.442\nWhere it came from?\n\n20\n00:00:55.442 --> 00:00:58.192\nAnd what it looks like before\nwe start diving in all the crazy\n\n21\n00:00:58.192 --> 00:00:59.789\ncommands that make up the langauge.\n\n22\n00:00:59.789 --> 00:01:02.430\n&gt;&gt; And so, first of all,\nfirst and foremost, what is SQL?\n\n23\n00:01:02.430 --> 00:01:04.700\nAll right, so what is SQL?\n\n24\n00:01:04.700 --> 00:01:07.250\nIt's somewhat of a loaded question, right.\n\n25\n00:01:07.250 --> 00:01:10.290\nAnd some of you out there in TV\nland right now might be saying,\n\n26\n00:01:10.290 --> 00:01:11.720\nwhy is Zach saying SQL?\n\n27\n00:01:11.720 --> 00:01:13.152\nIt's S-Q-L, right?\n\n28\n00:01:13.152 --> 00:01:16.870\n&gt;&gt; [LAUGH]\n&gt;&gt; There's this whole debate over\n\n29\n00:01:16.870 --> 00:01:19.590\nwhich one is the right pronunciation and\nfortunately in the Microsoft world we\n\n30\n00:01:19.590 --> 00:01:21.900\ndon't really have to worry about it,\nyou can say it either way.\n\n31\n00:01:21.900 --> 00:01:27.160\nIn the Unix world they get really picky\nabout it but it all goes back to history.\n\n32\n00:01:27.160 --> 00:01:30.080\nA long time ago, we had databases,\n\n33\n00:01:30.080 --> 00:01:31.980\nbut they weren't nearly as\nimportant as they are today.\n\n34\n00:01:31.980 --> 00:01:35.100\nToday, databases make up a part\nof everything that we do.\n\n35\n00:01:35.100 --> 00:01:36.220\nWhen you visit a website,\n\n36\n00:01:36.220 --> 00:01:39.300\nthe odds are a lot of its data is\nbeing rendered from a database.\n\n37\n00:01:39.300 --> 00:01:42.060\nA lot of the information that we\nwork with is coming from a database.\n\n38\n00:01:42.060 --> 00:01:47.060\nThey make things possible and\nthey recognize very early on that, man,\n\n39\n00:01:47.060 --> 00:01:48.850\nthese databases are so important.\n\n40\n00:01:48.850 --> 00:01:53.280\nAnd so many different people are coming\nup with database technologies out there.\n\n41\n00:01:53.280 --> 00:01:55.000\nLike IBM had their Db2.\n\n42\n00:01:55.000 --> 00:01:55.730\nYou had Delphi.\n\n43\n00:01:55.730 --> 00:01:57.440\nYou had Oracle's databases.\n\n44\n00:01:57.440 --> 00:02:00.610\nYou had, just a ton of various other ones.\n\n45\n00:02:00.610 --> 00:02:03.880\nMicrosoft SQL is actually one of their\noldest products but a lot of people don't\n\n46\n00:02:03.880 --> 00:02:07.990\nrealize that it's been out for a long,\nlong time since the early 80s.\n\n47\n00:02:07.990 --> 00:02:11.040\nSo these technologies,\nthey're all different.\n\n48\n00:02:11.040 --> 00:02:14.210\nAnd they said man if I'm a developer,\nI'm a programmer, and\n\n49\n00:02:14.210 --> 00:02:17.760\nI wanna reach into a database and\nget data out of it.\n\n50\n00:02:17.760 --> 00:02:21.230\nIf they are all different, now it have\ndifferent ways to talk to every one.\n\n51\n00:02:21.230 --> 00:02:27.060\nWould it be nice if we have one way to\nreach out and talk to those databases.\n\n52\n00:02:27.060 --> 00:02:29.380\nThe databases can be different,\nthey can be separate softwares but\n\n53\n00:02:29.380 --> 00:02:31.945\nif we have one way to talk to them it\nwill be easier to know what to expect and\n\n54\n00:02:31.945 --> 00:02:37.030\nthat's where this all came from,\nwhere SQL, came from.\n\n55\n00:02:37.030 --> 00:02:42.020\nNow in the original days, it actually\nwas called Sequel, the word, right.\n\n56\n00:02:42.020 --> 00:02:43.880\nAnd that's because what it stood for\n\n57\n00:02:43.880 --> 00:02:48.895\nwas the Structured English Query Language,\nall right?\n\n58\n00:02:48.895 --> 00:02:53.275\nAnd so they abbreviated it as S-E-Q-U-E-L,\nhowever you spell sequel.\n\n59\n00:02:53.275 --> 00:02:56.325\nSo [LAUGH] that's why they called it SQL,\nright?\n\n60\n00:02:56.325 --> 00:02:59.195\nBut it's actually,\nthere were two problems with the name.\n\n61\n00:02:59.195 --> 00:03:02.745\nOne problem is to said English in it and\nnowadays,\n\n62\n00:03:02.745 --> 00:03:04.865\nwe support a lot more\nlanguage than just English.\n\n63\n00:03:04.865 --> 00:03:08.360\nThe commands are in English, but\nthe data we move isn't and so,\n\n64\n00:03:08.360 --> 00:03:10.860\nthey'd decided to let's\njust drop English apart.\n\n65\n00:03:10.860 --> 00:03:15.910\nThe other problem was another company\nhad a copyright on that name SQL and\n\n66\n00:03:15.910 --> 00:03:18.050\nhandling data,\nsomething about airline data.\n\n67\n00:03:18.050 --> 00:03:21.250\nAnd so, there was a copyright dispute and\nthey've said, you know what, forget it,\n\n68\n00:03:21.250 --> 00:03:24.440\nwe'll just call SQL,\nStructured Query Language.\n\n69\n00:03:24.440 --> 00:03:27.220\nIt's a language that we can\nuse to talk to a database or\n\n70\n00:03:27.220 --> 00:03:31.330\nquery a database in a structure\nthat follows a certain format.\n\n71\n00:03:31.330 --> 00:03:35.760\nIt is consistent across multiple\nvendors and that's really the key,\n\n72\n00:03:35.760 --> 00:03:36.520\nthe secret here.\n\n73\n00:03:36.520 --> 00:03:41.378\nThe secret sauce behind SQL and why it's\nso successful is that pretty much every\n\n74\n00:03:41.378 --> 00:03:45.130\nrelational database that's\nout there supports SQL.\n\n75\n00:03:45.130 --> 00:03:50.000\nSo Microsoft SQL does,\nOracles database their 10i and so\n\n76\n00:03:50.000 --> 00:03:52.160\non, those databases all support it.\n\n77\n00:03:52.160 --> 00:03:58.700\nYou've post SQL, MySQL,\nMaria DB, all of those use SQL.\n\n78\n00:03:58.700 --> 00:04:02.530\nYou can write the same query and\nhave it run across all of them,\n\n79\n00:04:02.530 --> 00:04:04.750\nwhich is really, really nice.\n\n80\n00:04:04.750 --> 00:04:07.570\nIt let's you pick the database\nproduct that's right for you.\n\n81\n00:04:07.570 --> 00:04:08.900\nRight for your solution.\n\n82\n00:04:08.900 --> 00:04:10.610\nEach one has different bells and\nwhistles, right.\n\n83\n00:04:10.610 --> 00:04:14.270\nMicrosoft SQL has a ton of\nreally cool bells and whistles.\n\n84\n00:04:14.270 --> 00:04:16.010\nMaria DB is free.\n\n85\n00:04:16.010 --> 00:04:18.340\nSometimes free is better\nthan featureful right?\n\n86\n00:04:18.340 --> 00:04:22.630\nSo you make that choice, but the language\nyou use to talk to it is the same and\n\n87\n00:04:22.630 --> 00:04:27.420\nthat's really part of the power here,\nand SQL is now an ISO standard right.\n\n88\n00:04:27.420 --> 00:04:30.650\nSo it's an industry standard that\nanybody can use and follow and so\n\n89\n00:04:30.650 --> 00:04:32.440\na lot of people do.\n\n90\n00:04:32.440 --> 00:04:36.610\nNow as far as the terminology where\nI calling it sequel versus SQL.\n\n91\n00:04:36.610 --> 00:04:39.920\nEven though there was that whole\ncopyright mess and they changed to SQL,\n\n92\n00:04:39.920 --> 00:04:44.230\nin the Microsoft world, they still\ncall their product Microsoft Sequel.\n\n93\n00:04:44.230 --> 00:04:48.840\nSo you'll hear me say Sequel through most\nof the show and Zack do as well, but\n\n94\n00:04:48.840 --> 00:04:54.590\nin the Unix world, where they're all very\nconcerned about being freeze in B or\n\n95\n00:04:54.590 --> 00:04:57.160\nwhatever the slogan of\nthe Open Source Movement.\n\n96\n00:04:57.160 --> 00:05:00.825\nThey always make sure to say SQL, because\nthey don't wanna end up in any kind of\n\n97\n00:05:00.825 --> 00:05:03.790\ncopyright dispute or\nproprietary or whatever.\n\n98\n00:05:03.790 --> 00:05:07.090\nSo when you're operating in those spaces,\npeople will be really strict about that,\n\n99\n00:05:07.090 --> 00:05:12.010\nlike it's SQL but in the Microsoft\nworld we're allowed to say sequel,\n\n100\n00:05:12.010 --> 00:05:13.970\nthat's what we do oftentimes.\n\n101\n00:05:13.970 --> 00:05:17.690\n&gt;&gt; So where does Transact-SQL\nfit in in this whole process?\n\n102\n00:05:17.690 --> 00:05:20.240\n&gt;&gt; All right it's a good point, right,\nhere I am talking about SQL but\n\n103\n00:05:20.240 --> 00:05:24.010\nthe name of the show is that we're\ngonna be querying with Transact-SQL.\n\n104\n00:05:24.010 --> 00:05:25.480\nWhat's that all about?\n\n105\n00:05:25.480 --> 00:05:27.720\n&gt;&gt; Well SQL is a standard, right?\n\n106\n00:05:27.720 --> 00:05:32.460\nSQL is a standard, an ISO standard, and\nit's got a large set of commands but\n\n107\n00:05:32.460 --> 00:05:35.360\nI mentioned on Microsoft SQL Server\nhas a lot of extra features.\n\n108\n00:05:35.360 --> 00:05:38.150\nA lot of bells and whistles,\nbonus items, right?\n\n109\n00:05:38.150 --> 00:05:40.580\nWell SQL doesn't account for\n\n110\n00:05:40.580 --> 00:05:44.750\nthat because Microsoft might have\na feature that nobody else does.\n\n111\n00:05:44.750 --> 00:05:47.750\nSo they're not gonna make those commands\npart of the standard when nobody else can\n\n112\n00:05:47.750 --> 00:05:49.310\nsupport that feature anyway right?\n\n113\n00:05:49.310 --> 00:05:50.730\nIt's a proprietary feature,\n\n114\n00:05:50.730 --> 00:05:56.215\nso what Microsoft had to do is they\nhad to take SQL, and modify it okay?\n\n115\n00:05:56.215 --> 00:06:01.080\nTransact-SQL is Microsoft's\nown version Of SQL.\n\n116\n00:06:01.080 --> 00:06:06.150\nNow, before you get worried about that,\nTransact-SQL is 100% compatible with SQL.\n\n117\n00:06:06.150 --> 00:06:10.930\nSo everything you can do in SQL\nstill works under Transact-SQL, but\n\n118\n00:06:10.930 --> 00:06:12.240\nthe reverse is not true.\n\n119\n00:06:12.240 --> 00:06:15.580\nThere are certain commands that we\nhave in Transact-SQL that aren't\n\n120\n00:06:15.580 --> 00:06:18.500\npresent in regular old SQL, right.\n\n121\n00:06:18.500 --> 00:06:21.350\nNow, in this series I'm gonna try and\n\n122\n00:06:21.350 --> 00:06:24.920\nfocus on ones that\nare fully SQL compliant.\n\n123\n00:06:24.920 --> 00:06:29.370\nSo the bulk of what we learn here\nwill work on Oracle or post-brass or\n\n124\n00:06:29.370 --> 00:06:32.290\nwhatever other database it is you\nwant to use but there's a few we're\n\n125\n00:06:32.290 --> 00:06:36.250\ngoing to talk about especially later\nin the series that are Microsoft only.\n\n126\n00:06:36.250 --> 00:06:39.520\nAnd I will be sure to highlight those\nviews, so that you know when there is that\n\n127\n00:06:39.520 --> 00:06:43.560\ndifference but in this series, in this\nshow, we are learning about Transact-SQL.\n\n128\n00:06:43.560 --> 00:06:45.600\nWe are learning about\nMicrosoft's version of it.\n\n129\n00:06:45.600 --> 00:06:48.990\nNow, the difference is a lot of\nthem are really small, right.\n\n130\n00:06:48.990 --> 00:06:50.090\nLet me give you an example, right.\n\n131\n00:06:50.090 --> 00:06:55.200\nSo, I have got in my computer here,\nthis is a normal query, right.\n\n132\n00:06:55.200 --> 00:06:59.720\nI am saying select star, which means I\nwanna get everything from Person.Person.\n\n133\n00:06:59.720 --> 00:07:01.110\nThat's a table, all right.\n\n134\n00:07:01.110 --> 00:07:03.940\nAnd then I've got a semicolon which tells\nthe system that that's the end of my\n\n135\n00:07:03.940 --> 00:07:04.920\ncommand, all right?\n\n136\n00:07:04.920 --> 00:07:10.360\nThis is straight SQL according to\nISUS standard and if I run that,\n\n137\n00:07:10.360 --> 00:07:15.360\nit's gonna run and I get that table\ndata back and it works, okay.\n\n138\n00:07:15.360 --> 00:07:19.154\nIn the ISUS standard, this says\ncommand should end in a semi colon but\n\n139\n00:07:19.154 --> 00:07:25.080\nin Transact-SQL, Microsoft says,\nif you press Enter and\n\n140\n00:07:25.080 --> 00:07:28.090\nif I've got all the information I need,\nI know that's a command.\n\n141\n00:07:28.090 --> 00:07:28.890\nI can run it.\n\n142\n00:07:28.890 --> 00:07:31.420\nIf I get rid of that semicolon, and\n\n143\n00:07:31.420 --> 00:07:36.650\nthen I run it, it queries,\nand I get the database back.\n\n144\n00:07:36.650 --> 00:07:38.130\nI can leave the semicolon off.\n\n145\n00:07:38.130 --> 00:07:42.160\nNow if you do that on MySQL or\nMariaDB, Error, right,\n\n146\n00:07:42.160 --> 00:07:43.910\nyou get an error because\nyou didn't get a semicolon.\n\n147\n00:07:43.910 --> 00:07:46.530\nIt's waiting for the rest of your command,\nlet's just sit there and wait for\n\n148\n00:07:46.530 --> 00:07:48.010\nyou to put in the rest of your command.\n\n149\n00:07:48.010 --> 00:07:53.624\nThat's the difference between Transact-SQL\nand the ISO standard of SQL, right?\n\n150\n00:07:53.624 --> 00:07:58.543\nAlso I could do something like a little\nmore involved like I could say\n\n151\n00:07:58.543 --> 00:08:00.020\nI wanna get people.\n\n152\n00:08:01.600 --> 00:08:06.373\nWhat do I wanna do?\nI'll say where the last name\n\n153\n00:08:06.373 --> 00:08:11.470\nis not equal to Smith right?\n\n154\n00:08:11.470 --> 00:08:15.680\nIn or sorry, let me change that,\nI just made a mistake myself.\n\n155\n00:08:15.680 --> 00:08:17.690\nWe will do that one.\n\n156\n00:08:17.690 --> 00:08:18.772\nWhoops, there we go.\n\n157\n00:08:18.772 --> 00:08:23.120\nAll right, so the less than symbol\nfollowed by the greater than symbol, okay.\n\n158\n00:08:23.120 --> 00:08:26.930\nI'm saying we're less name\nis not equal to Smith.\n\n159\n00:08:26.930 --> 00:08:29.240\nNow if I stick a semicolon on the end,\n\n160\n00:08:29.240 --> 00:08:34.710\nwhat I have right there is\na fully SQL ISO compliant query.\n\n161\n00:08:34.710 --> 00:08:38.273\nIt's gonna pull this list of names,\nand let's see how many I got before.\n\n162\n00:08:38.273 --> 00:08:42.788\nSo when I ran that query a moment ago,\nI got 19,972 rows.\n\n163\n00:08:42.788 --> 00:08:43.848\nThat's a lot.\n\n164\n00:08:43.848 --> 00:08:44.854\n&gt;&gt; That's a few.\n\n165\n00:08:44.854 --> 00:08:47.666\n[LAUGH]\n&gt;&gt; And so I'm gonna rerun that query and\n\n166\n00:08:47.666 --> 00:08:51.690\nnow it's gonna come back and all\nthe Smiths are going to be gone, right?\n\n167\n00:08:51.690 --> 00:08:55.280\nSo if I go down and\nlook, now I have 19,869.\n\n168\n00:08:55.280 --> 00:08:58.120\nRight, so it went down by 103.\n\n169\n00:08:58.120 --> 00:09:01.350\nI guess there were 103 Smiths in there.\n\n170\n00:09:01.350 --> 00:09:02.950\nSo they're all gone now, right?\n\n171\n00:09:02.950 --> 00:09:08.370\nSo that's a valid ISO compliant query but\nin Transact SQL,\n\n172\n00:09:08.370 --> 00:09:13.000\nnot only can I leave the semicolon off but\nI can use regular boolean operators.\n\n173\n00:09:13.000 --> 00:09:15.950\nSo I could say,\nexclamation point equals, right?\n\n174\n00:09:15.950 --> 00:09:17.200\nWhat, what did I type the first time?\n\n175\n00:09:17.200 --> 00:09:22.830\nSo that is Transact-SQL, right there and\nwhen I run it, it's gonna run.\n\n176\n00:09:22.830 --> 00:09:28.269\nAnd I get the same thing, it pulls the\nquery I gets 19,869 really small number\n\n177\n00:09:28.269 --> 00:09:29.085\n&gt;&gt; [LAUGH]\n\n178\n00:09:29.085 --> 00:09:31.250\n&gt;&gt; Squint down here on my screen, but\n\n179\n00:09:31.250 --> 00:09:35.300\nI get that number back and it works,\nright, that's a variation,\n\n180\n00:09:35.300 --> 00:09:38.890\nit's a difference between trans SQL and\nSQL.\n\n181\n00:09:38.890 --> 00:09:44.630\nNow remember what I said earlier, anything\nwe can do in SQL, works in Transact-SQL.\n\n182\n00:09:44.630 --> 00:09:48.090\nSo, if I wrote it that way I\nhad it a moment ago, it worked.\n\n183\n00:09:48.090 --> 00:09:50.430\nIf I want to write it the Transact-SQL,\nI can't.\n\n184\n00:09:50.430 --> 00:09:53.750\nThe problem here is\nthe reverse is not true.\n\n185\n00:09:53.750 --> 00:09:57.240\nIf I take this command, and\nI run it in MySQL or this command and\n\n186\n00:09:57.240 --> 00:09:58.980\nrun it in Maria DB, it's not gonna work.\n\n187\n00:09:58.980 --> 00:10:04.180\nI'm gonna get an error because they're\nnot expecting exclamation point equals.\n\n188\n00:10:04.180 --> 00:10:08.550\nThey're expecting less than followed by\ngreater than to indicate not equal to.\n\n189\n00:10:08.550 --> 00:10:10.050\nSo, those are the variations.\n\n190\n00:10:10.050 --> 00:10:14.600\nNow, I recommend that you\nget used to writing in\n\n191\n00:10:14.600 --> 00:10:17.910\nSQL instead of translating\nSQL whenever you can, right?\n\n192\n00:10:17.910 --> 00:10:21.410\nEspecially if you intend to work with\nother database products, right, but\n\n193\n00:10:21.410 --> 00:10:23.110\nif you're in an all Microsoft shop,\n\n194\n00:10:23.110 --> 00:10:25.710\nyou can throw caution to the wind and\nwrite it their way.\n\n195\n00:10:25.710 --> 00:10:28.810\nTheir way is oftentimes easier and\nyou can go in and do that and\n\n196\n00:10:28.810 --> 00:10:29.970\nkind of get used to it.\n\n197\n00:10:29.970 --> 00:10:34.360\nBut, you'll find that, for me, I usually\ndo a bit of a mixture where I always end\n\n198\n00:10:34.360 --> 00:10:37.210\nmy commands in a semicolon because\nthat's what I'm used to doing.\n\n199\n00:10:37.210 --> 00:10:41.930\nBut then the exclamation point equals, I'm\nkind of used to writing it that way and\n\n200\n00:10:41.930 --> 00:10:44.440\nI always have to correct myself\nwhen I'm on other systems.\n\n201\n00:10:44.440 --> 00:10:47.820\nIf you learn it the SQL way, you don't\nhave to worry about correcting yourself,\n\n202\n00:10:47.820 --> 00:10:49.080\nit does work.\n\n203\n00:10:49.080 --> 00:10:52.860\nWhat we'll find as the series go on and\nwhen we get to those Microsoft specific\n\n204\n00:10:52.860 --> 00:10:55.792\ncommands, those are the ones\nthat break SQL.\n\n205\n00:10:55.792 --> 00:10:59.080\nThey're Transact-SQL and they,\nthey're not cross-compatible.\n\n206\n00:10:59.080 --> 00:11:02.370\nSo we just need to be aware of when we're\ndoing things that aren't cross-compatible.\n\n207\n00:11:02.370 --> 00:11:03.840\n&gt;&gt; So because I'm a common man,\n\n208\n00:11:03.840 --> 00:11:07.240\nwhat are some of the common\ncommands that we might find in SQL?\n\n209\n00:11:07.240 --> 00:11:09.690\n&gt;&gt; All right, so\nwe've got a lot of commands.\n\n210\n00:11:09.690 --> 00:11:11.070\nWhat I've just showed you here.\n\n211\n00:11:11.070 --> 00:11:14.670\nThe command is actually the very first\nword that I did Select, all right?\n\n212\n00:11:14.670 --> 00:11:18.290\nI'm telling I'm telling that I wanna\nselect information from the databases.\n\n213\n00:11:18.290 --> 00:11:22.910\nThe easiest way to read data from the\ndatabase and you'll find that select is\n\n214\n00:11:22.910 --> 00:11:26.290\nprobably the most commonly used\ncommand in your environment.\n\n215\n00:11:26.290 --> 00:11:29.334\nThere's certainly cases that\ndo things differently but\n\n216\n00:11:29.334 --> 00:11:31.824\nmost people are reading data\nout of the database right?\n\n217\n00:11:31.824 --> 00:11:36.025\nSo that's what select does, but there's\na lot of there's a lot of other commands.\n\n218\n00:11:36.025 --> 00:11:39.488\nSome of the other things you see\nhighlighted in blue here like from or\n\n219\n00:11:39.488 --> 00:11:42.570\nwhere, those aren't commands in and\nof themselves.\n\n220\n00:11:42.570 --> 00:11:45.410\nThose are modifiers to the SELECT command.\n\n221\n00:11:45.410 --> 00:11:47.840\nWe're telling the SELECT\ncommand to do some extra stuff,\n\n222\n00:11:47.840 --> 00:11:51.760\nright, but they're not commands in and\nof themselves, right?\n\n223\n00:11:51.760 --> 00:11:53.570\nWhere doesn't work by itself.\n\n224\n00:11:53.570 --> 00:11:56.750\nIt has to be used as part of\na SELECT statement and so\n\n225\n00:11:56.750 --> 00:12:00.540\nyou'll find that each command has its own\nset of sub commands that go along with it.\n\n226\n00:12:00.540 --> 00:12:05.740\nAnd as we talk to the database we will\nencounter quite a few of these okay?\n\n227\n00:12:05.740 --> 00:12:09.990\nNow all the commands are divided\nup into three categories.\n\n228\n00:12:09.990 --> 00:12:12.000\nThese three categories\nright here all right?\n\n229\n00:12:12.000 --> 00:12:15.900\nThere's the data manipulation\nlanguage which is how we\n\n230\n00:12:15.900 --> 00:12:19.170\nreach into the database and\nread and write data.\n\n231\n00:12:19.170 --> 00:12:23.270\nThe select command that I just ran,\nthat's a example of data manipulation.\n\n232\n00:12:23.270 --> 00:12:26.020\nI didn't actually manipulate data,\nI just retrieved it.\n\n233\n00:12:26.020 --> 00:12:27.920\nAlthough you could say that's\na way of manipulating it,\n\n234\n00:12:27.920 --> 00:12:29.850\nyour getting it out of the data.\n\n235\n00:12:29.850 --> 00:12:30.380\nSo DML or\n\n236\n00:12:30.380 --> 00:12:34.990\nthe Data Manipulation Language is how we\nwork with the data inside the database.\n\n237\n00:12:36.880 --> 00:12:41.980\nDDL, the Data Definition Language, is how\nwe actually work with the database itself.\n\n238\n00:12:41.980 --> 00:12:43.620\nHow do I make a database?\n\n239\n00:12:43.620 --> 00:12:45.090\nHow do I make a table?\n\n240\n00:12:45.090 --> 00:12:49.750\nHow do I define what kind of data\nis allowed to be in the database?\n\n241\n00:12:49.750 --> 00:12:52.460\nThat kind of stuff is\nData Definition Language.\n\n242\n00:12:52.460 --> 00:12:55.360\nSo, think of that as more\nof a construction worker.\n\n243\n00:12:55.360 --> 00:12:56.420\nI'm gonna build the building.\n\n244\n00:12:56.420 --> 00:12:58.990\nI don't know what's going in the building,\nbut I'm gonna build the building.\n\n245\n00:12:58.990 --> 00:13:02.660\nThat's what DDL does and meanwhile,\nData Manipulation Langauge is how we fill\n\n246\n00:13:02.660 --> 00:13:05.220\nthe building with the people\nthat are doing the job.\n\n247\n00:13:05.220 --> 00:13:08.960\nNow the last one is DCL,\nData Control Language and\n\n248\n00:13:08.960 --> 00:13:12.870\nData Control Language is\nhow we secure the servers.\n\n249\n00:13:12.870 --> 00:13:15.350\nHow we manage permissions,\nand things of that nature.\n\n250\n00:13:15.350 --> 00:13:20.010\nIn this series, we're probably not\ngonna cover any DCL commands, but\n\n251\n00:13:20.010 --> 00:13:22.270\nI want you to be aware that\nthat is the third language.\n\n252\n00:13:22.270 --> 00:13:26.660\nIf you go on to do,\nlike this is the 70-761 course,\n\n253\n00:13:26.660 --> 00:13:31.240\nif you go on to do 70-762, or\nthree, five, you know those guys.\n\n254\n00:13:31.240 --> 00:13:33.520\nActually I don't think there is a three,\nas it goes to four and five.\n\n255\n00:13:33.520 --> 00:13:37.210\n[LAUGH] If you go and do those you'll see\na lot of DCL in them cuz you gotta sign\n\n256\n00:13:37.210 --> 00:13:40.740\npermissions, right, in this one we were\nmore focused in working with the data, so\n\n257\n00:13:40.740 --> 00:13:44.120\nwe're gonna be dealing mostly with\ndata manipulation language and\n\n258\n00:13:44.120 --> 00:13:48.350\nwe'll do a little bit of DDL,\nthe data definition language, right.\n\n259\n00:13:48.350 --> 00:13:51.920\nThough inside of them like data\nmanipulation there four common commands\n\n260\n00:13:51.920 --> 00:13:56.610\nthat we are gonna use in this series\nare select, which is how we read data.\n\n261\n00:13:56.610 --> 00:14:00.060\nInsert that's how we add new data.\n\n262\n00:14:00.060 --> 00:14:03.680\nUpdate, that's how we\nchange existing data and\n\n263\n00:14:03.680 --> 00:14:07.610\ndelete, that how we remove data, and\nget it out of the database, right?\n\n264\n00:14:07.610 --> 00:14:13.860\nThose four commands make up the bulk\nof what every database does every day.\n\n265\n00:14:13.860 --> 00:14:18.120\nRemember I said that SELECT is the one\nthat you're really going to use the most?\n\n266\n00:14:18.120 --> 00:14:20.380\nWell, if we group all\nfour of these together,\n\n267\n00:14:20.380 --> 00:14:26.190\nit's like 99.9% of the queries that are\nrun are these four commands right here.\n\n268\n00:14:26.190 --> 00:14:29.670\nThese are what we do as we add data and\nremove it.\n\n269\n00:14:29.670 --> 00:14:31.740\nYou don't build a database everyday but\n\n270\n00:14:31.740 --> 00:14:35.230\nyou use the data in it every day\npossibly every second, right.\n\n271\n00:14:35.230 --> 00:14:39.403\nIf you're Amazon.com and you've got a huge\nproduct database people are searching\n\n272\n00:14:39.403 --> 00:14:41.670\nyour database for products all the time.\n\n273\n00:14:41.670 --> 00:14:45.880\nThey're doing selects to find their\nproduct and when they want to go and\n\n274\n00:14:45.880 --> 00:14:47.410\nbuy, they are creating an order.\n\n275\n00:14:47.410 --> 00:14:50.960\nThey're inserting an order and\nwhen they change order details or\n\n276\n00:14:50.960 --> 00:14:52.920\ncredit card information, they're updating.\n\n277\n00:14:52.920 --> 00:14:57.530\nUpdating that information and, at some\npoint, we decide we've got old orders we\n\n278\n00:14:57.530 --> 00:15:00.010\ndon't need to save anymore and\nwe delete them and we get them out.\n\n279\n00:15:00.010 --> 00:15:03.060\nThat's regular, routine operations\nthat most databases have.\n\n280\n00:15:04.060 --> 00:15:05.560\nDDL's less common, right?\n\n281\n00:15:05.560 --> 00:15:07.500\nThat's the one where we're\nbuilding a database.\n\n282\n00:15:07.500 --> 00:15:09.090\nI create a database.\n\n283\n00:15:09.090 --> 00:15:10.840\nI create a table.\n\n284\n00:15:10.840 --> 00:15:14.310\nI create a data type inside of that table.\n\n285\n00:15:14.310 --> 00:15:14.860\nI'm building.\n\n286\n00:15:15.960 --> 00:15:18.340\nI alter when I want to change something.\n\n287\n00:15:18.340 --> 00:15:21.880\nI change the table to add a new column or\nsomething of that nature, right?\n\n288\n00:15:21.880 --> 00:15:25.670\nWe use the alter command for that and\nthen delete comes back, because instead of\n\n289\n00:15:25.670 --> 00:15:28.610\ndeleting data from a table,\nnow I might be deleting a table itself.\n\n290\n00:15:28.610 --> 00:15:30.350\nOr deleting the database, right?\n\n291\n00:15:30.350 --> 00:15:32.420\nThe DELETE command does that.\n\n292\n00:15:32.420 --> 00:15:33.890\nActually you don't delete a database,\n\n293\n00:15:33.890 --> 00:15:36.510\nthere's another command I didn't put\non here called DROP, which would drop\n\n294\n00:15:36.510 --> 00:15:41.340\nthe database, but DELETE is how we\nwould delete a table, for example.\n\n295\n00:15:41.340 --> 00:15:44.580\nAnd then lastly we get the data control\nlanguage, which again, I said we're not\n\n296\n00:15:44.580 --> 00:15:49.120\ngoing to tackle much here in this show but\nyou've got GRANT, REVOKE, and DENY.\n\n297\n00:15:49.120 --> 00:15:52.540\nGRANT is how you give permission for\nsomeone to do something.\n\n298\n00:15:52.540 --> 00:15:56.090\nREVOKE is how you take away\nsomebody's person to do something and\n\n299\n00:15:56.090 --> 00:16:00.200\nDENY is how you make sure that\nsomebody never gets permission\n\n300\n00:16:00.200 --> 00:16:04.000\nto something no matter what,\neven if I go and grant them afterwards.\n\n301\n00:16:04.000 --> 00:16:06.980\nIf they're still denied they won't\nbe able to have that access.\n\n302\n00:16:06.980 --> 00:16:10.490\nSo those are examples of\ncommands that you would\n\n303\n00:16:12.060 --> 00:16:15.780\nuse in the Data Control Language.\n\n304\n00:16:15.780 --> 00:16:21.480\nThat really doesn't seem like\na lot of commands does it right?\n\n305\n00:16:21.480 --> 00:16:27.070\nBetween those diagrams there we've\ngot what is it ten commands right?\n\n306\n00:16:27.070 --> 00:16:29.220\nSo it sounds like a pretty easy task.\n\n307\n00:16:29.220 --> 00:16:31.920\nBut each command has so\nmany variations and so\n\n308\n00:16:31.920 --> 00:16:35.450\nmany different ways of using it,\nespecially the SELECT command,\n\n309\n00:16:35.450 --> 00:16:38.810\nthat you'll find it takes a long\ntime to master all ten of them.\n\n310\n00:16:38.810 --> 00:16:43.580\nSome of them are really easy like DELETE,\nDELETE's no big deal But SELECT, INSERT,\n\n311\n00:16:43.580 --> 00:16:44.790\nINSERT is really tricky.\n\n312\n00:16:44.790 --> 00:16:46.780\nAnd there's a few of\nthe other ones like create,\n\n313\n00:16:46.780 --> 00:16:48.330\nwhere you have to know all\nthese different options.\n\n314\n00:16:48.330 --> 00:16:50.680\nYou guys will see that there's\nactually a lot more involved in it but\n\n315\n00:16:50.680 --> 00:16:54.120\nthese are the commands that we're gonna\nbe focusing on as we move to the series.\n\n316\n00:16:54.120 --> 00:16:55.180\n&gt;&gt; Wonderful information.\n\n317\n00:16:55.180 --> 00:16:56.070\nI am so excited.\n\n318\n00:16:56.070 --> 00:16:57.190\nI can't wait to find out more.\n\n319\n00:16:57.190 --> 00:16:59.890\nThis was the introduction\nto Transact-SQL and\n\n320\n00:16:59.890 --> 00:17:02.150\nDonnie your last words before we move on.\n\n321\n00:17:02.150 --> 00:17:07.650\n&gt;&gt; Main thing here is, a lot of people\nthink of SQL is a programming language and\n\n322\n00:17:07.650 --> 00:17:09.370\nI would disagree with that.\n\n323\n00:17:09.370 --> 00:17:11.040\nWe can put some logic in there, and\n\n324\n00:17:11.040 --> 00:17:15.405\nyou can do some things that it starts\nto become sort of like programming but\n\n325\n00:17:15.405 --> 00:17:19.080\nTransact-SQL and SQL itself, it's more\nlike learning a foreign language.\n\n326\n00:17:19.080 --> 00:17:22.310\nIt's just learning how to talk to\nthe database, to ask it a question.\n\n327\n00:17:22.310 --> 00:17:23.520\nI might say hey,\n\n328\n00:17:23.520 --> 00:17:28.540\nI need a list of employees whose\nlast name starts with s, right.\n\n329\n00:17:28.540 --> 00:17:31.510\nI don't need to be a programmer, I just\nneed to know how to word that question\n\n330\n00:17:31.510 --> 00:17:34.580\nthe way the server will expect it and\nthen it'll give me the data that I want.\n\n331\n00:17:34.580 --> 00:17:38.070\nAnd if I want it in a server,\nI need a list of every employee whose\n\n332\n00:17:38.070 --> 00:17:42.420\nlast name starts with S and if you could\nsort it alphabetically for me, right?\n\n333\n00:17:42.420 --> 00:17:45.240\nThat kind of thing,\nwe just need to know the way to say it and\n\n334\n00:17:45.240 --> 00:17:47.180\nthat's really what Transact-SQL is.\n\n335\n00:17:47.180 --> 00:17:51.380\nSo as you go and learn this,\nI want you to be thinking of that.\n\n336\n00:17:51.380 --> 00:17:55.490\nThink of what's the question I want to\nask in English, or whatever your native\n\n337\n00:17:55.490 --> 00:17:59.750\nlanguage happens to be, and then how\nwould I write that in Transact-SQL?\n\n338\n00:17:59.750 --> 00:18:02.010\nIt's just building up the idea\nin your head, first of all.\n\n339\n00:18:02.010 --> 00:18:06.480\nLike what do I want in English helps you\nto then figure out what the command would\n\n340\n00:18:06.480 --> 00:18:09.320\nbe in Transact-SQL and all the different\ncomponents that you need and the pieces.\n\n341\n00:18:09.320 --> 00:18:13.070\nSo always bear that in mind as we go\nthrough every episode in this series,\n\n342\n00:18:13.070 --> 00:18:16.230\nthat it is like learning\na foreign language.\n\n343\n00:18:16.230 --> 00:18:19.550\n&gt;&gt; Querying Data with Transact-SQL,\ngreat show.\n\n344\n00:18:19.550 --> 00:18:23.070\nDon's doing a wonderful job and\nwill continue to do so is his way.\n\n345\n00:18:23.070 --> 00:18:27.530\nMake sure you watch every single episode\nof Querying Data with Transact-SQL and\n\n346\n00:18:27.530 --> 00:18:28.810\nalso, when you're in the course library,\n\n347\n00:18:28.810 --> 00:18:30.730\ncheck out the other hundreds\nof videos in there.\n\n348\n00:18:30.730 --> 00:18:34.078\nThey're all designed to do one thing,\nhelp you go further and\n\n349\n00:18:34.078 --> 00:18:36.000\ntell everybody you know about IT Pro TV.\n\n350\n00:18:36.000 --> 00:18:37.370\nThey'll be glad you did.\n\n351\n00:18:37.370 --> 00:18:38.020\nThanks for watching.\n\n352\n00:18:38.020 --> 00:18:38.970\nI'm Zack Memos.\n\n353\n00:18:38.970 --> 00:18:39.685\n&gt;&gt; And I'm Don Pizzatt.\n\n354\n00:18:39.685 --> 00:18:40.288\n&gt;&gt; And we will see you soon.\n\n355\n00:18:40.288 --> 00:18:48.046\n[MUSIC]\n\n356\n00:18:48.046 --> 00:18:50.570\n&gt;&gt; Thank you for watching IT Pro TV.\n\n",
          "vimeoId": "242963954"
        },
        {
          "description": "In this episode, Don demonstrates how to use the Microsoft SQL Server Management Studio (SSMS) to issue T-SQL queries against a server. He shows how to install the SSMS and get it connected to a database. He also highlights some of the benefits of using the SSMS like IntelliSense syntax highlighting and autocomplete.",
          "length": "1908",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-1-2-introduction_to_transact_sql_pt2-111417-PGM.00_31_34_02.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-1-2-introduction_to_transact_sql_pt2-111417-PGM.00_31_34_02.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-1-2-introduction_to_transact_sql_pt2-111417-PGM.00_31_34_02.Still001-sm.jpg",
          "title": "Introduction to Transact-SQL Part 2",
          "transcript": "WEBVTT\n\n1\n00:00:00.270 --> 00:00:01.941\nWelcome to ITProTV.\n\n2\n00:00:01.941 --> 00:00:03.975\nI'm your host, Don Pezet.\n\n3\n00:00:03.975 --> 00:00:04.829\n[CROSSTALK]\n[MUSIC]\n\n4\n00:00:04.829 --> 00:00:11.112\n&gt;&gt; You're watching ITProTV.\n\n5\n00:00:11.112 --> 00:00:16.850\n&gt;&gt; Welcome ladies and gentlemen to your\nQuerying Data with Trasact-SQL show.\n\n6\n00:00:16.850 --> 00:00:18.024\nI'm your host, Cherokee Boose.\n\n7\n00:00:18.024 --> 00:00:20.450\nThis is actually a part two.\n\n8\n00:00:20.450 --> 00:00:22.630\nIf you haven't seen the first one,\nI suggest you do that.\n\n9\n00:00:22.630 --> 00:00:27.460\nBut we're gonna continue taking a look\nat an introduction to Transact-SQL.\n\n10\n00:00:27.460 --> 00:00:30.390\nAnd with us today, back in studios,\nwe have Mr. Don Pezet.\n\n11\n00:00:30.390 --> 00:00:32.091\nThank you for joining us today, Don.\n\n12\n00:00:32.091 --> 00:00:33.470\n&gt;&gt; Hey, thanks for having me, Cherokee.\n\n13\n00:00:33.470 --> 00:00:34.656\nAnd if you watched part one,\n\n14\n00:00:34.656 --> 00:00:37.384\nyou know we learned a little bit\nof the history of Transact-SQL.\n\n15\n00:00:37.384 --> 00:00:43.200\nWhat it is, how it differs from just the\nnormal SQL, and some of the basics there.\n\n16\n00:00:43.200 --> 00:00:46.522\nAnd in this episode, what I wanna do\nis continue on with the basics and\n\n17\n00:00:46.522 --> 00:00:47.782\nintroduce you to, well,\n\n18\n00:00:47.782 --> 00:00:51.537\nthe way that we actually issue these\ncommands against the database service.\n\n19\n00:00:51.537 --> 00:00:54.669\nSo if we're gonna learn all these\ncommands, we need to know how to actually\n\n20\n00:00:54.669 --> 00:00:58.070\nthrow them at the server, and we'll get\na chance to see that and walk through it.\n\n21\n00:00:58.070 --> 00:00:59.027\nIf you already know how to do that,\n\n22\n00:00:59.027 --> 00:01:00.950\nthough, you're not gonna hurt my\nfeelings if you skip the episode.\n\n23\n00:01:00.950 --> 00:01:02.936\n&gt;&gt; [LAUGH]\n&gt;&gt; We're not gonna do a whole\n\n24\n00:01:02.936 --> 00:01:06.540\nlot of actual SQL\nlanguage in this episode.\n\n25\n00:01:06.540 --> 00:01:10.110\nIt's gonna be focused more on just\nthe usability of that interface.\n\n26\n00:01:10.110 --> 00:01:12.992\n&gt;&gt; All right, Don, so in all honesty,\nI did skip the episode.\n\n27\n00:01:12.992 --> 00:01:14.573\n&gt;&gt; [LAUGH]\n&gt;&gt; I wasn't here for the last one.\n\n28\n00:01:14.573 --> 00:01:17.090\nYou might have to help\nme out a little bit.\n\n29\n00:01:17.090 --> 00:01:20.400\nSo what kind of program are we gonna\nbe using to execute these commands?\n\n30\n00:01:20.400 --> 00:01:22.842\nIs there anything I need\nto set up ahead of time?\n\n31\n00:01:22.842 --> 00:01:26.456\n&gt;&gt; All right, well, the reality is any\nSQL compatible client can issue commands\n\n32\n00:01:26.456 --> 00:01:28.496\nagainst the Microsoft SQL Server, right?\n\n33\n00:01:28.496 --> 00:01:31.130\nAnd there are tons of\nthem that are out there.\n\n34\n00:01:31.130 --> 00:01:34.060\nBut if you've gone through the effort\nto get Microsoft SQL Server,\n\n35\n00:01:34.060 --> 00:01:36.270\nthe odds are you're going\nto use their tools.\n\n36\n00:01:36.270 --> 00:01:39.219\nAnd if you are a database administrator or\na system administrator,\n\n37\n00:01:39.219 --> 00:01:42.700\nthe number one tool that you're gonna\nuse is the SQL Server Management Studio.\n\n38\n00:01:42.700 --> 00:01:44.526\nAnd sometimes,\nMicrosoft will abbreviate it SSMS.\n\n39\n00:01:44.526 --> 00:01:47.431\nThat's a lot of letters, so\nI usually just say it out, but\n\n40\n00:01:47.431 --> 00:01:49.860\nit's the SQL Server Management Studio.\n\n41\n00:01:49.860 --> 00:01:53.215\nIt is a tool that is\npackaged with SQL Server.\n\n42\n00:01:53.215 --> 00:01:56.453\nSo if you go and\ndownload SQL Server Enterprise Edition or\n\n43\n00:01:56.453 --> 00:02:00.837\nthe Standard Edition, even the Express\nEdition, some of the downloads have\n\n44\n00:02:00.837 --> 00:02:04.961\na package, some don't, but\nyou get the SQL Server Management Studio.\n\n45\n00:02:04.961 --> 00:02:08.315\nAnd you can take it, you install it,\nyou run it, connect to a server, and\n\n46\n00:02:08.315 --> 00:02:11.728\nit gives you the full ability to manage\nand interoperate with that server,\n\n47\n00:02:11.728 --> 00:02:14.190\nespecially with issuing queries and\nrunning those.\n\n48\n00:02:14.190 --> 00:02:18.910\nNow the SQL Server Management Studio, you\nmight wonder why it has such a long name.\n\n49\n00:02:18.910 --> 00:02:21.266\nIt's actually a variation of\nMicrosoft's Visual Studio.\n\n50\n00:02:21.266 --> 00:02:25.131\nSo if you're a developer,\nmaybe use Microsoft Visual Studio for\n\n51\n00:02:25.131 --> 00:02:28.517\ndoing C# development, or\nVisual Basic, or whatever.\n\n52\n00:02:28.517 --> 00:02:29.881\nWell, in the olden days,\n\n53\n00:02:29.881 --> 00:02:33.787\nMicrosoft SQL Server actually used\nthe standard MMC that all of our regular\n\n54\n00:02:33.787 --> 00:02:38.860\nadministration tools do because they were\ngearing it towards system administrators.\n\n55\n00:02:38.860 --> 00:02:42.699\nBut what they found was that more and more\noften, it wasn't the system administrator\n\n56\n00:02:42.699 --> 00:02:46.540\nthat had to talk to the database server,\nit was the developers that did.\n\n57\n00:02:46.540 --> 00:02:47.811\nAnd so they made the decision to switch.\n\n58\n00:02:47.811 --> 00:02:51.965\nAnd this was a long time ago, I think\nin 2005, when they switched and said,\n\n59\n00:02:51.965 --> 00:02:54.693\nwe're gonna start using\nbasically Visual Studio or\n\n60\n00:02:54.693 --> 00:02:57.760\nthat type of interface to\ninteract with the server.\n\n61\n00:02:57.760 --> 00:03:01.380\nAnd so now that's what we have, the SQL\nServer Management Studio, which looks\n\n62\n00:03:01.380 --> 00:03:05.320\na lot like Visual Studio and has a lot of\nthe same features and interface that makes\n\n63\n00:03:05.320 --> 00:03:08.990\nit easier for developers to jump in and to\nbe able to run that and interact with it.\n\n64\n00:03:08.990 --> 00:03:13.020\nNow unlike Visual Studio, it doesn't\ndo Visual Basic, it doesn't do C#.\n\n65\n00:03:13.020 --> 00:03:15.887\nIt is tuned to run SQL, and specifically,\n\n66\n00:03:15.887 --> 00:03:20.520\nTransact-SQL, and to interact\nwith those Microsoft SQL Servers.\n\n67\n00:03:20.520 --> 00:03:23.965\nSo it gives you a great full development\nenvironment to be able to work with\n\n68\n00:03:23.965 --> 00:03:25.199\nthe server and interact.\n\n69\n00:03:25.199 --> 00:03:27.870\nSo that's gonna be the number\none tool that we use.\n\n70\n00:03:27.870 --> 00:03:31.500\nIt's also got some added benefits that\nit can connect to more than one server.\n\n71\n00:03:31.500 --> 00:03:33.820\nSo if you've got 20 SQL Servers,\n\n72\n00:03:33.820 --> 00:03:36.030\nor 100, or\nwhatever you can connect to manage those.\n\n73\n00:03:36.030 --> 00:03:38.100\nAnd it'll even manage the ones\nyou have in the cloud.\n\n74\n00:03:38.100 --> 00:03:42.288\nSo if you've deployed Azure SQL, for\nexample, you can connect and manage those.\n\n75\n00:03:42.288 --> 00:03:44.503\nAnd even a mixture of the two.\nYou might have Azure SQL Servers and\n\n76\n00:03:44.503 --> 00:03:46.024\non-premise SQL Servers, and\n\n77\n00:03:46.024 --> 00:03:49.428\neven the ones that are running right\non your own desktop for testing.\n\n78\n00:03:49.428 --> 00:03:52.240\nAnd you can manage it all\nfrom one little environment.\n\n79\n00:03:52.240 --> 00:03:53.720\nSo that Management Studio\nis pretty powerful.\n\n80\n00:03:53.720 --> 00:03:56.680\n&gt;&gt; So Don, where can I get\nthe SQL Server Management Studio?\n\n81\n00:03:56.680 --> 00:03:59.760\n&gt;&gt; The easiest place to get it is\npackaged with the install, right?\n\n82\n00:03:59.760 --> 00:04:02.953\nSo if you're on the server and\nyou do the install of SQL Server,\n\n83\n00:04:02.953 --> 00:04:05.378\nit's going to install\nthe Management Studio.\n\n84\n00:04:05.378 --> 00:04:07.880\nBut, actually,\nthat's not always true, right?\n\n85\n00:04:07.880 --> 00:04:09.740\nWhat if I have a Core Services server?\n\n86\n00:04:09.740 --> 00:04:12.100\nIt's not gonna install\nthe management tools, right?\n\n87\n00:04:12.100 --> 00:04:13.207\nSo if you're gonna run this,\n\n88\n00:04:13.207 --> 00:04:16.400\nthe idea is that you're really gonna\nrun it from your own workstation.\n\n89\n00:04:16.400 --> 00:04:16.980\nI might have 100 servers.\n\n90\n00:04:16.980 --> 00:04:20.390\nNow I might not have the Management Studio\ninstalled on a single one of them.\n\n91\n00:04:20.390 --> 00:04:22.159\nI have it installed on my laptop,\non my desktop, and\n\n92\n00:04:22.159 --> 00:04:23.790\nthat's where I manage things from.\n\n93\n00:04:23.790 --> 00:04:27.909\nNow if I have a SQL Server DVD laying\naround, I can go and grab that and\n\n94\n00:04:27.909 --> 00:04:28.565\npop it in.\n\n95\n00:04:28.565 --> 00:04:30.320\nBut I know my laptop has the problem.\n\n96\n00:04:30.320 --> 00:04:31.527\n&gt;&gt; [LAUGH]\n&gt;&gt; Most people do,\n\n97\n00:04:31.527 --> 00:04:33.864\nI don't have a DVD drive anymore.\n\n98\n00:04:33.864 --> 00:04:36.547\n&gt;&gt; I was gonna say, you have a DVD drive?\n\n99\n00:04:36.547 --> 00:04:37.452\n&gt;&gt; [LAUGH] It's not 2010 anymore, right?\n\n100\n00:04:37.452 --> 00:04:39.290\nSo [LAUGH] we've moved beyond that.\n\n101\n00:04:39.290 --> 00:04:41.336\nSo now, we're usually gonna go and\ndownload it, right?\n\n102\n00:04:41.336 --> 00:04:44.976\nAnd I've even gotten to the point where\nI don't use the one that comes on the CD\n\n103\n00:04:44.976 --> 00:04:47.720\nanyway because it's obsolete\nby the time you install it.\n\n104\n00:04:47.720 --> 00:04:50.194\nSo I'm normally gonna go and download it.\n\n105\n00:04:50.194 --> 00:04:53.435\nAnd Microsoft does a great job of making\nthe SQL Server Management Studio available\n\n106\n00:04:53.435 --> 00:04:55.059\nfor download right off of their website.\n\n107\n00:04:55.059 --> 00:04:57.370\nSo we can always jump over and do it.\n\n108\n00:04:57.370 --> 00:04:59.840\nNow, if you're on a server,\nlet me show you my desktop here.\n\n109\n00:04:59.840 --> 00:05:03.290\nSo I've got a server\npulled up here that has\n\n110\n00:05:03.290 --> 00:05:07.740\nWindows Server 2016 with\nSQL Server 2016 installed on it.\n\n111\n00:05:07.740 --> 00:05:12.310\nAnd because it was a GUI install,\nit actually dropped the icon for\n\n112\n00:05:12.310 --> 00:05:15.380\nthe Microsoft SQL Server Management Studio\nright there on my desktop.\n\n113\n00:05:15.380 --> 00:05:17.770\nSo if you've installed it locally,\nyou've already got it.\n\n114\n00:05:17.770 --> 00:05:19.000\nYou're ready to go.\n\n115\n00:05:19.000 --> 00:05:22.640\nIt's the Microsoft SQL Server\nManagement Studio, and that's it.\n\n116\n00:05:22.640 --> 00:05:26.940\nBut if you don't have it, then what you'll\ndo is you'll go to Microsoft's website.\n\n117\n00:05:26.940 --> 00:05:29.866\nAnd here's the Microsoft site, and I'll\nput this link in with the show notes so\n\n118\n00:05:29.866 --> 00:05:31.184\nyou don't have to scramble for it.\n\n119\n00:05:31.184 --> 00:05:36.140\nBut Microsoft keeps this one link\nactive for every version of SQL.\n\n120\n00:05:36.140 --> 00:05:37.340\nCuz every time a new version comes out,\n\n121\n00:05:37.340 --> 00:05:40.160\nthey release a new version\nof the Management Studio.\n\n122\n00:05:40.160 --> 00:05:43.320\nThis show, for example,\nis based on SQL Server 2016.\n\n123\n00:05:43.320 --> 00:05:46.550\nBut the most current\none is SQL Server 2017,\n\n124\n00:05:46.550 --> 00:05:51.480\nwhich just came out not too long ago so\nwe don't have a show for that yet.\n\n125\n00:05:51.480 --> 00:05:54.480\nBut SQL Server 2016 is the one\nthat's being actively pushed for\n\n126\n00:05:54.480 --> 00:05:55.790\nproduction use right now.\n\n127\n00:05:55.790 --> 00:05:59.067\nBut if I come here to\nthe SQL Server Management Studio download,\n\n128\n00:05:59.067 --> 00:06:01.629\nI see where I can download\nthe Management Studio.\n\n129\n00:06:01.629 --> 00:06:06.160\nAnd it's offering for me to download\nSQL Server Management Studio 17.3, right?\n\n130\n00:06:06.160 --> 00:06:11.574\nNow, the neat part about the Management\nStudio is that it is backwards compatible,\n\n131\n00:06:11.574 --> 00:06:13.951\nright, at least to a certain range.\n\n132\n00:06:13.951 --> 00:06:17.962\nAnd it'll normally tell us that somewhere\nhere in the web page if I were to take\n\n133\n00:06:17.962 --> 00:06:22.096\nthe time and read it, it's just buried in\nhere somewhere, but I know this one in\n\n134\n00:06:22.096 --> 00:06:26.880\nparticular actually supports managing\nSQL Server 2008 all the way through 2017.\n\n135\n00:06:26.880 --> 00:06:32.078\nSo if I've got SQL Server 2012,\n2014, 2016, 2017,\n\n136\n00:06:32.078 --> 00:06:36.817\n2008, I can manage all of that\nwith this Management Studio.\n\n137\n00:06:36.817 --> 00:06:40.210\nSo you can always run a newer version\nof the Management Studio to control\n\n138\n00:06:40.210 --> 00:06:41.340\nan older server.\n\n139\n00:06:41.340 --> 00:06:42.920\nThe opposite is not true.\n\n140\n00:06:42.920 --> 00:06:45.960\nI can't take an older version\nof the Management Studio and\n\n141\n00:06:45.960 --> 00:06:48.680\ncontrol a newer version of SQL,\nit causes problems, right?\n\n142\n00:06:48.680 --> 00:06:52.456\nSo you always wanna make sure you at least\nhave the version that's compatible with\n\n143\n00:06:52.456 --> 00:06:53.460\nyour server.\n\n144\n00:06:53.460 --> 00:06:56.777\nNow, version numbers are a little\nbit tricky in the SQL world.\n\n145\n00:06:56.777 --> 00:07:03.690\nBecause SQL Server 2016, 2016 is the year\nthat it was released, not the version.\n\n146\n00:07:03.690 --> 00:07:06.291\nThe version for SQL Server 2016\nis actually version 13.0.16.,\n\n147\n00:07:06.291 --> 00:07:07.016\nsomething, right?\n\n148\n00:07:08.544 --> 00:07:10.836\n&gt;&gt; Good.\n\n149\n00:07:10.836 --> 00:07:11.981\n&gt;&gt; I know, it gets confusing.\n\n150\n00:07:11.981 --> 00:07:15.898\nSo when Microsoft gives these version\nnumbers here to the Management Studio,\n\n151\n00:07:15.898 --> 00:07:17.630\nthey actually abbreviated a bit.\n\n152\n00:07:17.630 --> 00:07:21.560\nThey're leaving off the 13.0 part and\njust making it 17.3.\n\n153\n00:07:21.560 --> 00:07:25.800\nSo that 17 tells me this is for\nSQL Server 2017, right?\n\n154\n00:07:26.880 --> 00:07:31.650\nNow, if you need it, they actually have\na link on here for previous releases.\n\n155\n00:07:31.650 --> 00:07:33.500\nYou can scroll down in the article and\nfind it.\n\n156\n00:07:33.500 --> 00:07:37.230\nOr over here on the right, there's\na little link that says Previous releases.\n\n157\n00:07:37.230 --> 00:07:40.467\nAnd you can jump down, and they've got\na link and download the older one.\n\n158\n00:07:40.467 --> 00:07:44.867\nSo if I really really just\ninsist on having the 2016 one,\n\n159\n00:07:44.867 --> 00:07:47.035\nI can come in here and find it.\n\n160\n00:07:47.035 --> 00:07:49.331\nAnd actually, again, over here on\nmy right, I can jump down here.\n\n161\n00:07:49.331 --> 00:07:54.421\nThe latest one for\nSQL Server 2016 is 16.5.3.\n\n162\n00:07:54.421 --> 00:07:57.631\nAnd so\nI can click that link to jump down to it.\n\n163\n00:07:57.631 --> 00:08:01.719\nAnd I can download that build, but again,\nI might as well get the 17 one unless I'm\n\n164\n00:08:01.719 --> 00:08:05.070\ntrying to manage something older\nthat maybe the new one doesn't do.\n\n165\n00:08:05.070 --> 00:08:07.950\nBut honestly, if you're running\nsomething earlier than SQL 2008,\n\n166\n00:08:07.950 --> 00:08:11.200\nyou've got problems than which version\nof Management Studio you're running.\n\n167\n00:08:11.200 --> 00:08:13.910\n&gt;&gt; And it seems like the way that\nit's set up, it actually is nicer.\n\n168\n00:08:13.910 --> 00:08:18.120\nBecause just downloading this one\nparticular tool is probably a lot\n\n169\n00:08:18.120 --> 00:08:22.250\neasier than getting the licensing and\nreconfiguring your SQL Servers.\n\n170\n00:08:22.250 --> 00:08:26.350\n&gt;&gt; Absolutely, and\nin this case the tool is technically, I'm\n\n171\n00:08:26.350 --> 00:08:30.660\ngonna use the word free, it's not really\nfree cuz there's a license agreement and\n\n172\n00:08:30.660 --> 00:08:31.900\nit's proprietary code and all that.\n\n173\n00:08:31.900 --> 00:08:34.430\nBut they don't charge you for\nit I guess is the point.\n\n174\n00:08:34.430 --> 00:08:36.060\nSo you can download this\nManagement Studio and\n\n175\n00:08:36.060 --> 00:08:39.000\nyou can install it on as many\ncomputers as you want, tons of them.\n\n176\n00:08:39.000 --> 00:08:42.950\nAnd they don't have to be\nWindows 10 Professional,\n\n177\n00:08:42.950 --> 00:08:46.150\nit can be Windows 7,\nthey can even be the Home Edition.\n\n178\n00:08:46.150 --> 00:08:48.250\nIt will install just fine on those.\n\n179\n00:08:48.250 --> 00:08:50.580\nThe servers are where\nthe license needs to be.\n\n180\n00:08:50.580 --> 00:08:52.840\nThat's where they control\nthe licensing on the server site.\n\n181\n00:08:52.840 --> 00:08:55.390\nThey don't care how many of these\nconnections you make to manage it.\n\n182\n00:08:55.390 --> 00:08:57.590\nSo really neat and easy to get that.\n\n183\n00:08:57.590 --> 00:08:59.935\nYou just download the tool\nto standard setup.\n\n184\n00:08:59.935 --> 00:09:02.290\nRight, you click next twelve times.\n\n185\n00:09:02.290 --> 00:09:03.221\n&gt;&gt; [LAUGH]\n&gt;&gt; Or something like that and\n\n186\n00:09:03.221 --> 00:09:03.983\nall of the sudden you're installed.\n\n187\n00:09:03.983 --> 00:09:07.804\nSo really straightforward but once you've\ngot it, now you've got the tool to be able\n\n188\n00:09:07.804 --> 00:09:10.684\nto reach out, connect to a server and\nstart to ease your grants.\n\n189\n00:09:13.127 --> 00:09:13.843\n&gt;&gt; All right so\n\n190\n00:09:13.843 --> 00:09:18.150\nif we take a look at issuing those\ncommands how do we go ahead and do that.\n\n191\n00:09:18.150 --> 00:09:22.160\n&gt;&gt; All right so the tool itself is\nactually pretty straightforward.\n\n192\n00:09:22.160 --> 00:09:25.350\nBut if it's the first time going into it,\nthings can be a little bit confusing.\n\n193\n00:09:25.350 --> 00:09:29.180\nSo let me show you here, I'm gonna\njump back to my other machine here.\n\n194\n00:09:29.180 --> 00:09:34.590\nAnd, I haven't run the management tool on\nthis system yet so I'm gonna launch it.\n\n195\n00:09:34.590 --> 00:09:36.560\nAnd the first time that you launch it,\n\n196\n00:09:36.560 --> 00:09:38.740\nit doesn't necessarily know\nwhat you want to connect to.\n\n197\n00:09:38.740 --> 00:09:42.430\nSo here's the SQL Server 2016\nManagement Studio launching and\n\n198\n00:09:42.430 --> 00:09:45.540\nas soon as the interface loads, and it\ntakes a little bit of time the first time\n\n199\n00:09:45.540 --> 00:09:49.350\nthat you launch it, it's gonna ask me,\nwho do I wanna connect to?\n\n200\n00:09:49.350 --> 00:09:52.110\nNow in the future,\nremember who I connected to last and\n\n201\n00:09:52.110 --> 00:09:53.050\nwe'll put it in there.\n\n202\n00:09:53.050 --> 00:09:55.160\nBut if this is the first\ntime I'm connected,\n\n203\n00:09:55.160 --> 00:09:58.170\nit's gonna do a couple of things\nthat may or may not be right, okay?\n\n204\n00:09:58.170 --> 00:10:00.520\nSo we need to look at these settings and\nfigure it out.\n\n205\n00:10:00.520 --> 00:10:02.830\nSo if we zoom in on that\njust a little bit here,\n\n206\n00:10:02.830 --> 00:10:06.200\nwe can see the very first thing is asking\nwhat kinda server do I wanna connect to.\n\n207\n00:10:06.200 --> 00:10:10.220\nWell if we're gonna be issuing SQL,\nor transact SQL commands,\n\n208\n00:10:10.220 --> 00:10:12.890\nthen I need to tell it that I'm\nconnecting to a database engine.\n\n209\n00:10:12.890 --> 00:10:13.780\nThat's what we normally want.\n\n210\n00:10:13.780 --> 00:10:17.100\nBut if you drop it down, you'll see where\nyou can connect to reporting services, or\n\n211\n00:10:17.100 --> 00:10:19.595\nintegration, analysis services.\n\n212\n00:10:19.595 --> 00:10:23.835\nThese are advanced services that are part\nof SQL, you may or may not have those,\n\n213\n00:10:23.835 --> 00:10:26.447\na lot of people don't have these features.\n\n214\n00:10:26.447 --> 00:10:28.195\nThe database engine is\nthe one we all have,\n\n215\n00:10:28.195 --> 00:10:31.785\nthat's the one that we're talking to the\ndatabases and we're getting information.\n\n216\n00:10:31.785 --> 00:10:34.547\nThe next thing it asks is which\nserver you wanna connect to.\n\n217\n00:10:34.547 --> 00:10:37.615\nNow it's gonna default to your computer,\nso\n\n218\n00:10:37.615 --> 00:10:40.270\nif this is my workstation,\nit will have my workstation name in there.\n\n219\n00:10:40.270 --> 00:10:42.820\nI might not be running SQL\non my own workstation.\n\n220\n00:10:42.820 --> 00:10:43.580\nI might be, right?\n\n221\n00:10:43.580 --> 00:10:45.610\nI'll usually install SQL Express or\nsomething so\n\n222\n00:10:45.610 --> 00:10:47.720\nI can run testing on my own laptop.\n\n223\n00:10:47.720 --> 00:10:53.230\nBut in this case, I'm on the server so it\nis right, but it may not be right for you.\n\n224\n00:10:53.230 --> 00:10:54.900\nYou can drop it down, and\n\n225\n00:10:54.900 --> 00:10:59.680\nit will try and find SQL Servers on\nthe network but that function of finding\n\n226\n00:10:59.680 --> 00:11:03.760\na SQL server on the network is actually\ndisabled by default, on the server side.\n\n227\n00:11:03.760 --> 00:11:06.260\nSo the server's don't advertise\nthemselves by default so\n\n228\n00:11:06.260 --> 00:11:07.930\nyou may not see the server\nyou wanna connect to.\n\n229\n00:11:07.930 --> 00:11:11.720\nIn which case you can either type the name\nor you can browse to try and find it.\n\n230\n00:11:11.720 --> 00:11:14.020\nBut again, it's just disabled by default.\n\n231\n00:11:14.020 --> 00:11:15.660\n&gt;&gt; So what would you say?\n\n232\n00:11:15.660 --> 00:11:18.490\nIs that an option that you\nwould recommend enabling?\n\n233\n00:11:18.490 --> 00:11:22.310\nBecause it seems almost like a security\nissue if you have a server saying, hi,\n\n234\n00:11:22.310 --> 00:11:23.020\nhere I am.\n\n235\n00:11:23.020 --> 00:11:25.060\n&gt;&gt; That's actually the reason\nto disable it, right?\n\n236\n00:11:25.060 --> 00:11:26.510\nSo it's advertising itself.\n\n237\n00:11:26.510 --> 00:11:29.750\nIf you have an authentication, then it\ndoesn't matter so much, right, because\n\n238\n00:11:29.750 --> 00:11:33.240\nsomebody found the SQL Server, they still\nhave to authenticate to get into it.\n\n239\n00:11:33.240 --> 00:11:34.550\n&gt;&gt; True.\n&gt;&gt; But if you've got\n\n240\n00:11:34.550 --> 00:11:37.220\nwhere the guest account\nhas full read access,\n\n241\n00:11:37.220 --> 00:11:40.420\nyou might want to ensure that only people\nwho are supposed to connect can do it.\n\n242\n00:11:40.420 --> 00:11:44.360\nNow this is not true secure,\nit's called security through obscurity.\n\n243\n00:11:44.360 --> 00:11:45.480\nHiding a SQL server.\n\n244\n00:11:45.480 --> 00:11:48.770\nSo it's not the most effective thing but\nit's spend on a nothing so\n\n245\n00:11:48.770 --> 00:11:50.010\na lot of people do it.\n\n246\n00:11:50.010 --> 00:11:52.730\nI've just gotten used to\ntyping in the server names.\n\n247\n00:11:52.730 --> 00:11:54.220\nBecause then I don't care\nif it's advertised or\n\n248\n00:11:54.220 --> 00:11:55.870\nnot I'll always be able to connect.\n\n249\n00:11:55.870 --> 00:11:58.480\nAnd it'll remember the ones that\nyou've connected to previously so\n\n250\n00:11:58.480 --> 00:12:02.220\nwhen you drop down you'll see ones that\nyou've typed in before even if they're not\n\n251\n00:12:02.220 --> 00:12:04.180\nadvertising on the network.\n\n252\n00:12:04.180 --> 00:12:05.900\nThen you got authentication, right?\n\n253\n00:12:05.900 --> 00:12:10.620\nWhoever set up your SQL server, created\na user account and a password, right?\n\n254\n00:12:10.620 --> 00:12:12.744\nNow hopefully they did\nWindows authentication.\n\n255\n00:12:12.744 --> 00:12:15.700\nIn that way, the user can get\nyour log in to a new workstation,\n\n256\n00:12:15.700 --> 00:12:17.530\nwill be able to log in to\nthe server no problem.\n\n257\n00:12:17.530 --> 00:12:20.860\nIf you're in an active director domain,\nthat works great.\n\n258\n00:12:20.860 --> 00:12:22.340\nBut, if you're a remote user or\n\n259\n00:12:22.340 --> 00:12:25.000\nyou don't have an active directory domain,\nthat doesn't work so well.\n\n260\n00:12:25.000 --> 00:12:28.340\nYou might need to use what's called\nSQL Integrated Authentication.\n\n261\n00:12:28.340 --> 00:12:32.830\nIf I drop down Windows, I can choose SQL\nServer Authentication and right in here,\n\n262\n00:12:32.830 --> 00:12:34.640\nI can specify a particular username and\n\n263\n00:12:34.640 --> 00:12:36.600\npassword to be able to\nconnect to that server.\n\n264\n00:12:36.600 --> 00:12:39.618\nYour database administrator will tell\nyou which one you're supposed to use.\n\n265\n00:12:39.618 --> 00:12:43.490\nAnd if you're providing your credentials\nyou can choose to remember the passwords\n\n266\n00:12:43.490 --> 00:12:46.230\nto always be there when you\nlaunches they type in every time.\n\n267\n00:12:46.230 --> 00:12:48.660\nIn my case,\nI'm doing Windows Authentication\n\n268\n00:12:48.660 --> 00:12:51.972\nwhich is really nice because I've\nalready logged into my workstation so\n\n269\n00:12:51.972 --> 00:12:53.530\nI don't have to provide a username and\npassword.\n\n270\n00:12:53.530 --> 00:12:54.830\nIt already knows it.\n\n271\n00:12:54.830 --> 00:12:59.410\nAnd when I hit connect, it's gonna reach\nright out and connect to that server.\n\n272\n00:12:59.410 --> 00:13:03.340\nAnd I know it worked if I see my little\nleft navigation tree, or it's called\n\n273\n00:13:03.340 --> 00:13:07.250\nthe object explorer, if I start to see\nthat populate with data I know at work.\n\n274\n00:13:07.250 --> 00:13:09.940\nIf I see it empty, I know it didn't.\n\n275\n00:13:09.940 --> 00:13:13.470\n&gt;&gt; Okay Don so would you mind\nbringing me up to speed here and\n\n276\n00:13:13.470 --> 00:13:17.090\njust help with a brief\ntour of this interface.\n\n277\n00:13:17.090 --> 00:13:19.640\n&gt;&gt; Yeah I mentioned earlier\nthis is it's based on\n\n278\n00:13:19.640 --> 00:13:21.090\nthe Microsoft Visual Studio, right?\n\n279\n00:13:21.090 --> 00:13:24.210\nAnd if you're a developer you\nprobably already know most of what\n\n280\n00:13:24.210 --> 00:13:24.800\nwe're looking at here.\n\n281\n00:13:24.800 --> 00:13:28.030\nBut if you're not a developer\nthis is kind of new right?\n\n282\n00:13:28.030 --> 00:13:31.200\nThe Microsoft Visual Studio\nis really designed\n\n283\n00:13:31.200 --> 00:13:34.260\nto allow you to be editing more\nthan one file at the same time, and\n\n284\n00:13:34.260 --> 00:13:37.450\nswitch between them, and\nsave code and retrieve code.\n\n285\n00:13:37.450 --> 00:13:39.300\nVersus the Microsoft Management Console,\n\n286\n00:13:39.300 --> 00:13:41.030\nwhat an assistant administrator\nwould be used to.\n\n287\n00:13:41.030 --> 00:13:43.880\n&gt;&gt; Sure.\n&gt;&gt; The MMC, you have a navigation panel on\n\n288\n00:13:43.880 --> 00:13:47.750\nthe left side and you have the area\nthat you'll be working on in the middle.\n\n289\n00:13:47.750 --> 00:13:51.180\nRight, but what we'll find\nhere is that it's different.\n\n290\n00:13:51.180 --> 00:13:54.670\nWe'll start to end up with tabs across\nthe top, the more things that we open.\n\n291\n00:13:54.670 --> 00:13:57.880\nWe'll have another panel over here on\nthe right that'll show the properties of\n\n292\n00:13:57.880 --> 00:13:59.390\nthe object that we're working with.\n\n293\n00:13:59.390 --> 00:14:02.650\nThe interface will change\nbased on what we're doing.\n\n294\n00:14:02.650 --> 00:14:05.940\nSo for example, on the left side here,\nI've got my Object Explorer, and\n\n295\n00:14:05.940 --> 00:14:07.730\nthe Object Explorer is how\nI can I can navigate and\n\n296\n00:14:07.730 --> 00:14:09.720\nsee what's inside of that server.\n\n297\n00:14:09.720 --> 00:14:10.570\nI see my server.\n\n298\n00:14:10.570 --> 00:14:13.000\nMine's called PLABSQL 01.\n\n299\n00:14:13.000 --> 00:14:17.121\nAnd in the side of it, I can see\nDatabases, Security, Replications,\n\n300\n00:14:17.121 --> 00:14:18.830\nthe SQL Server Agent.\n\n301\n00:14:18.830 --> 00:14:24.060\nSo I might expand out my Databases, and I\nmight come down here to my Adventure Work\n\n302\n00:14:24.060 --> 00:14:28.500\n2016CTP3 database, that's the one\nwe'll be using throughout this show.\n\n303\n00:14:28.500 --> 00:14:31.720\nThis database, just for\nyour own reference, is available for\n\n304\n00:14:31.720 --> 00:14:34.050\ndownload from Microsoft's website.\n\n305\n00:14:34.050 --> 00:14:37.940\nIt's a sample database they've had\nsince I've started working with SQL, so\n\n306\n00:14:37.940 --> 00:14:39.530\nat least back in SQL 6.5.\n\n307\n00:14:39.530 --> 00:14:40.150\nThey had.\n\n308\n00:14:40.150 --> 00:14:43.110\n&gt;&gt; No, I was just wondering, like did\nyou come up with this adventure works?\n\n309\n00:14:43.110 --> 00:14:44.510\n&gt;&gt; No, no, no. [LAUGH].\n&gt;&gt; Did I miss something in the first show?\n\n310\n00:14:44.510 --> 00:14:46.330\n&gt;&gt; That, that one's been around a long,\nlong time.\n\n311\n00:14:46.330 --> 00:14:49.755\nAnd they, they just got more\ncomplex with each version of SQL.\n\n312\n00:14:49.755 --> 00:14:51.270\nThey use to package it with the server.\n\n313\n00:14:51.270 --> 00:14:52.650\nSo, with was there by default and\n\n314\n00:14:52.650 --> 00:14:56.490\nnow you actually have to go and\ndownload it but get it if you wanna do\n\n315\n00:14:56.490 --> 00:14:59.680\nthe stuff on your own computer you\ncan actually download it and do it.\n\n316\n00:14:59.680 --> 00:15:02.410\nBut that database,\nif I browse inside of it got tables.\n\n317\n00:15:02.410 --> 00:15:03.810\nAnd if you browse inside the tables,\n\n318\n00:15:03.810 --> 00:15:06.970\nyou can start looking and\nfind like person address.\n\n319\n00:15:06.970 --> 00:15:10.820\nI'm navigating through that\ndatabase in a visual environment,\n\n320\n00:15:10.820 --> 00:15:12.680\nwhich is nice, it makes it\na little easier to find things,\n\n321\n00:15:12.680 --> 00:15:14.965\nespecially if you've never\nseen the database before.\n\n322\n00:15:14.965 --> 00:15:19.140\nWe can kinda get an idea of the hierarchy,\nand I can even take a table and if I right\n\n323\n00:15:19.140 --> 00:15:26.440\nclick on it, then I can come in and\nI can say, I want to select top 1000 rows.\n\n324\n00:15:26.440 --> 00:15:27.660\nShow me the first 2000 rows, or\n\n325\n00:15:27.660 --> 00:15:32.130\nlet me edit the top 200 rows or\nwhatever I can start to take a look at it.\n\n326\n00:15:32.130 --> 00:15:33.420\nI'll select the top 1000.\n\n327\n00:15:33.420 --> 00:15:36.460\nAnd when I do that,\nit's gonna reach into the database.\n\n328\n00:15:36.460 --> 00:15:41.160\nAnd it's gonna run a query, and\nit's going to show the table, right?\n\n329\n00:15:41.160 --> 00:15:42.900\nNow my interface looks a lot different.\n\n330\n00:15:42.900 --> 00:15:46.210\nThis is where we really start\nto differentiate between\n\n331\n00:15:46.210 --> 00:15:49.000\nthe Management Studio versus the MMC.\n\n332\n00:15:49.000 --> 00:15:51.680\nSo now, I got a lot more clever.\n\n333\n00:15:51.680 --> 00:15:53.647\nBut if you know what you're looking at,\nit's actually not so bad.\n\n334\n00:15:53.647 --> 00:15:54.304\n&gt;&gt; I know.\n\n335\n00:15:54.304 --> 00:15:57.445\nI'm just thinking Ronnie would\nprobably have a heart attack if I had\n\n336\n00:15:57.445 --> 00:15:58.613\nmultiple tabs.\n\n337\n00:15:58.613 --> 00:15:59.686\n[LAUGH] Even when I'm browsing,\nhe's always like.\n\n338\n00:15:59.686 --> 00:16:02.345\nCherokee, but-\n&gt;&gt; But, this is made for it.\n\n339\n00:16:02.345 --> 00:16:03.916\nYou're supposed to have multiple tabs.\n\n340\n00:16:03.916 --> 00:16:07.400\nWhat I have done is,\nI've effectively run a query.\n\n341\n00:16:07.400 --> 00:16:10.110\nWhat we're going to be doing through the\nwhole rest of this series, I've done here.\n\n342\n00:16:10.110 --> 00:16:11.662\nI didnt do it the real way,\nI didn't type it.\n\n343\n00:16:11.662 --> 00:16:13.670\nI cheated.\n\n344\n00:16:13.670 --> 00:16:14.890\nIt typed it for me.\n\n345\n00:16:14.890 --> 00:16:18.840\nSo that right click that I did,\nand SELECT TOP 1000 rows, it said,\n\n346\n00:16:18.840 --> 00:16:22.970\nwhat you actually meant was this,\nand it typed the query for me.\n\n347\n00:16:22.970 --> 00:16:27.880\nSELECT TOP (1000) and then all the various\ncolumn names from this database,\n\n348\n00:16:27.880 --> 00:16:30.450\nthis table, and then it output the data.\n\n349\n00:16:30.450 --> 00:16:31.280\nSo up here on the top,\n\n350\n00:16:31.280 --> 00:16:36.650\nI'm seeing the command, and down here, I'm\nseeing the table that came up as a result.\n\n351\n00:16:36.650 --> 00:16:40.320\nSo I've got the query and the result,\nand the neat part here is,\n\n352\n00:16:40.320 --> 00:16:42.170\nyou can tweak it an see it in real time.\n\n353\n00:16:42.170 --> 00:16:45.826\nI can come and I can take that 1,000 and\nI'm gonna drop it down to 5.\n\n354\n00:16:45.826 --> 00:16:50.531\nJust give me the top five, and\nwhen I run that, it's gonna execute, and\n\n355\n00:16:50.531 --> 00:16:53.020\ndown here, now I only have five rows.\n\n356\n00:16:53.020 --> 00:16:56.230\n&gt;&gt; What a handy little way to\nactually learn the syntax too,\n\n357\n00:16:56.230 --> 00:16:58.270\nif you're using this and\nthen comparing it.\n\n358\n00:16:58.270 --> 00:16:58.970\n&gt;&gt; Yeah, yeah.\n\n359\n00:16:58.970 --> 00:17:02.190\nIf you make a mistake,\nyour error will appear down here, and\n\n360\n00:17:02.190 --> 00:17:03.540\nthen you can come up here and\nyou can fix it.\n\n361\n00:17:03.540 --> 00:17:07.470\nSo you know, maybe I was coming in here\nand I forgot to put the number, and\n\n362\n00:17:07.470 --> 00:17:08.360\nI just did it like that.\n\n363\n00:17:08.360 --> 00:17:11.370\nNot a mistake I would make,\nI guess, but I get the error.\n\n364\n00:17:11.370 --> 00:17:13.214\nAnd it tells me, message 102.\n\n365\n00:17:13.214 --> 00:17:14.310\nThat means nothing to me.\n\n366\n00:17:14.310 --> 00:17:16.900\nLevel 15,\nthat means it caused the command to fail.\n\n367\n00:17:16.900 --> 00:17:18.188\nState 1, it failed.\n\n368\n00:17:18.188 --> 00:17:21.630\n[LAUGH] Line 2, so line 2 has the problem.\n\n369\n00:17:21.630 --> 00:17:25.560\nAnd then, incorrect syntax near,\nand it's a closed parentheses.\n\n370\n00:17:25.560 --> 00:17:27.880\nSo I can go up here and I can find line 2.\n\n371\n00:17:27.880 --> 00:17:29.258\nLine 2 is this SELECT TOP.\n\n372\n00:17:29.258 --> 00:17:31.670\nI can find the closed parentheses.\n\n373\n00:17:31.670 --> 00:17:32.800\nIt's a little hard to see, but\n\n374\n00:17:32.800 --> 00:17:36.820\ndo you see the little red squiggly\nthat's under that closed parentheses?\n\n375\n00:17:36.820 --> 00:17:37.470\n&gt;&gt; I do.\n\n376\n00:17:37.470 --> 00:17:40.970\n&gt;&gt; That's helping us find\nexactly where the error is.\n\n377\n00:17:40.970 --> 00:17:42.170\nNow I know where the error is.\n\n378\n00:17:42.170 --> 00:17:44.730\nAnd I can look at it and say,\nwell what did I do wrong here?\n\n379\n00:17:44.730 --> 00:17:46.870\nAnd let me correct, and you know what?\n\n380\n00:17:46.870 --> 00:17:47.630\nI didn't give it a value.\n\n381\n00:17:47.630 --> 00:17:49.280\nLet me give it a value.\n\n382\n00:17:49.280 --> 00:17:51.310\nAnd now the little red squiggly went away.\n\n383\n00:17:51.310 --> 00:17:55.320\nIt understands the syntax,\nit's tuned for Transact-SQL.\n\n384\n00:17:55.320 --> 00:17:57.530\nI mentioned that earlier,\nhere we see it in action.\n\n385\n00:17:57.530 --> 00:18:01.730\nSo it knows that's wrong, and it let's me\nknow, and kinda helps me to correct it,\n\n386\n00:18:01.730 --> 00:18:04.370\nand then I can go and run and\nnow it executes properly.\n\n387\n00:18:04.370 --> 00:18:09.090\nAnd I can quickly recycle code, rerun it\nas I need it to get that up and going.\n\n388\n00:18:09.090 --> 00:18:12.650\nSo, it actually works really,\nreally neat like that.\n\n389\n00:18:12.650 --> 00:18:17.020\nAll along, on the right side here,\nI've got my connection parameters.\n\n390\n00:18:17.020 --> 00:18:19.950\nAnd it's showing me information about\nthe server that I'm connected to.\n\n391\n00:18:19.950 --> 00:18:21.700\nBecause there's various\nsession variables and\n\n392\n00:18:21.700 --> 00:18:23.680\nthings that might change\nthe results I get.\n\n393\n00:18:23.680 --> 00:18:26.520\nDepending on who I'm logged in as,\nI might get one set of\n\n394\n00:18:26.520 --> 00:18:28.910\nresults versus a different set\nof results for somebody else.\n\n395\n00:18:28.910 --> 00:18:30.970\nSo I can see, who am I logged in as.\n\n396\n00:18:30.970 --> 00:18:33.150\nWhat server version am I running,\nand so on.\n\n397\n00:18:33.150 --> 00:18:36.090\nI see all that information right\nover here on the right side,\n\n398\n00:18:36.090 --> 00:18:37.660\ninside of our connection properties.\n\n399\n00:18:37.660 --> 00:18:41.400\nAnd this can change sometimes, depending\non what you're viewing the properties for.\n\n400\n00:18:41.400 --> 00:18:44.208\nSo you'll see this updated,\nit's very dynamic.\n\n401\n00:18:44.208 --> 00:18:49.170\nAnd then across the top,\nwe have a whole collection of buttons,\n\n402\n00:18:49.170 --> 00:18:52.606\nand I'm gonna save a lot of these buttons,\ncuz they deal with things that we haven't\n\n403\n00:18:52.606 --> 00:18:55.820\nlearned about yet, that we're gonna learn\nabout in the SQL Administration shows.\n\n404\n00:18:55.820 --> 00:18:58.670\nBut a couple that are really\nimportant that I wanna highlight\n\n405\n00:18:58.670 --> 00:19:01.210\nare all found right here\nin this bottom row.\n\n406\n00:19:02.350 --> 00:19:04.600\nFirst off,\nyou'll see this little button right here.\n\n407\n00:19:04.600 --> 00:19:06.350\nThis says, change connection.\n\n408\n00:19:06.350 --> 00:19:09.940\nI can change to another server if I\nwanna connect to a different server.\n\n409\n00:19:09.940 --> 00:19:12.370\nOr if I wanna connect to more\nthan one server right down here,\n\n410\n00:19:12.370 --> 00:19:15.720\nI can use this connect button, and\nI can specify other servers to connect to,\n\n411\n00:19:15.720 --> 00:19:17.380\nand I can be connected to more at once.\n\n412\n00:19:17.380 --> 00:19:20.620\n&gt;&gt; So it maintains that session,\nand you're not terminating that and\n\n413\n00:19:20.620 --> 00:19:22.250\nthen moving on to the next server,\nessentially?\n\n414\n00:19:22.250 --> 00:19:22.880\n&gt;&gt; Right.\n\n415\n00:19:22.880 --> 00:19:25.700\n&gt;&gt; Well, technically, with SQL,\nyou open a connection,\n\n416\n00:19:25.700 --> 00:19:27.280\nand then you stop talking to the server.\n\n417\n00:19:27.280 --> 00:19:30.600\nYou only talk to it when you're running\nqueries, but you hold your authentication\n\n418\n00:19:30.600 --> 00:19:34.400\nopen so it's ready to jump right back\nin at a moment's notice, easy enough.\n\n419\n00:19:34.400 --> 00:19:36.830\nSometimes you can make a mistake and\nleave a session running, and\n\n420\n00:19:36.830 --> 00:19:39.770\nit'll stay running until\nthe server decides to close it.\n\n421\n00:19:39.770 --> 00:19:42.130\nNext, I see the database\nthat I'm working on.\n\n422\n00:19:42.130 --> 00:19:45.900\nNow when I ran this command over here, how\ndid it know which database to run it on?\n\n423\n00:19:45.900 --> 00:19:49.880\nWell, this drop down box right here told\nit to run against Adventure Works 2016.\n\n424\n00:19:49.880 --> 00:19:52.680\nIf I drop that down,\nI'll see the other databases and\n\n425\n00:19:52.680 --> 00:19:55.580\nI could choose to run against\nfrom one of them instead.\n\n426\n00:19:55.580 --> 00:19:56.440\nThen we got Execute.\n\n427\n00:19:56.440 --> 00:19:59.500\nThis is the button that\ntells it to run the query.\n\n428\n00:19:59.500 --> 00:20:02.540\nNow, I never hit this button,\nbecause I'm so used to hitting F5.\n\n429\n00:20:02.540 --> 00:20:04.150\nAnd notice, when I float my mouse over,\n\n430\n00:20:04.150 --> 00:20:06.095\nthere was that tooltip\nthat appeared briefly?\n\n431\n00:20:06.095 --> 00:20:08.000\nAnd it says, Execute, F5.\n\n432\n00:20:08.000 --> 00:20:10.680\nI'll use the F5 and it'll run.\n\n433\n00:20:10.680 --> 00:20:12.570\nAnd that's kind of a habit\nthat I've gotten into but\n\n434\n00:20:12.570 --> 00:20:14.500\nthat Execute button does it.\n\n435\n00:20:14.500 --> 00:20:17.540\nWe've got the Debug button,\nwhich will step through the query,\n\n436\n00:20:17.540 --> 00:20:20.750\nrunning one piece at a time to help\nyou find where an error is, or\n\n437\n00:20:20.750 --> 00:20:23.500\nto help tweak and\ntrouble shoot to solve a bad query.\n\n438\n00:20:23.500 --> 00:20:25.790\nYou've got a Stop button.\n\n439\n00:20:25.790 --> 00:20:28.424\nIf you ever run a bad query that holds\na session open on the server, and\n\n440\n00:20:28.424 --> 00:20:30.220\nit just keeps running and running.\n\n441\n00:20:30.220 --> 00:20:31.440\nWay down at the bottom,\n\n442\n00:20:31.440 --> 00:20:34.577\nyou've got this little timer that shows\nhow long your query has been running.\n\n443\n00:20:34.577 --> 00:20:37.050\nAnd if that time just keeps going and\ngoing and going,\n\n444\n00:20:37.050 --> 00:20:41.080\nyou might need to stop the query, and so\nyou would use this Stop button to do that.\n\n445\n00:20:41.080 --> 00:20:43.620\nIt only lights up while\nyour query is running.\n\n446\n00:20:43.620 --> 00:20:46.910\nNext to it though, is my favorite button,\nand it's the Check button.\n\n447\n00:20:46.910 --> 00:20:50.400\nIt's Parse, and\nit's got a shortcut of control F5.\n\n448\n00:20:50.400 --> 00:20:52.810\nIf I'm typing a query,\n\n449\n00:20:52.810 --> 00:20:56.600\nI don't necessarily wanna throw it at the\nserver to find out if it's good or not.\n\n450\n00:20:56.600 --> 00:20:59.380\nSo real quick,\nI can just take Control F5 and\n\n451\n00:20:59.380 --> 00:21:04.300\nit will run a check to make\nsure the query is okay.\n\n452\n00:21:04.300 --> 00:21:06.990\nAnd see down here,\nit says command completed successfully?\n\n453\n00:21:06.990 --> 00:21:09.570\nIt didn't talk to the server at all.\n\n454\n00:21:09.570 --> 00:21:11.260\nIt did it all right here\nin the management studio.\n\n455\n00:21:11.260 --> 00:21:14.080\nSo let me check your code, and\nmake sure you don't have any errors.\n\n456\n00:21:14.080 --> 00:21:15.690\nAnd if you don't, then you're good to go.\n\n457\n00:21:15.690 --> 00:21:18.880\nIf I were to have injected\nan error like this, and\n\n458\n00:21:18.880 --> 00:21:22.530\ndo a Ctrl F5, it's gonna run,\nand it finds the error.\n\n459\n00:21:22.530 --> 00:21:24.730\nBut the important part is\nthat it found it here.\n\n460\n00:21:24.730 --> 00:21:26.210\nIt didn't send it to the server.\n\n461\n00:21:26.210 --> 00:21:28.420\nThe server wasn't involved in it.\n\n462\n00:21:28.420 --> 00:21:32.240\n&gt;&gt; So, Don, someone not having\na development background, but more of\n\n463\n00:21:32.240 --> 00:21:36.980\nan administrative feel, I'm getting a lot\nof similarities that I'm noticing between\n\n464\n00:21:36.980 --> 00:21:41.500\nthis interface and PowerShell for\nthe Integrated Scripting Environment.\n\n465\n00:21:41.500 --> 00:21:43.680\n&gt;&gt; Yeah the PowerShell ISE\nis very similar,\n\n466\n00:21:43.680 --> 00:21:45.910\ncuz it's based off of\nVisual Studio as well.\n\n467\n00:21:45.910 --> 00:21:47.670\nSo two completely different products, but\n\n468\n00:21:47.670 --> 00:21:49.520\nMicrosoft creates this\nconsistent environment.\n\n469\n00:21:49.520 --> 00:21:50.170\nAnd that's really nice,\n\n470\n00:21:50.170 --> 00:21:53.010\ncuz if you have experience in one of them,\nit helps out here.\n\n471\n00:21:53.010 --> 00:21:55.200\nIt's not like learning\nsomething all new from scratch.\n\n472\n00:21:55.200 --> 00:21:56.840\nYou can jump right in.\n\n473\n00:21:57.940 --> 00:21:59.850\n&gt;&gt; Alright, so how can we get to work?\n\n474\n00:21:59.850 --> 00:22:02.185\nAre we actually going to go ahead and\nstart running it?\n\n475\n00:22:02.185 --> 00:22:03.775\n&gt;&gt; Yeah, so I kind of cheated here.\n\n476\n00:22:03.775 --> 00:22:05.318\n&gt;&gt; [LAUGH]\n&gt;&gt; When I wanted to run a query,\n\n477\n00:22:05.318 --> 00:22:07.610\nI right clicked on a table and\nselected top 1000 rows.\n\n478\n00:22:07.610 --> 00:22:12.300\nBut what I would normally do,\nso let's say it's brand new.\n\n479\n00:22:12.300 --> 00:22:16.160\nI'm coming in here and\nI see this other environment.\n\n480\n00:22:16.160 --> 00:22:20.060\nI've got my Objects Explorer on the left,\nand this big empty space here.\n\n481\n00:22:20.060 --> 00:22:22.320\nWhat we're normally gonna\ndo is start a new query.\n\n482\n00:22:22.320 --> 00:22:25.220\nAnd there's a button, I guess I\nskipped over it a moment ago, but\n\n483\n00:22:25.220 --> 00:22:26.010\nthis guy right here.\n\n484\n00:22:26.010 --> 00:22:27.800\nNew, I didn't skip over it.\n\n485\n00:22:27.800 --> 00:22:29.092\nIt gets replaced with Executed-\n\n486\n00:22:29.092 --> 00:22:29.592\n&gt;&gt; Executed-\n&gt;&gt; In\n\n487\n00:22:29.592 --> 00:22:30.280\na lot of-\n&gt;&gt; Okay.\n\n488\n00:22:30.280 --> 00:22:31.470\n&gt;&gt; Yup.\nSo anyway,\n\n489\n00:22:31.470 --> 00:22:33.090\nwe go to New Query to launch a new one.\n\n490\n00:22:33.090 --> 00:22:35.395\nThis is another button that I'm not\nreally in the habit of hitting,\n\n491\n00:22:35.395 --> 00:22:36.620\ncuz I always hit Ctrl + N.\n\n492\n00:22:36.620 --> 00:22:40.573\nAnd if you float over it, you get that\nright there, that's the little shortcut,\n\n493\n00:22:40.573 --> 00:22:42.300\nCtrl + N for New Query.\n\n494\n00:22:42.300 --> 00:22:46.680\nAnd when you launch a query like this,\nnow your window updates,\n\n495\n00:22:46.680 --> 00:22:48.110\nand you've got a query space.\n\n496\n00:22:48.110 --> 00:22:50.060\nAnd if you're really comfortable\nwith writing queries,\n\n497\n00:22:50.060 --> 00:22:53.330\nyou just start writing them and\noff you go.\n\n498\n00:22:53.330 --> 00:22:57.992\nOne thing that I do recommend, though,\nis that the text is a little small, right?\n\n499\n00:22:57.992 --> 00:23:00.270\n&gt;&gt; [LAUGH]\n&gt;&gt; So If I wanna come in and say,\n\n500\n00:23:00.270 --> 00:23:05.250\nselect star from person dot, whoops, from-\n&gt;&gt; Yeah, I definitely can't see that.\n\n501\n00:23:05.250 --> 00:23:06.420\n&gt;&gt; Person dot person.\n\n502\n00:23:06.420 --> 00:23:07.381\nYeah, and it looks small on your TV.\n\n503\n00:23:07.381 --> 00:23:08.156\nIt's small on my laptop, too.\n\n504\n00:23:08.156 --> 00:23:11.170\n&gt;&gt; [LAUGH]\n&gt;&gt; I can barely read that.\n\n505\n00:23:11.170 --> 00:23:14.480\nSo what I usually do is go up to tools and\noptions.\n\n506\n00:23:15.670 --> 00:23:19.650\nAnd in the options screen you'll see,\nlet's see, buried in here,\n\n507\n00:23:19.650 --> 00:23:20.760\nFonts and Colors.\n\n508\n00:23:20.760 --> 00:23:22.670\nI'm gonna zoom in cuz I'm having\na hard time reading that too.\n\n509\n00:23:22.670 --> 00:23:24.290\nYou'll find Fonts and Colors.\n\n510\n00:23:24.290 --> 00:23:26.230\nAnd I often times bump that font size up.\n\n511\n00:23:26.230 --> 00:23:30.230\nIt's 10 pitch font, and on modern\nmonitors that's really darn small.\n\n512\n00:23:30.230 --> 00:23:32.810\nSo, I usually bump it to like 16 or 18,\n\n513\n00:23:32.810 --> 00:23:35.770\nget a little bit bigger to\nmake it easier to read.\n\n514\n00:23:35.770 --> 00:23:39.580\nAnd you know, for this show,\nwe'll go 18 so it's a little extra big.\n\n515\n00:23:39.580 --> 00:23:44.183\nAnd now that's done, what you'll find is\nthat's a heck of a lot easier to read.\n\n516\n00:23:44.183 --> 00:23:47.390\nNow the only challenge here is,\nit only changed the font size for\n\n517\n00:23:47.390 --> 00:23:48.320\nthe query window.\n\n518\n00:23:48.320 --> 00:23:51.000\nNotice how my object\nexplorer is still small.\n\n519\n00:23:51.000 --> 00:23:54.415\nI kind of like that, because you're not\nconstantly using the object explorer, and\n\n520\n00:23:54.415 --> 00:23:55.676\nyou can fit more on the screen.\n\n521\n00:23:55.676 --> 00:23:58.124\nBut it does create a little problem,\nbecause, like if I run this query.\n\n522\n00:23:58.124 --> 00:24:00.487\nThe results are all in a small font.\n\n523\n00:24:00.487 --> 00:24:03.036\nBut it does help at least\nas far as writing a query.\n\n524\n00:24:03.036 --> 00:24:04.996\nThat's one thing that I like to change.\n\n525\n00:24:04.996 --> 00:24:07.249\nBut now I can get in here,\nI can write my query, I can run it,\n\n526\n00:24:07.249 --> 00:24:08.640\nperform my executions.\n\n527\n00:24:08.640 --> 00:24:11.755\nDo all the various things that I\nneed right here from inside of\n\n528\n00:24:11.755 --> 00:24:13.070\na new query window.\n\n529\n00:24:13.070 --> 00:24:16.900\n&gt;&gt; All right, Don, so if we wanted to\nperform something a little more complex,\n\n530\n00:24:18.050 --> 00:24:19.950\nlet's say, how would I approach that?\n\n531\n00:24:19.950 --> 00:24:21.200\nCan I run multiple commands?\n\n532\n00:24:21.200 --> 00:24:23.600\nDo I have to configure a script,\nor what would I do?\n\n533\n00:24:23.600 --> 00:24:26.160\n&gt;&gt; Sure, so\nif you wanna run multiple commands,\n\n534\n00:24:26.160 --> 00:24:29.160\nright, you can do them all right here\nin the same query window, right?\n\n535\n00:24:29.160 --> 00:24:31.150\nIt's gonna run them one after the other.\n\n536\n00:24:31.150 --> 00:24:32.956\nNow sometimes, I don't want that, right?\n\n537\n00:24:32.956 --> 00:24:34.840\nMaybe I wanna query from\ntwo different tables.\n\n538\n00:24:34.840 --> 00:24:39.171\nSo if I come in here and I say,\nSELECT * FROM Person.Person and\n\n539\n00:24:39.171 --> 00:24:40.989\nthen I do a SELECT * FROM.\n\n540\n00:24:40.989 --> 00:24:45.559\nAnd we're gonna learn these queries later,\nso don't worry about that right now, but\n\n541\n00:24:45.559 --> 00:24:47.660\nI'll do HumanResources.Employee.\n\n542\n00:24:47.660 --> 00:24:51.400\nSo I'm gonna query from these two\ntables and pull the data, right?\n\n543\n00:24:51.400 --> 00:24:54.066\nWhen I run that,\nit's gonna run the first one, and\n\n544\n00:24:54.066 --> 00:24:56.001\nthen it's gonna run the second one.\n\n545\n00:24:56.001 --> 00:24:59.061\nAnd watch what happens to my\nresults window down here.\n\n546\n00:24:59.061 --> 00:25:01.180\nIn fact, let me resize my results\nwindow just a little bit here so\n\n547\n00:25:01.180 --> 00:25:02.209\nwe can fit it on the screen.\n\n548\n00:25:02.209 --> 00:25:05.476\nMy goodness, if I can get the mouse,\ncome on mouse, you can do it.\n\n549\n00:25:05.476 --> 00:25:07.614\n&gt;&gt; It's like a challenge.\n\n550\n00:25:07.614 --> 00:25:08.515\n[LAUGH]\n&gt;&gt; It really is,\n\n551\n00:25:08.515 --> 00:25:10.536\nit's now like getting your mouse\nright on that little border.\n\n552\n00:25:10.536 --> 00:25:12.548\nAll right, forget it,\nI'll leave it the same size.\n\n553\n00:25:12.548 --> 00:25:14.504\n&gt;&gt; [LAUGH]\n&gt;&gt; [LAUGH] But when I run it,\n\n554\n00:25:14.504 --> 00:25:18.248\nwhat you'll see happen, and\nit happens very briefly, and so\n\n555\n00:25:18.248 --> 00:25:23.370\nit's hard to see, is that I've got\nthe results for the first query here.\n\n556\n00:25:23.370 --> 00:25:28.979\nAnd then if I scroll down, I've got the\nresults for the second query beneath it.\n\n557\n00:25:28.979 --> 00:25:31.465\nSo it's actually stacked the results.\n\n558\n00:25:31.465 --> 00:25:33.955\nSo I've got one table here and\none table here.\n\n559\n00:25:33.955 --> 00:25:35.751\nAnd that doesn't always make sense.\n\n560\n00:25:35.751 --> 00:25:37.305\nIt's definitely hard to read.\n\n561\n00:25:37.305 --> 00:25:39.796\nAnd so that's not normally how I'll do it,\nunless that's my intent,\n\n562\n00:25:39.796 --> 00:25:41.760\nunless I'm intending it to\ncome up separate like that.\n\n563\n00:25:41.760 --> 00:25:45.195\nSo what I'll normally do is\ntake one of these, right?\n\n564\n00:25:45.195 --> 00:25:50.415\nAnd instead of running them\nin the same query window,\n\n565\n00:25:50.415 --> 00:25:53.789\nI'll run one in one query window.\n\n566\n00:25:53.789 --> 00:25:58.790\nAnd then if you just hit New Query or\nCtrl+N, I can get a second window.\n\n567\n00:25:58.790 --> 00:26:02.060\nAnd I can paste in that other query,\nand I can run it here.\n\n568\n00:26:02.060 --> 00:26:04.360\nAnd see how I've got tabs up top?\n\n569\n00:26:04.360 --> 00:26:08.994\nAnd so I can use the tabs to move back and\nforth between the results I'm now running.\n\n570\n00:26:08.994 --> 00:26:10.300\nIt's just like tabs in a web browser.\n\n571\n00:26:10.300 --> 00:26:12.050\nYou can open a bunch of tabs.\n\n572\n00:26:12.050 --> 00:26:14.970\nBut where this gets a little bit\ndifferent is we can get really advanced.\n\n573\n00:26:14.970 --> 00:26:16.950\nWe can save these queries, right?\n\n574\n00:26:16.950 --> 00:26:20.190\nMaybe I'll run this query every Monday.\n\n575\n00:26:20.190 --> 00:26:22.750\nAll right, well,\nI don't want to rewrite it every Monday.\n\n576\n00:26:22.750 --> 00:26:24.910\nSo I could save it and then open it again.\n\n577\n00:26:24.910 --> 00:26:26.584\nThese are just text files, right?\n\n578\n00:26:26.584 --> 00:26:28.650\nThe queries are just straight up text.\n\n579\n00:26:28.650 --> 00:26:29.870\nAnd if we save them,\n\n580\n00:26:29.870 --> 00:26:34.480\nif you go to File &gt; Save, see how\nI've got, let's zoom in a bit here.\n\n581\n00:26:34.480 --> 00:26:38.590\nIf I go to File &gt; Save,\nyou've got or you can save.\n\n582\n00:26:38.590 --> 00:26:43.910\nThe file is SQLQuery3.sql,\nnot the most fancy of names.\n\n583\n00:26:43.910 --> 00:26:47.729\nBut I can save it as that or\nI can save it as another format.\n\n584\n00:26:47.729 --> 00:26:50.395\nAnd this default, this .sql,\nit's just a text file.\n\n585\n00:26:50.395 --> 00:26:54.615\nYou can edit it in Notepad or anything,\nand then you just bring it in here.\n\n586\n00:26:54.615 --> 00:26:59.345\nAnd we can open queries that we've saved\nby coming in here and choosing File &gt;\n\n587\n00:26:59.345 --> 00:27:03.420\nOpen &gt; File, and then navigating\nto find that file and bring it up.\n\n588\n00:27:03.420 --> 00:27:05.520\nIf you have Visual Studio for teams, or\n\n589\n00:27:05.520 --> 00:27:08.420\nTeam edition, you can actually create\nrepositories where you store that.\n\n590\n00:27:08.420 --> 00:27:10.331\nYou can do it on your own machine,\ntoo, but\n\n591\n00:27:10.331 --> 00:27:13.110\nit's normally just a holder\n[LAUGH] where you put these files.\n\n592\n00:27:13.110 --> 00:27:16.637\n&gt;&gt; And would we potentially automate this\nif we knew we had to run this particular\n\n593\n00:27:16.637 --> 00:27:18.039\nquery everyday or-\n&gt;&gt; Yeah,\n\n594\n00:27:18.039 --> 00:27:20.770\nif we go beyond the scope of this course.\n\n595\n00:27:20.770 --> 00:27:23.280\nBut if I normally run it every Monday,\n\n596\n00:27:23.280 --> 00:27:25.365\nthere's actually a command-line\ninterface for SQL.\n\n597\n00:27:25.365 --> 00:27:29.009\nAnd we can just tell it, hey, every\nMonday at 8 AM, use the command-line,\n\n598\n00:27:29.009 --> 00:27:32.110\nrun this SQL file that I feed into you,\nand it'll run it and do it.\n\n599\n00:27:32.110 --> 00:27:36.473\nSo we can use the visual interface here to\ncreate the query, save it as a text file,\n\n600\n00:27:36.473 --> 00:27:40.225\nand then we can use the command-line\nto execute it on a routine basis.\n\n601\n00:27:40.225 --> 00:27:43.340\nSo it's nice to have an easier\ninterface in developing.\n\n602\n00:27:43.340 --> 00:27:47.185\n&gt;&gt; Yes, and talking about that easier\ninterface, I know we're getting close on\n\n603\n00:27:47.185 --> 00:27:50.853\ntime, but Don, PowerShell does offer\na lot of tools in ways that can help,\n\n604\n00:27:50.853 --> 00:27:52.561\nlike plug and chug for scripting.\n\n605\n00:27:52.561 --> 00:27:54.580\n&gt;&gt; [LAUGH]\n&gt;&gt; Is there something similar to that\n\n606\n00:27:54.580 --> 00:27:56.290\nhere within this management console?\n\n607\n00:27:56.290 --> 00:28:00.020\n&gt;&gt; Absolutely, so I already showed you one\nof them, which was a syntax correction,\n\n608\n00:28:00.020 --> 00:28:04.220\nright, that if I make mistakes in here,\nit helps me find them, and\n\n609\n00:28:04.220 --> 00:28:06.450\nhelps me correct them and\nget that cleared.\n\n610\n00:28:06.450 --> 00:28:07.480\nSo that syntax checking,\n\n611\n00:28:07.480 --> 00:28:11.620\nthat little parse check mark up top or\nCtrl+F5 is really handy.\n\n612\n00:28:11.620 --> 00:28:14.075\nAnd sometimes it'll even\ndo code suggestions.\n\n613\n00:28:14.075 --> 00:28:18.630\nThere's a feature that the Microsoft,\nthey patented, it's called IntelliSense.\n\n614\n00:28:18.630 --> 00:28:20.599\nIntelliSense looks at what you're typing.\n\n615\n00:28:20.599 --> 00:28:23.348\nAnd it starts to give you suggestions,\nright?\n\n616\n00:28:23.348 --> 00:28:26.590\nSo when I'm typing that SELECT command,\nwell,\n\n617\n00:28:26.590 --> 00:28:28.250\nthere's a lot of different things\nthat might start with SEL.\n\n618\n00:28:28.250 --> 00:28:31.313\nIt doesn't necessarily know what\nI'm doing, but it definitely knows\n\n619\n00:28:31.313 --> 00:28:34.030\nwhat I'm doing is wrong right now,\nso I get the red underline.\n\n620\n00:28:34.030 --> 00:28:37.630\nBut when I type it out,\nsee how it turned blue, right?\n\n621\n00:28:37.630 --> 00:28:39.479\nIt recognized that and\nsays, wait a minute,\n\n622\n00:28:39.479 --> 00:28:41.241\nyou're not just typing some random word.\n\n623\n00:28:41.241 --> 00:28:44.010\nThat's an actual command that\nyou're giving me, right?\n\n624\n00:28:44.010 --> 00:28:47.680\nAnd so it knows to do that and-\n&gt;&gt; I noticed you didn't tap through there,\n\n625\n00:28:47.680 --> 00:28:49.020\nis that an option?\n\n626\n00:28:49.020 --> 00:28:51.190\n&gt;&gt; Not on a command like that.\n\n627\n00:28:51.190 --> 00:28:52.630\nIt is on other things, though.\n\n628\n00:28:52.630 --> 00:28:56.140\nSo, for example, I wanna select\nsome information from a table.\n\n629\n00:28:56.140 --> 00:28:57.614\nI wanna select FirstName and LastName.\n\n630\n00:28:57.614 --> 00:29:01.600\nWell, it doesn't know what\ntable I'm working on right now.\n\n631\n00:29:01.600 --> 00:29:04.206\nSo it's giving me suggestions and\nsuggestions are all wrong, right,\n\n632\n00:29:04.206 --> 00:29:05.779\ncuz it doesn't know what I'm working on.\n\n633\n00:29:05.779 --> 00:29:08.360\nBut when it does know, it really is handy.\n\n634\n00:29:08.360 --> 00:29:10.470\nSo, for example,\nif I say I wanna select everything.\n\n635\n00:29:10.470 --> 00:29:13.450\nI'll do a star, and I'll say FROM.\n\n636\n00:29:13.450 --> 00:29:15.570\nNow it knows that I'm\nabout to pick a table.\n\n637\n00:29:15.570 --> 00:29:18.430\nSo it knows that whatever I'm\nabout to type is a table and\n\n638\n00:29:18.430 --> 00:29:19.890\nit can give me suggestions.\n\n639\n00:29:19.890 --> 00:29:21.990\nI want the Person.Person table.\n\n640\n00:29:21.990 --> 00:29:26.356\nSo I'll type Pe and see how it's\nalready suggesting Person right there?\n\n641\n00:29:26.356 --> 00:29:28.380\nAnd it's already highlighted.\n\n642\n00:29:28.380 --> 00:29:29.853\nIt knows what I'm looking for.\n\n643\n00:29:29.853 --> 00:29:32.790\nI can hit Tab, and it finishes it out.\n\n644\n00:29:32.790 --> 00:29:36.150\nNow my table is actually called\nPerson.Person, so I could type a dot.\n\n645\n00:29:36.150 --> 00:29:38.406\nAnd now it shows me all the sub-entries.\n\n646\n00:29:38.406 --> 00:29:42.740\nAnd if I do another P,\nit moves it down to Person.Password.\n\n647\n00:29:42.740 --> 00:29:44.420\nThat's not what I want,\nI want Person.Person.\n\n648\n00:29:44.420 --> 00:29:48.412\nSo if I type Pe, now it's got it,\nI can hit Tab again, right?\n\n649\n00:29:48.412 --> 00:29:51.346\nAnd now that it knows what\ntable I'm working on,\n\n650\n00:29:51.346 --> 00:29:55.332\nif I go back to this value here and\nI replace it, I want FirstName.\n\n651\n00:29:55.332 --> 00:30:00.060\nI can type Fir, and\nit'll start to look in that table.\n\n652\n00:30:00.060 --> 00:30:01.660\nAnd see how it found FirstName?\n\n653\n00:30:01.660 --> 00:30:03.950\nIt couldn't find that earlier cuz\nit didn't know where to look.\n\n654\n00:30:03.950 --> 00:30:05.200\nNow it knows where to look.\n\n655\n00:30:05.200 --> 00:30:09.640\nIntelliSense understands where\nyou're at in the command.\n\n656\n00:30:09.640 --> 00:30:12.405\nIt changes based on what you've done.\n\n657\n00:30:12.405 --> 00:30:14.889\nAnd it senses intelligently,\nI guess where the name came from.\n\n658\n00:30:14.889 --> 00:30:18.027\n&gt;&gt; [LAUGH]\n&gt;&gt; What those recommendations should be,\n\n659\n00:30:18.027 --> 00:30:20.010\nand that saves you a lot of time.\n\n660\n00:30:20.010 --> 00:30:24.260\nI know for me, sometimes I'll be typing in\na table name and no suggestions come up.\n\n661\n00:30:24.260 --> 00:30:26.078\nAnd I'm like,\nwhy is this thing not working?\n\n662\n00:30:26.078 --> 00:30:26.790\nIt's not that it's not working.\n\n663\n00:30:26.790 --> 00:30:28.074\nIt means that I spelled something wrong,\nor\n\n664\n00:30:28.074 --> 00:30:29.470\nI'm referencing a table\nthat doesn't exist.\n\n665\n00:30:29.470 --> 00:30:31.366\nIt usually means I'm connected\nto the wrong database.\n\n666\n00:30:31.366 --> 00:30:32.820\nThat's almost always what happens to me.\n\n667\n00:30:32.820 --> 00:30:36.053\nSo it's neat cuz it helps you know\nwhen you're doing something bad if you\n\n668\n00:30:36.053 --> 00:30:38.690\ndon't get suggestions, but\nyou'll see that pop up.\n\n669\n00:30:38.690 --> 00:30:40.150\nYou can ignore it if you hate it.\n\n670\n00:30:40.150 --> 00:30:42.820\nYou can go into Tools &gt; Options and\ndisable it if you hate it.\n\n671\n00:30:42.820 --> 00:30:44.020\nBut most people love it.\n\n672\n00:30:44.020 --> 00:30:46.208\nAnd you can just hit Tab to\nchoose what it's copying.\n\n673\n00:30:46.208 --> 00:30:47.384\nYou can use your mouse to click on it.\n\n674\n00:30:47.384 --> 00:30:51.534\nAnd it saves you a lot of typing and\nmakes you save a lot of errors.\n\n675\n00:30:51.534 --> 00:30:52.267\n&gt;&gt; I think it looks pretty cool.\n\n676\n00:30:52.267 --> 00:30:55.025\nIt's almost like finding\nthe pieces to that puzzle, or\n\n677\n00:30:55.025 --> 00:30:56.780\nat least assisting with that.\n\n678\n00:30:56.780 --> 00:30:59.315\nYou get your little corner pieces,\nthen your edge pieces.\n\n679\n00:30:59.315 --> 00:31:00.818\n&gt;&gt; [LAUGH]\n&gt;&gt; [LAUGH] And you can move forward.\n\n680\n00:31:00.818 --> 00:31:04.503\nSo thank you for taking the time to show\nus at least how to get started here, Don,\n\n681\n00:31:04.503 --> 00:31:06.190\nbut I know there's more to come.\n\n682\n00:31:06.190 --> 00:31:07.990\n&gt;&gt; Absolutely.\n&gt;&gt; And thank you for joining us as well.\n\n683\n00:31:07.990 --> 00:31:10.755\nDon, do you have any final\nthoughts before we head on out?\n\n684\n00:31:10.755 --> 00:31:12.355\n&gt;&gt; This episode was fairly lightweight,\nright?\n\n685\n00:31:12.355 --> 00:31:14.785\nI wanted you guys to have\nexperience with the user interface.\n\n686\n00:31:14.785 --> 00:31:16.895\nThe whole rest of the series,\nwe're writing queries,\n\n687\n00:31:16.895 --> 00:31:19.485\nwhere we're actually writing SQL or\nTransact-SQL.\n\n688\n00:31:19.485 --> 00:31:22.785\nAnd you'll get a chance to see how that\nworks and how we write these ourselves.\n\n689\n00:31:22.785 --> 00:31:24.875\nSo don't worry if you didn't know\nthese queries that I just did.\n\n690\n00:31:24.875 --> 00:31:26.205\nWe're gonna learn all those later on.\n\n691\n00:31:26.205 --> 00:31:28.885\n&gt;&gt; All right, perfect, well, for\nthis show, we'll go ahead and sign out.\n\n692\n00:31:28.885 --> 00:31:30.515\nI've been your host, Cherokee Boose.\n\n693\n00:31:30.515 --> 00:31:31.255\n&gt;&gt; And I'm Don Pezet.\n\n694\n00:31:31.255 --> 00:31:34.684\n&gt;&gt; See you next time here on ITProTV.\n\n695\n00:31:34.684 --> 00:31:40.457\n[MUSIC]\n\n696\n00:31:40.457 --> 00:31:42.310\n&gt;&gt; Thank you for watching ITProTV.\n\n",
          "vimeoId": "242963341"
        },
        {
          "description": "In this episode, Don introduces the viewers to the SELECT statement. He demonstrates how to retrieve data from a SQL database using SELECT, and then shows how to use the WHERE clause to refine the results",
          "length": "1578",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-2-1-retrieving_data_with_select-111317-PGM.00_26_06_14.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-2-1-retrieving_data_with_select-111317-PGM.00_26_06_14.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-2-1-retrieving_data_with_select-111317-PGM.00_26_06_14.Still001-sm.jpg",
          "title": "Retrieving Data with SELECT",
          "transcript": "",
          "vimeoId": "242962869"
        },
        {
          "description": "In this episode, Don continues demonstrating how to use the SELECT statement to retrieve data from a SQL server. He expands upon part 1 by demonstrating how to use ORDER BY, UNION and DISTINCT to further refine the results of a SELECT query.",
          "length": "1437",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-2-2-retrieving_data_with_select_pt2-111417-PGM.00_25_34_28.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-2-2-retrieving_data_with_select_pt2-111417-PGM.00_25_34_28.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-2-2-retrieving_data_with_select_pt2-111417-PGM.00_25_34_28.Still001-sm.jpg",
          "title": "Retrieving Data with SELECT Part 2",
          "transcript": "",
          "vimeoId": "242961954"
        },
        {
          "description": "In this episode, Don explains how to combine results from more than one table by using the JOIN clause. He demonstrates the basic operation of JOIN and then explains some methods to help simplify the SELECT query and make it more manageable.",
          "length": "1779",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-1-combining_results_with_join-111417-PGM.00_31_20_08.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-1-combining_results_with_join-111417-PGM.00_31_20_08.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-1-combining_results_with_join-111417-PGM.00_31_20_08.Still001-sm.jpg",
          "title": "Combining Results with JOIN",
          "transcript": "",
          "vimeoId": "242962353"
        },
        {
          "description": "In this episode, Don continues explaining how the JOIN clause can be used to generate results from multiple tables. He builds on part 1 by discussing other types of JOIN clauses that can be performed. He explains and demonstrates how to use INNER JOIN and three different types of OUTER JOIN.",
          "length": "1973",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-2-combining_results_with_join_pt2-111517-PGM.00_34_25_27.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-2-combining_results_with_join_pt2-111517-PGM.00_34_25_27.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-2-combining_results_with_join_pt2-111517-PGM.00_34_25_27.Still001-sm.jpg",
          "title": "Combining Results with JOIN Part 2",
          "transcript": "WEBVTT\n\n1\n00:00:00.093 --> 00:00:02.244\nWelcome to ITPRO.TV,\nI'm your host, Don Pezet.\n\n2\n00:00:02.244 --> 00:00:05.913\n[CROSSTALK]\n\n3\n00:00:05.913 --> 00:00:08.297\n[MUSIC]\n\n4\n00:00:08.297 --> 00:00:11.656\n&gt;&gt; You're watching ITPRO.TV.\n\n5\n00:00:11.656 --> 00:00:16.690\n&gt;&gt; Welcome ladies and gentlemen to your\nQuerying Data with Transact-SQL series.\n\n6\n00:00:16.690 --> 00:00:18.453\nI'm your show host, Cherokee Boose.\n\n7\n00:00:18.453 --> 00:00:22.606\nIn this episode, we'll be taking\na look at combining joins, and\n\n8\n00:00:22.606 --> 00:00:24.720\nthis is actually a Part II.\n\n9\n00:00:24.720 --> 00:00:26.838\nAnd with us today,\nback in studios, we have Mr.\n\n10\n00:00:26.838 --> 00:00:29.327\nDon Pezet, thank you for\njoining us, Don, how are you?\n\n11\n00:00:29.327 --> 00:00:29.876\n&gt;&gt; I'm doing great.\n\n12\n00:00:29.876 --> 00:00:32.990\nAnd in the first episode,\nwe focused on inner joins, right?\n\n13\n00:00:32.990 --> 00:00:35.097\nAnd we got a chance to see how\nwe can combine these tables and\n\n14\n00:00:35.097 --> 00:00:36.305\nput some information together.\n\n15\n00:00:36.305 --> 00:00:37.925\nAnd right at the end of the episode,\n\n16\n00:00:37.925 --> 00:00:40.920\nwe dropped in that little bombshell of,\nby the way.\n\n17\n00:00:40.920 --> 00:00:43.733\nThat's just one of actually four\ndifferent types of joins, and\n\n18\n00:00:43.733 --> 00:00:46.402\nthe other joins all fall into\nthis category of an outer join.\n\n19\n00:00:46.402 --> 00:00:50.570\nAnd in this episode, we're going to take\na look at the outer joins, how they work.\n\n20\n00:00:50.570 --> 00:00:53.188\nHow we issue the commands, and\nhow we use them to retrieve data and\n\n21\n00:00:53.188 --> 00:00:54.628\nkinda get a feel for how that works.\n\n22\n00:00:54.628 --> 00:00:56.930\nThat's all coming up right\nhere in this episode.\n\n23\n00:00:56.930 --> 00:00:59.411\n&gt;&gt; Don, I have to ask before\nwe get started, though,\n\n24\n00:00:59.411 --> 00:01:02.667\nwhat is the difference between\nan inner join versus an outer join?\n\n25\n00:01:02.667 --> 00:01:05.769\n&gt;&gt; This is actually a pretty\nsignificant difference, and\n\n26\n00:01:05.769 --> 00:01:09.003\nI didn't quite highlight it so\nmuch in the first episode.\n\n27\n00:01:09.003 --> 00:01:12.791\nBut it really boils down to the results\nthat we're presented with, right?\n\n28\n00:01:12.791 --> 00:01:15.581\nWhen we did the inner join,\nwe took two tables and\n\n29\n00:01:15.581 --> 00:01:19.204\nwe compared the results together\nbased on some kind of entity.\n\n30\n00:01:19.204 --> 00:01:20.404\nAnd we got a result and\n\n31\n00:01:20.404 --> 00:01:23.824\nset out of them based on your\ndata from two different tables.\n\n32\n00:01:23.824 --> 00:01:28.253\nNow, what I didn't highlight was that\nsometimes we don't have matches,\n\n33\n00:01:28.253 --> 00:01:30.320\nthings don't match up.\n\n34\n00:01:30.320 --> 00:01:34.073\nAnd in an inner join, anything that\ndoesn't match up just gets left out,\n\n35\n00:01:34.073 --> 00:01:36.383\ndoesn't get included, it gets thrown out.\n\n36\n00:01:36.383 --> 00:01:38.720\nAnd I don't think I ever mentioned\nthat in the first episode, but\n\n37\n00:01:38.720 --> 00:01:40.710\nwe're definitely going\nto see it right here.\n\n38\n00:01:40.710 --> 00:01:43.970\nBecause the whole point of an outer\njoin is to come back in and say,\n\n39\n00:01:43.970 --> 00:01:46.357\nI actually want that\nstuff that didn't match.\n\n40\n00:01:46.357 --> 00:01:49.600\nI need to know about it,\nit's important for some reason, right?\n\n41\n00:01:49.600 --> 00:01:52.741\nAnd there's several scenarios\nwhere that gets involved.\n\n42\n00:01:52.741 --> 00:01:56.008\nBut if we take a look,\nI'll bring up the query that we did,\n\n43\n00:01:56.008 --> 00:01:59.780\nI've got on my screen here the query\nthat we did in the last show.\n\n44\n00:01:59.780 --> 00:02:03.790\n&gt;&gt; Okay.\n&gt;&gt; This is a straight up inner join.\n\n45\n00:02:03.790 --> 00:02:06.824\nNow, through the whole episode,\nI just typed join like that, but\n\n46\n00:02:06.824 --> 00:02:10.469\nthere's actually an implied, when you\ndo join, it's an implied inner join.\n\n47\n00:02:10.469 --> 00:02:15.240\nAnd you can type it yourself if you want.\n\n48\n00:02:15.240 --> 00:02:18.720\nBut what we were doing was we\nwere getting the first name and\n\n49\n00:02:18.720 --> 00:02:20.577\nlast name of all of our people.\n\n50\n00:02:20.577 --> 00:02:24.751\nAnd matching it up to a job title and\na hired date from a human resources table,\n\n51\n00:02:24.751 --> 00:02:26.615\nthose were the two tables.\n\n52\n00:02:26.615 --> 00:02:30.086\nPerson.Person, that had every\ncontact that we knew about, and\n\n53\n00:02:30.086 --> 00:02:33.633\nthen HumanResources.Employee,\nthat had all of our employees.\n\n54\n00:02:33.633 --> 00:02:37.360\nAnd when we matched it up,\nwe got this result down here.\n\n55\n00:02:37.360 --> 00:02:40.880\nWhere we could see each of these people,\nlike Ken Sanchez, who's the CEO,\n\n56\n00:02:40.880 --> 00:02:42.535\nChief Executive Officer, right?\n\n57\n00:02:42.535 --> 00:02:46.800\nNow here's the thing, it did a great job,\nit created the table that I want.\n\n58\n00:02:46.800 --> 00:02:51.236\nI see these employees, I see their job\ntitle, that data came from two tables, and\n\n59\n00:02:51.236 --> 00:02:52.404\nthat's wonderful.\n\n60\n00:02:52.404 --> 00:02:54.620\nBut if I look at the result, right?\n\n61\n00:02:54.620 --> 00:02:58.596\nBuried down here under my head,\nI can see they return 290 rows,\n\n62\n00:02:58.596 --> 00:03:00.880\nI've got 290 employees, right?\n\n63\n00:03:00.880 --> 00:03:08.760\nBut that first table, Person.Person,\nit has a lot more than 290 entries in it.\n\n64\n00:03:08.760 --> 00:03:12.818\nIn fact,\nif we change our query a little bit here,\n\n65\n00:03:12.818 --> 00:03:19.309\nlet me just pull up that table if I do\na SELECT star FROM Person.Person, right?\n\n66\n00:03:19.309 --> 00:03:22.401\nOr actually I guess we could try and\nkeep it a little more fair and just do,\n\n67\n00:03:22.401 --> 00:03:25.508\nfirst name, comma, last name,\nwhich is what we're working with.\n\n68\n00:03:25.508 --> 00:03:28.015\n&gt;&gt; That's good, because I don't\nremember the number either, I mean,\n\n69\n00:03:28.015 --> 00:03:29.766\nit was several thousand,\nif I can recall [LAUGH].\n\n70\n00:03:29.766 --> 00:03:33.229\n&gt;&gt; Yeah, and if we just run that,\nand create Person.Person, right, so\n\n71\n00:03:33.229 --> 00:03:36.470\nhere it comes back with the data\nthat we got from that table.\n\n72\n00:03:36.470 --> 00:03:41.600\nAnd if I look down at my row count now,\n19,972,\n\n73\n00:03:41.600 --> 00:03:46.050\nwell, we only got 290 results on our join.\n\n74\n00:03:46.050 --> 00:03:50.190\nAnd the reason we only got 290 results\nis because it was an INNER JOIN.\n\n75\n00:03:50.190 --> 00:03:54.771\nAn INNER JOIN says, look, Person.Person\nhas over 19,000 people in it.\n\n76\n00:03:54.771 --> 00:03:59.890\nBut only 290 of them matched\nup to HumanResources.Employee.\n\n77\n00:03:59.890 --> 00:04:03.655\nAnd so that's what it then went on\nto display for us in our table, and\n\n78\n00:04:03.655 --> 00:04:07.507\nwhy we only got 290 results,\nthat's the way an inner join works.\n\n79\n00:04:07.507 --> 00:04:10.710\nNow, if that's what you want, great.\n\n80\n00:04:10.710 --> 00:04:14.147\nAnd in a lot of cases, it is what we want,\nso an inner join is straightforward,\n\n81\n00:04:14.147 --> 00:04:15.359\nyou do it, and that's it.\n\n82\n00:04:15.359 --> 00:04:19.995\nBut if I need to get the other records\nas well, the ones that didn't match.\n\n83\n00:04:19.995 --> 00:04:23.775\nAn inner join is not what I need, and\nthat's where an outer join comes in.\n\n84\n00:04:23.775 --> 00:04:26.440\n&gt;&gt; Well, Don, I feel like you\nhave some surprises for us,\n\n85\n00:04:26.440 --> 00:04:28.960\njust like the surprise with\nthe inner versus outer.\n\n86\n00:04:28.960 --> 00:04:31.662\nI see here on the notes that there\nare different types of outer joins,\n\n87\n00:04:31.662 --> 00:04:33.255\ndo you want to kind of elaborate on that?\n\n88\n00:04:33.255 --> 00:04:33.755\n&gt;&gt; Yeah, yeah.\n&gt;&gt; [LAUGH]\n\n89\n00:04:33.755 --> 00:04:35.853\n&gt;&gt; So on an inner join, there's just one,\n\n90\n00:04:35.853 --> 00:04:40.360\nand that's the default join, so that's it,\nwe've learned all we need to know on that\n\n91\n00:04:40.360 --> 00:04:43.433\none, right?\nBut on an outer join, there's actually\n\n92\n00:04:43.433 --> 00:04:45.938\nthree different types of outer joins.\nAnd\n\n93\n00:04:45.938 --> 00:04:51.260\nthat's because of the way that the records\nmay or may not match up, right?\n\n94\n00:04:51.260 --> 00:04:53.795\nWhen we run the query,\nwhere is the data getting lost?\n\n95\n00:04:53.795 --> 00:04:56.254\nAnd so, that's where,\nwhen we use an outer join,\n\n96\n00:04:56.254 --> 00:04:59.620\nwe actually have to make\na little more of a choice, right?\n\n97\n00:04:59.620 --> 00:05:02.478\nFor an inner join, I can just type,\ninner join, for an outer join,\n\n98\n00:05:02.478 --> 00:05:03.898\nI can't just type, outer join.\n\n99\n00:05:03.898 --> 00:05:07.251\nIf I do that, I should have\ntested this before the show, but\n\n100\n00:05:07.251 --> 00:05:08.680\nI'm gonna run it [LAUGH].\n\n101\n00:05:08.680 --> 00:05:12.110\nAnd I'll give it an error, actually its\nunderlying JOIN there as an error, right?\n\n102\n00:05:12.110 --> 00:05:16.910\nAnd that's because it knows I need to\ntell it which of the three types of outer\n\n103\n00:05:16.910 --> 00:05:18.740\njoins that I want to do.\n\n104\n00:05:18.740 --> 00:05:22.642\nSo the three types,\nthere is a left outer join,\n\n105\n00:05:22.642 --> 00:05:26.163\na right outer join, and a full outer join.\n\n106\n00:05:26.163 --> 00:05:30.627\nAnd what they're doing is basically\nallowing us to pick the values that we\n\n107\n00:05:30.627 --> 00:05:31.780\nwant to preserve.\n\n108\n00:05:31.780 --> 00:05:34.749\nThe values that don't necessarily\nhave a full match up and\n\n109\n00:05:34.749 --> 00:05:36.392\nall the exact records and so on.\n\n110\n00:05:36.392 --> 00:05:38.705\nNow to explain the difference\nbetween the three,\n\n111\n00:05:38.705 --> 00:05:41.800\nit's kind of hard when you're just\nlooking at raw data like this.\n\n112\n00:05:41.800 --> 00:05:44.280\nSo I actually worked up a little picture,\nand\n\n113\n00:05:44.280 --> 00:05:46.902\nyou guys know my artistic\nability is not great.\n\n114\n00:05:46.902 --> 00:05:49.514\n&gt;&gt; [LAUGH]\n&gt;&gt; But basically, when we do a join,\n\n115\n00:05:49.514 --> 00:05:52.274\nwe've got two tables,\nright, Table 1 and Table 2.\n\n116\n00:05:52.274 --> 00:05:57.013\nIn the example I showed you guys a minute\nago, Table 1 was Person.Person, and\n\n117\n00:05:57.013 --> 00:05:59.150\nit had all the people we know about.\n\n118\n00:05:59.150 --> 00:06:01.920\nAnd Table 2 was the-\n&gt;&gt; Human resources.\n\n119\n00:06:01.920 --> 00:06:06.193\n&gt;&gt; Right, HumanResources.Employee, and\nthat had just our employees' information.\n\n120\n00:06:06.193 --> 00:06:10.474\n&gt;&gt; So there's a lot of data in\nTable 1 that isn't in Table 2,\n\n121\n00:06:10.474 --> 00:06:14.860\nthat doesn't match up, but\nthere's overlap, right?\n\n122\n00:06:14.860 --> 00:06:19.197\nIf you remember back to first grade,\nred and blue make purple, or Ziploc bags,\n\n123\n00:06:19.197 --> 00:06:19.732\nI guess.\n\n124\n00:06:19.732 --> 00:06:23.286\nAnd I can see I've got this\npurple area right here,\n\n125\n00:06:23.286 --> 00:06:25.945\nthat's the overlap between the two.\n\n126\n00:06:25.945 --> 00:06:29.226\nSo, I might have 19,972 rows in Table 1,\nbut\n\n127\n00:06:29.226 --> 00:06:32.371\nonly 290 of them overlap with Table 2,\nokay?\n\n128\n00:06:32.371 --> 00:06:37.418\nWhen we do an inner join,\nour result is just the overlap,\n\n129\n00:06:37.418 --> 00:06:41.000\njust that part in the middle, okay?\n\n130\n00:06:41.000 --> 00:06:44.408\nNow, no matter what join we run,\nif it's an inner join or\n\n131\n00:06:44.408 --> 00:06:48.467\nany of the three outer joins,\nyou will always get this purple part.\n\n132\n00:06:48.467 --> 00:06:49.975\nYou always get the overlap.\n\n133\n00:06:49.975 --> 00:06:51.216\n&gt;&gt; Okay.\n\n134\n00:06:51.216 --> 00:06:53.523\n&gt;&gt; Where the outer join comes in,\nthough, is when we say,\n\n135\n00:06:53.523 --> 00:06:55.070\nwe want more than that, right?\n\n136\n00:06:55.070 --> 00:06:58.717\nIf you just want the overlap,\ninner join, done, easy, right?\n\n137\n00:06:58.717 --> 00:07:02.870\nBut if you want the stuff that\ngets left out, we've got choices.\n\n138\n00:07:02.870 --> 00:07:06.203\nAnd the choice always comes down\nto where we want the unmatched\n\n139\n00:07:06.203 --> 00:07:07.879\nrecords to come from, right?\n\n140\n00:07:07.879 --> 00:07:12.496\nNow, when you do a join like this,\nthey don't like to call it Table 1 and\n\n141\n00:07:12.496 --> 00:07:17.000\nTable 2, instead they call it\na left table and a right table.\n\n142\n00:07:17.000 --> 00:07:20.752\nTable 1 is my left table, and\nTable 2 is my right table.\n\n143\n00:07:20.752 --> 00:07:23.812\nNow, on a diagram like this, it makes\nsense, you look at it, and you're like,\n\n144\n00:07:23.812 --> 00:07:26.250\nall right, Table 1 is on the left,\nand Table 2 is on the right.\n\n145\n00:07:26.250 --> 00:07:29.865\n&gt;&gt; But is Person.Person, or\nHumanResources.Employee on the left or\n\n146\n00:07:29.865 --> 00:07:30.496\nthe right?\n\n147\n00:07:30.496 --> 00:07:32.330\n&gt;&gt; Right, so\nthat's where it gets a little tricky.\n\n148\n00:07:32.330 --> 00:07:37.698\nAnd if we go back and look at our query,\nthe way it works is the FROM table,\n\n149\n00:07:37.698 --> 00:07:40.790\nthe first one, that's your left table.\n\n150\n00:07:40.790 --> 00:07:45.780\nAnd then the JOIN table, the next one,\nthat's your right table, all right?\n\n151\n00:07:45.780 --> 00:07:48.437\nAnd if you can't remember that,\ndown here is where it's actually defined.\n\n152\n00:07:48.437 --> 00:07:51.901\nWhen you say that you're doing\nthe join ON, right here,\n\n153\n00:07:51.901 --> 00:07:56.156\nI've got one table on the left And\nthen equal in one table on the right,\n\n154\n00:07:56.156 --> 00:07:59.430\nthat was actually establishing\nthat relationship.\n\n155\n00:07:59.430 --> 00:08:03.340\nAnd if I were to flip that around,\nthat would flip who is left and right.\n\n156\n00:08:03.340 --> 00:08:06.940\nSo, it usually is done this way\nthough where the from is left and\n\n157\n00:08:06.940 --> 00:08:08.320\nthe join is the right.\n\n158\n00:08:08.320 --> 00:08:11.920\nBut again, when in doubt look for the\nequal sign and whoever's to the left is\n\n159\n00:08:11.920 --> 00:08:14.280\nthe left table, whoever is on\nthe right is the right table.\n\n160\n00:08:14.280 --> 00:08:18.960\nAnd so when we do that join,\nthis is what's kind of coming into play.\n\n161\n00:08:18.960 --> 00:08:20.760\nNow on an inner join,\nwe don't care who's left or\n\n162\n00:08:20.760 --> 00:08:24.830\nright cuz we just get the overlap,\nbut on the outer join we do\n\n163\n00:08:24.830 --> 00:08:28.660\nbecause on an outer join I might wanna\ndo what's called a full outer join.\n\n164\n00:08:28.660 --> 00:08:33.490\nA full outer join as I say I want\nevery row that doesn't match.\n\n165\n00:08:33.490 --> 00:08:39.130\nI don't care if it's a person who's not\nan employee, I wanna get their data.\n\n166\n00:08:39.130 --> 00:08:43.478\nAnd so it will show me the overlap,\nit'll combine that data, but\n\n167\n00:08:43.478 --> 00:08:49.271\nit'll also show me the contacts that don't\nhave a higher date and a job title, right?\n\n168\n00:08:49.271 --> 00:08:52.560\n&gt;&gt; Yes.\n&gt;&gt; I'll see those, my regular people.\n\n169\n00:08:52.560 --> 00:08:56.650\nBut I'll also see any entries in\nhuman resources that employ where I\n\n170\n00:08:56.650 --> 00:08:59.820\nhave a higher date and a job title,\nbut it's not mapped to a person.\n\n171\n00:08:59.820 --> 00:09:03.860\nNow, usually we have database integrity\nthat prevents that from happening.\n\n172\n00:09:03.860 --> 00:09:08.170\nSo there really is no scenario where I\nshould have an entry in human resources\n\n173\n00:09:08.170 --> 00:09:11.220\nfor somebody who's not also in person,\nthat shouldn't happen.\n\n174\n00:09:11.220 --> 00:09:13.160\nSo maybe I'm doing error checking.\n\n175\n00:09:13.160 --> 00:09:14.150\nI'm looking to see maybe it didn't happen.\n\n176\n00:09:14.150 --> 00:09:15.790\nMaybe somebody screwed up, right?\n\n177\n00:09:15.790 --> 00:09:21.070\nBut typically, I'm not gonna need\nthe unmatched ones from Table 2.\n\n178\n00:09:21.070 --> 00:09:22.890\nBut I will have unmatched ones in Table 1.\n\n179\n00:09:22.890 --> 00:09:25.380\nWe need to understand our data\nto figure out what we want.\n\n180\n00:09:25.380 --> 00:09:27.400\nIf I do a full outer join,\n\n181\n00:09:27.400 --> 00:09:32.390\nI'm usually getting stuff that isn't\nwhat I really want, all right.\n\n182\n00:09:32.390 --> 00:09:34.620\nAnd so\nfull outer joins are pretty uncommon.\n\n183\n00:09:34.620 --> 00:09:40.300\nInstead, we're normally gonna be doing\na left outer join or a right outer join.\n\n184\n00:09:40.300 --> 00:09:43.750\nAnd in a left outer join,\nyou're still getting the purple,\n\n185\n00:09:43.750 --> 00:09:47.790\nyou're getting the overlap material in the\nmiddle, but you're getting the unmatched\n\n186\n00:09:47.790 --> 00:09:52.930\nrows from the left table,\nnot the unmatched rows in the right table.\n\n187\n00:09:52.930 --> 00:09:56.660\nUsing my employee example, a left\nouter join would be more appropriate.\n\n188\n00:09:56.660 --> 00:09:59.918\nIf I just wanna see employees,\nI do an Inner Join.\n\n189\n00:09:59.918 --> 00:10:04.500\nIf I wanna see employees and regular\ncontacts, but I want the employees to have\n\n190\n00:10:04.500 --> 00:10:08.960\ntheir job title and hire date,\nthen a left outer join makes more sense.\n\n191\n00:10:08.960 --> 00:10:11.850\nThe unmatched records and\nthe matched records from Table 1.\n\n192\n00:10:11.850 --> 00:10:13.640\nThe overlap is the purple.\n\n193\n00:10:13.640 --> 00:10:17.040\nAnd then no unmatched\nrecords from Table 2.\n\n194\n00:10:17.040 --> 00:10:19.070\n&gt;&gt; All right Don, so\nI'm left with a question here, and\n\n195\n00:10:19.070 --> 00:10:22.340\nwe talked about the inner joins when\nwe said we can combine more than two\n\n196\n00:10:22.340 --> 00:10:25.460\ntables to go ahead and perform that query.\n\n197\n00:10:25.460 --> 00:10:30.030\nSo if I could see maybe that\nhappening full outer join, but\n\n198\n00:10:30.030 --> 00:10:32.880\nwhen you have a left or right outer join.\n\n199\n00:10:32.880 --> 00:10:35.640\nI mean can you not have\nmore than two tables?\n\n200\n00:10:35.640 --> 00:10:36.510\n&gt;&gt; You can.\n\n201\n00:10:36.510 --> 00:10:38.470\nIt just starts to get really complex,\nright?\n\n202\n00:10:38.470 --> 00:10:40.450\n&gt;&gt; Okay.\n&gt;&gt; So I have an example of that.\n\n203\n00:10:40.450 --> 00:10:43.460\nI wanna show you guys a little bit\nlater after we've kinda solidify this.\n\n204\n00:10:43.460 --> 00:10:48.100\nBecause when you start combining more than\none table, more than two tables, sorry.\n\n205\n00:10:48.100 --> 00:10:50.690\nDoing a simple join between\ntwo tables is easy.\n\n206\n00:10:50.690 --> 00:10:53.840\nBut then, when you do a third join, or\na fourth join, cuz you can do many,\n\n207\n00:10:53.840 --> 00:10:55.890\nmany, many, it gets really complex.\n\n208\n00:10:55.890 --> 00:11:00.020\nSo you need to make sure you that you\nhave a good understanding of each join.\n\n209\n00:11:00.020 --> 00:11:03.760\nAnd in a later episode, we're gonna talk\nabout something called a derived table.\n\n210\n00:11:03.760 --> 00:11:05.830\n&gt;&gt; Okay.\n&gt;&gt; And a derived table is where the table\n\n211\n00:11:05.830 --> 00:11:07.330\ndoesn't even necessarily exist.\n\n212\n00:11:07.330 --> 00:11:09.390\nWe run some kinda calculations.\n\n213\n00:11:09.390 --> 00:11:11.380\nAnd it creates a temporary table.\n\n214\n00:11:11.380 --> 00:11:14.240\nAnd we can do joins against\nthose temporary tables, right?\n\n215\n00:11:14.240 --> 00:11:16.380\nAnd that's when it really gets complex.\n\n216\n00:11:16.380 --> 00:11:19.900\nSo as this series goes on,\nwe're goanna kick out the stops.\n\n217\n00:11:19.900 --> 00:11:22.520\nWe're gonna use this chance\nto see some of that stuff.\n\n218\n00:11:22.520 --> 00:11:25.605\nBut for right now,\nlet's focus on the simple join.\n\n219\n00:11:25.605 --> 00:11:28.111\nYou're join two tables, make sure we got\na good understanding on foundation one.\n\n220\n00:11:28.111 --> 00:11:30.834\n&gt;&gt; Baby steps.\n&gt;&gt; And I promise you before we're done\n\n221\n00:11:30.834 --> 00:11:35.350\nwith the join episodes, I will show\nyou guys a multi table example.\n\n222\n00:11:35.350 --> 00:11:38.470\nBut we're gonna see that even more when\nwe get to derive tables cuz you almost\n\n223\n00:11:38.470 --> 00:11:40.770\nalways do joins on derive tables.\n\n224\n00:11:40.770 --> 00:11:43.220\nIt's not a guarantee,\nbut typically you will.\n\n225\n00:11:43.220 --> 00:11:45.220\nSo we'll get a chance to see that.\n\n226\n00:11:45.220 --> 00:11:48.520\nAll right, now, the last one I talked\nabout was the left outer join, right?\n\n227\n00:11:48.520 --> 00:11:53.340\nAnd, in my scenario, where I've got the\nperson not person, and the employee table,\n\n228\n00:11:53.340 --> 00:11:55.480\nthat make sense,\nthat I would do a left outer join.\n\n229\n00:11:55.480 --> 00:11:57.690\nSometimes it's the other way around,\nthough.\n\n230\n00:11:57.690 --> 00:12:00.610\nSometimes I might have a list\nof customers in one table.\n\n231\n00:12:00.610 --> 00:12:02.200\nAnd a list of orders on the right side.\n\n232\n00:12:02.200 --> 00:12:05.950\nAnd I might have orders on the right\nthat haven't been matched to a customer.\n\n233\n00:12:05.950 --> 00:12:08.040\nOr orders that haven't\nmatched with salesperson.\n\n234\n00:12:08.040 --> 00:12:10.660\nYou see this with sales leads a lot,\nright?\n\n235\n00:12:10.660 --> 00:12:14.120\nI get a sales lead and it hasn't been\nassociated with a salesperson yet.\n\n236\n00:12:14.120 --> 00:12:18.020\nIt exists, it's in that right table,\nbut it's not in the left table yet.\n\n237\n00:12:18.020 --> 00:12:21.730\nAnd then the next scenario will change\nthis diagram around and instead of doing\n\n238\n00:12:21.730 --> 00:12:25.280\nlike what I'm showing you on my screen now\nwhere I've got unmatched one in the left.\n\n239\n00:12:25.280 --> 00:12:27.680\nI might want the unmatch\nones in the right.\n\n240\n00:12:27.680 --> 00:12:31.060\nSo on the left,\nI might have my sales people.\n\n241\n00:12:31.060 --> 00:12:35.660\nAnd it's a pretty, finite number, I'm\nonly got certain amount of sales people.\n\n242\n00:12:35.660 --> 00:12:40.730\nAnd then every sale or every lead over\nhere should be attached to a sales person.\n\n243\n00:12:40.730 --> 00:12:44.020\nThe overlap, those are gonna be\nleads that are already assigned.\n\n244\n00:12:44.020 --> 00:12:46.060\nThat's good, they've already\nbeen assigned to sales person.\n\n245\n00:12:46.060 --> 00:12:50.860\nWhat's left out over here are things that\nneed to be assigned to a salesperson.\n\n246\n00:12:50.860 --> 00:12:53.650\nAnd a right outer join would show me both.\n\n247\n00:12:53.650 --> 00:12:55.590\nNow, one thing I want to throw out here.\n\n248\n00:12:55.590 --> 00:13:00.850\nIf I'm just looking for sales that\nhaven't been attached to a salesperson,\n\n249\n00:13:00.850 --> 00:13:03.040\nI don't need a join for that, right?\n\n250\n00:13:03.040 --> 00:13:06.480\nBecause they'll have\nan entry in that table\n\n251\n00:13:06.480 --> 00:13:08.720\nthat indicates who the salesperson is.\n\n252\n00:13:08.720 --> 00:13:11.381\nAnd if it's empty that's a null value,\nI don't need a join,\n\n253\n00:13:11.381 --> 00:13:12.926\nI can just query that table and say.\n\n254\n00:13:12.926 --> 00:13:13.448\n&gt;&gt; Do a search.\n\n255\n00:13:13.448 --> 00:13:17.572\n&gt;&gt; Yeah, show me any value or any row\nthat doesn't have a sales through and\n\n256\n00:13:17.572 --> 00:13:18.750\nyou're done.\n\n257\n00:13:18.750 --> 00:13:21.620\nSo if you're just trying to find\nthe missing ones, you'll need a join.\n\n258\n00:13:21.620 --> 00:13:23.930\n&gt;&gt; So\nwhy would we use those unmatched records?\n\n259\n00:13:23.930 --> 00:13:27.100\n&gt;&gt; When you want both,\nwhen I want the matched records and\n\n260\n00:13:27.100 --> 00:13:30.410\nthe unmatched,\nI wanna see a whole of my leads, right?\n\n261\n00:13:30.410 --> 00:13:36.170\nAnd an example there would be,\nwhere I'm trying to find out\n\n262\n00:13:36.170 --> 00:13:41.290\nwho's the person with the most leads, and\nwho's the person with the least leads.\n\n263\n00:13:41.290 --> 00:13:43.710\nSo that I can then assign records to\nthe person that has the least, and\n\n264\n00:13:43.710 --> 00:13:47.110\nI can do it all in one table and we can\nget it all kinda calculated in one place.\n\n265\n00:13:47.110 --> 00:13:49.610\nIt's not a one-size-fits-all scenario.\n\n266\n00:13:49.610 --> 00:13:54.100\nYou've gotta look at it, and determine\nis this actually what I wanna do.\n\n267\n00:13:54.100 --> 00:13:56.550\nAnd I'll be honest with you,\nouter joins for\n\n268\n00:13:56.550 --> 00:13:59.540\nme I can usually find some other way\nto get the information that I want.\n\n269\n00:13:59.540 --> 00:14:03.540\nIt's nice to have the tool because again\nthe server's doing the work for us.\n\n270\n00:14:03.540 --> 00:14:08.040\nAnd it's also nice to know about the tool\nbecause a lot of people don't realize with\n\n271\n00:14:08.040 --> 00:14:11.000\ninner joins you're not necessarily\ngetting all of your records.\n\n272\n00:14:11.000 --> 00:14:12.680\nThat there's things that\nare being left behind,\n\n273\n00:14:12.680 --> 00:14:16.330\nand there's that potential that you get\nbad records that sit there for years and\n\n274\n00:14:16.330 --> 00:14:19.390\nyou never know about it because\nthe inner joins have been hiding it.\n\n275\n00:14:19.390 --> 00:14:21.755\nAnd if you don't look at the underlying\ntables, you won't see it.\n\n276\n00:14:21.755 --> 00:14:23.500\nOutter joins make sure we get\nsome of that information.\n\n277\n00:14:23.500 --> 00:14:26.170\nSo just to recap real quick,\ncuz I talked longer than I wanted to.\n\n278\n00:14:26.170 --> 00:14:28.325\nLet me run through these\ndiagrams one more time.\n\n279\n00:14:28.325 --> 00:14:31.130\n&gt;&gt; Okay.\n&gt;&gt; We had the right outer join,\n\n280\n00:14:31.130 --> 00:14:36.000\nwhich gets all the matches and\nany unmatched record from the right table.\n\n281\n00:14:36.000 --> 00:14:38.490\nA left outer join,\nwhich is all the matches and\n\n282\n00:14:38.490 --> 00:14:41.070\nall the unmatched records\nfrom the left table.\n\n283\n00:14:41.070 --> 00:14:45.650\nAnd a full outer join which gets\nall the unmatched records from\n\n284\n00:14:45.650 --> 00:14:50.305\nboth tables as well as the overlap,\nthis gives me the full set of data.\n\n285\n00:14:50.305 --> 00:14:55.100\nThey're all joins, they're just\nincluding a lot more than an inner join.\n\n286\n00:14:55.100 --> 00:14:57.650\n&gt;&gt; All right so\ncan we actually se an example,\n\n287\n00:14:57.650 --> 00:15:00.800\ndo you have anything visually,\nI mean more pictures maybe?\n\n288\n00:15:00.800 --> 00:15:02.020\n&gt;&gt; [LAUGH]\n&gt;&gt; [LAUGH]\n\n289\n00:15:02.020 --> 00:15:03.500\n&gt;&gt; I don't have more pictures, but\n\n290\n00:15:03.500 --> 00:15:06.900\nI do have examples\n&gt;&gt; Which is good because I'm not so\n\n291\n00:15:06.900 --> 00:15:07.860\ngood at the pictures.\n\n292\n00:15:07.860 --> 00:15:09.710\nBut, if I go back to this one, right?\n\n293\n00:15:09.710 --> 00:15:12.480\nWe already saw,\nI kind of demonstrated a moment ago,\n\n294\n00:15:12.480 --> 00:15:17.120\nthat when I did that inner join here,\nand again,\n\n295\n00:15:17.120 --> 00:15:20.630\nI don't have to type inner, I can just\nleave it as JOIN cuz that is the default,\n\n296\n00:15:20.630 --> 00:15:23.200\nbut if I want to type it out\n&gt;&gt; It helps me to make sure I know exactly\n\n297\n00:15:23.200 --> 00:15:24.880\nwhat type of join I'm doing.\n\n298\n00:15:24.880 --> 00:15:28.970\nWhen I do that,\nI only got 290 rows back, right?\n\n299\n00:15:28.970 --> 00:15:33.530\nSo that was my indicator there that\nI'm leaving rows on the table.\n\n300\n00:15:33.530 --> 00:15:37.035\nIf I scroll all the way down\nhere I can see 290 rows, right?\n\n301\n00:15:37.035 --> 00:15:41.460\nAnd looking at all these different people,\neveryone of them has a job title and\n\n302\n00:15:41.460 --> 00:15:45.012\na hire date, If they didn't,\nif one of those was a null value or\n\n303\n00:15:45.012 --> 00:15:46.930\njust completely missing.\n\n304\n00:15:46.930 --> 00:15:50.530\nActually a null value would show up here,\nbecause at least it has a record.\n\n305\n00:15:50.530 --> 00:15:54.461\nBut if it was completely missing,\nit wouldn't show up, right?\n\n306\n00:15:54.461 --> 00:15:58.640\nSo all the other people, the 19,000-\n&gt;&gt; Like the 19,400 something, yeah.\n\n307\n00:15:58.640 --> 00:16:01.043\n&gt;&gt; Pardon me, yeah,\nthat's beyond my math skills there.\n\n308\n00:16:01.043 --> 00:16:03.673\n&gt;&gt; [LAUGH].\n&gt;&gt; If I were to change this though and\n\n309\n00:16:03.673 --> 00:16:07.260\nmake it an outer join,\nI could see those, right?\n\n310\n00:16:07.260 --> 00:16:08.790\nAnd changing them,\nI mean, really not hard.\n\n311\n00:16:08.790 --> 00:16:13.797\nIn this case, the table on the left,\nwhich is person.person,\n\n312\n00:16:13.797 --> 00:16:18.175\nthat has all of my contacts,\nemployees and otherwise.\n\n313\n00:16:18.175 --> 00:16:21.500\nThe table on the right just\nhas my employees, right?\n\n314\n00:16:21.500 --> 00:16:24.590\nThere's h or HumanResources.employees,\nthat's just employees.\n\n315\n00:16:24.590 --> 00:16:26.170\nSo if I wanna get my non-employees,\n\n316\n00:16:26.170 --> 00:16:29.700\nit's the table on the left that has\nwhat I'm concerned about, okay?\n\n317\n00:16:29.700 --> 00:16:35.960\nSo I could do a left outer join,\nlike that, okay?\n\n318\n00:16:35.960 --> 00:16:39.400\nA left outer join, and\nnotice my syntax doesn't change much,\n\n319\n00:16:39.400 --> 00:16:40.870\nI just tell it a different join.\n\n320\n00:16:40.870 --> 00:16:43.460\nEverything else is done the same way,\nso it's easy to learn this,\n\n321\n00:16:43.460 --> 00:16:45.470\nthe hard part is picking\nwhich one you want.\n\n322\n00:16:45.470 --> 00:16:46.718\n&gt;&gt; Making sure you got the right one,\nyeah [LAUGH].\n\n323\n00:16:46.718 --> 00:16:49.807\n&gt;&gt; And even then, if you screw up, you run\nthe query, you get the wrong results and\n\n324\n00:16:49.807 --> 00:16:50.515\nso you change it.\n\n325\n00:16:50.515 --> 00:16:54.570\nAnd easy enough, change from left\nto right or go to full or whatever.\n\n326\n00:16:54.570 --> 00:16:57.130\nNow when I do a left\nouter join on this and\n\n327\n00:16:57.130 --> 00:17:01.570\nI re-run it, it's gonna run and\nI get my information back.\n\n328\n00:17:01.570 --> 00:17:05.822\nAnd I'm gonna notice two things right\noff the bat, let me zoom in a bit.\n\n329\n00:17:05.822 --> 00:17:09.727\nFirst off, way down here in the bottom\nright corner under my head,\n\n330\n00:17:09.727 --> 00:17:12.320\nI can see that I've got 19,972 rows.\n\n331\n00:17:12.320 --> 00:17:16.290\nI now have the full set of person.person,\nokay?\n\n332\n00:17:16.290 --> 00:17:20.010\nAnd then if I look at the result,\nthere's Kim Abercrombie, but\n\n333\n00:17:20.010 --> 00:17:21.140\nshe's one of my employees.\n\n334\n00:17:21.140 --> 00:17:24.770\nAnd I can see right here,\nproduction technician-WC60.\n\n335\n00:17:24.770 --> 00:17:27.556\nI don't know what that means,\nbut there she is.\n\n336\n00:17:27.556 --> 00:17:32.684\nAnd I've got Hazim Aberose, who is\na quality assurance manager, down in QA.\n\n337\n00:17:32.684 --> 00:17:35.220\nSo there they are, they're my employees.\n\n338\n00:17:35.220 --> 00:17:38.260\nBut then I've got other people,\nI've got Catherine Abel.\n\n339\n00:17:38.260 --> 00:17:42.690\nWho's entered in with no job title and\nno hire date.\n\n340\n00:17:42.690 --> 00:17:44.290\nShe's not an employee, right?\n\n341\n00:17:44.290 --> 00:17:47.323\nShe is just a contact that we have for\nsome other reason.\n\n342\n00:17:47.323 --> 00:17:49.630\nMaybe a customer,\nmaybe a contractor, I don't know.\n\n343\n00:17:49.630 --> 00:17:50.840\nBut she's not an employee.\n\n344\n00:17:50.840 --> 00:17:53.040\nI now get the full results, right?\n\n345\n00:17:53.040 --> 00:17:55.710\nAnd I can see them in one table.\n\n346\n00:17:55.710 --> 00:17:59.710\nA left outer joint in this\ncase made sense for me, okay?\n\n347\n00:17:59.710 --> 00:18:02.370\nNow I could've done a full outer join, but\n\n348\n00:18:02.370 --> 00:18:05.930\nin my scenario, actually we really\nwouldn't result in any difference.\n\n349\n00:18:05.930 --> 00:18:09.942\nIf the right table has no unmatched\nrecords, in the right table I'm not gonna\n\n350\n00:18:09.942 --> 00:18:13.349\nhave a human resources record for\nsomebody who's not a contact.\n\n351\n00:18:13.349 --> 00:18:14.749\nIt doesn't make any sense, right?\n\n352\n00:18:14.749 --> 00:18:17.990\nSo in this case,\na full outer join would perform the same.\n\n353\n00:18:17.990 --> 00:18:25.549\nIf I change that to a full outer join and\nI rerun that, I get my results back.\n\n354\n00:18:25.549 --> 00:18:29.090\nSee how the results look the same and\nI still have the same information.\n\n355\n00:18:29.090 --> 00:18:32.371\nIf I go all the way to bottom right,\nI still have 19,917.\n\n356\n00:18:32.371 --> 00:18:37.355\n&gt;&gt; And I totally messed that number up, I\nthought it was 19,700 something like that.\n\n357\n00:18:37.355 --> 00:18:38.465\n&gt;&gt; Close enough, right?\n\n358\n00:18:38.465 --> 00:18:42.210\n[LAUGH] So\nI can see that it didn't change, right?\n\n359\n00:18:42.210 --> 00:18:44.030\nIn this scenario,\n\n360\n00:18:44.030 --> 00:18:48.720\na full outer join is gonna give me the\nsame results as a left outer join, right?\n\n361\n00:18:48.720 --> 00:18:53.520\nAnd that happens a lot, usually you\nhave one table that has all the right\n\n362\n00:18:53.520 --> 00:18:57.769\ninformation and another table\nthat's expected to not match.\n\n363\n00:18:57.769 --> 00:19:00.505\nThat's usually what we have,\nand so left outer joins and\n\n364\n00:19:00.505 --> 00:19:02.396\nright outer joins are the most common.\n\n365\n00:19:02.396 --> 00:19:07.560\nFull outer joins are indicating that there\nmight be unmatched records in both sides,\n\n366\n00:19:07.560 --> 00:19:09.390\nin the left side and the right side.\n\n367\n00:19:09.390 --> 00:19:15.346\nThat might happen if we were trying to\nmatch up sales leads to orders, right?\n\n368\n00:19:15.346 --> 00:19:20.330\nI might have some sales leads\nthat had no order placed.\n\n369\n00:19:20.330 --> 00:19:24.040\nAnd I might have some orders\nthat don't have a lead attached,\n\n370\n00:19:24.040 --> 00:19:25.630\nbecause maybe it was a recurring sale.\n\n371\n00:19:25.630 --> 00:19:27.159\nIt came from somebody we\nalready do business with,\n\n372\n00:19:27.159 --> 00:19:28.089\nso there's no lead attached.\n\n373\n00:19:28.089 --> 00:19:31.260\nIn that case,\nI have missing matches on both sides.\n\n374\n00:19:31.260 --> 00:19:35.050\nAnd if I do a left outer join,\nI'll get, let's say 100 rows.\n\n375\n00:19:35.050 --> 00:19:36.902\nIf I do a right outer join,\nI might get 200 rows.\n\n376\n00:19:36.902 --> 00:19:40.832\nAnd then if I do a full outer join,\nI might get 300 rows, right?\n\n377\n00:19:40.832 --> 00:19:42.682\nSo each one has a different recurrence.\n\n378\n00:19:42.682 --> 00:19:45.630\nBut that's a much less common comparison,\nbut\n\n379\n00:19:45.630 --> 00:19:49.580\nit is one that there is a scenario for,\nsometimes we do need to do that.\n\n380\n00:19:49.580 --> 00:19:52.729\n&gt;&gt; I think in the last episode\nwe were just kind of alluding\n\n381\n00:19:52.729 --> 00:19:56.630\nto the fact we might be using it for\nthe purpose of least privileged or\n\n382\n00:19:56.630 --> 00:19:58.425\nsome kind of security aspect.\n\n383\n00:19:58.425 --> 00:20:02.144\nSo in that situation we would\nexpect one to be a full set,\n\n384\n00:20:02.144 --> 00:20:06.990\nand then the other would just be\na slimmed down version, so more common?\n\n385\n00:20:06.990 --> 00:20:09.456\n&gt;&gt; Yeah, absolutely, and\nwhen I talk about how common they are and\n\n386\n00:20:09.456 --> 00:20:11.749\nhow uncommon they are,\nthat's just from what I've seen.\n\n387\n00:20:11.749 --> 00:20:13.370\n&gt;&gt; From knowing what they are, yeah.\n\n388\n00:20:13.370 --> 00:20:15.496\n&gt;&gt; And the reality is, your environment\nmight be very different, right?\n\n389\n00:20:15.496 --> 00:20:18.487\nSo you may have a special needs where\nyou need a particular course, so\n\n390\n00:20:18.487 --> 00:20:20.250\nit's nice to have that choice, right?\n\n391\n00:20:20.250 --> 00:20:22.225\nSo just because I say one's uncommon,\ndoesn't mean don't use it.\n\n392\n00:20:22.225 --> 00:20:24.551\n&gt;&gt; [LAUGH]\n&gt;&gt; It's there, you can use it,\n\n393\n00:20:24.551 --> 00:20:26.560\nit's just not as common [LAUGH].\n\n394\n00:20:26.560 --> 00:20:29.430\nSo that's kind of the way\nI always look at it.\n\n395\n00:20:29.430 --> 00:20:30.093\n&gt;&gt; All right, so\n\n396\n00:20:30.093 --> 00:20:33.480\nif we want to take a look at this and\nwe want to see all the employees there.\n\n397\n00:20:33.480 --> 00:20:36.716\nWe are going to go ahead and use the outer\njoin for that particular scenario?\n\n398\n00:20:36.716 --> 00:20:41.930\n&gt;&gt; Right, so what I just showed\nyou was a left outer join.\n\n399\n00:20:41.930 --> 00:20:43.579\nAnd I showed you a full outer join,\nbut again,\n\n400\n00:20:43.579 --> 00:20:44.988\nit really didn't look any different.\n\n401\n00:20:44.988 --> 00:20:48.560\nSo we've kinda seen those, so let's\ntake a look at a right outer join, okay?\n\n402\n00:20:48.560 --> 00:20:49.062\n&gt;&gt; Okay [LAUGH].\n\n403\n00:20:49.062 --> 00:20:50.894\n&gt;&gt; If I were to do a right outer join,\n\n404\n00:20:50.894 --> 00:20:55.018\nit's kind of flipping that scenario\naround and saying, the table I have on\n\n405\n00:20:55.018 --> 00:20:59.860\nthe left has a minimal sets of records or\na certain amount that I know is accurate.\n\n406\n00:20:59.860 --> 00:21:03.510\nAnd the table on the right has one's\nthat might not be matching up.\n\n407\n00:21:03.510 --> 00:21:06.093\nWell, I can't use the same query,\ncuz that's just not gonna match up, so\n\n408\n00:21:06.093 --> 00:21:07.203\nlet me use a different one here.\n\n409\n00:21:07.203 --> 00:21:10.190\nI've got a couple of\ntables buried away that-\n\n410\n00:21:10.190 --> 00:21:11.085\n&gt;&gt; You're holding out on us.\n\n411\n00:21:11.085 --> 00:21:11.660\n&gt;&gt; Hm?\n\n412\n00:21:11.660 --> 00:21:12.734\n&gt;&gt; You're holding out [LAUGH].\n\n413\n00:21:12.734 --> 00:21:14.554\n&gt;&gt; I know [LAUGH].\nIf you ever get bored and\n\n414\n00:21:14.554 --> 00:21:19.173\nwanna poke around the AdventureWorks\ndatabase that Microsoft provides as\n\n415\n00:21:19.173 --> 00:21:22.116\na sample,\nthere is a ton of information there.\n\n416\n00:21:22.116 --> 00:21:25.600\nYou can simulate darn near anything\nwith it, it's a great test database.\n\n417\n00:21:25.600 --> 00:21:27.223\nAnyhow, so I do have two tables.\n\n418\n00:21:27.223 --> 00:21:30.140\nLet me just kinda show them to you so\nyou know what they are.\n\n419\n00:21:30.140 --> 00:21:36.344\nFirst off, I've got a table called\nsales.salesperson, all right?\n\n420\n00:21:36.344 --> 00:21:39.983\nNow I've got employees,\n290 of them apparently, but\n\n421\n00:21:39.983 --> 00:21:42.430\nnot all of them are sales people.\n\n422\n00:21:42.430 --> 00:21:45.640\nSo if they're a sales person,\nthey have an entry in this table.\n\n423\n00:21:45.640 --> 00:21:47.959\nAnd so if I pull that list up,\nI can see a list.\n\n424\n00:21:47.959 --> 00:21:52.400\nAnd you'll recognize one of the columns,\nBusinessEntityID, right?\n\n425\n00:21:52.400 --> 00:21:56.610\nI could match that BusinessEntityID\nup with my person.person table and\n\n426\n00:21:56.610 --> 00:21:58.300\nfigure out what their first name and\nlast name is.\n\n427\n00:21:58.300 --> 00:22:00.984\nOr match it up with\nHumanResources.employee, and\n\n428\n00:22:00.984 --> 00:22:03.365\nfind out what their hire date and\njob title is.\n\n429\n00:22:03.365 --> 00:22:07.252\nBut here is sales.salesperson,\nits got their BusinessEntityID,\n\n430\n00:22:07.252 --> 00:22:11.540\nit's got what territory they're\nassigned to, what their sales quota is,\n\n431\n00:22:11.540 --> 00:22:15.570\nwhat their commission percentage and\nso on, the salesy kind of stuff.\n\n432\n00:22:15.570 --> 00:22:18.100\nI don't need this information\non all of my employees,\n\n433\n00:22:18.100 --> 00:22:20.220\nI only need it on salespeople, right?\n\n434\n00:22:20.220 --> 00:22:23.550\nWell, notice that TerritoryID,\nwhere are they selling?\n\n435\n00:22:23.550 --> 00:22:24.830\nWhere do they work?\n\n436\n00:22:24.830 --> 00:22:28.402\nAnd on most of them,\nthey've got a TerritoryID listed, but\n\n437\n00:22:28.402 --> 00:22:30.090\nnot all of them, right?\n\n438\n00:22:30.090 --> 00:22:32.200\nHere's one who doesn't have a TerritoryID.\n\n439\n00:22:32.200 --> 00:22:35.371\nWhoever this is, employee,\nI don't think I'll look up who 274 was.\n\n440\n00:22:35.371 --> 00:22:36.805\n&gt;&gt; It's because they don't\nget any commission, so\n\n441\n00:22:36.805 --> 00:22:37.873\nthey're not even worried about it.\n\n442\n00:22:37.873 --> 00:22:41.289\n&gt;&gt; Well, that's a good point, and\napparently they're flat rate sales,\n\n443\n00:22:41.289 --> 00:22:43.400\nwho knows what their story is, right?\n\n444\n00:22:43.400 --> 00:22:46.283\nBut they are somebody who's\nmissing those entries, right?\n\n445\n00:22:46.283 --> 00:22:53.530\nNow that TerritoryID is just a number,\nright?\n\n446\n00:22:53.530 --> 00:22:57.300\nAnd I've got another table\nthat maps up to that.\n\n447\n00:22:57.300 --> 00:23:01.505\nIf I get in the right sport here I can do\n\n448\n00:23:01.505 --> 00:23:06.415\na SELECT * FROM Sales.SalesTerritory.\n\n449\n00:23:06.415 --> 00:23:11.332\nAnd that one, if I pull it up,\nit shows me my territories, and\n\n450\n00:23:11.332 --> 00:23:14.656\nhere's the territory numbers, right?\n\n451\n00:23:14.656 --> 00:23:17.960\nI've got territories 1 through 10 and\nthat's it, there's only 10,\n\n452\n00:23:17.960 --> 00:23:19.468\nthere's no more rows after that.\n\n453\n00:23:19.468 --> 00:23:22.450\nAnd each one is completely filled in,\nright?\n\n454\n00:23:22.450 --> 00:23:25.448\nI've got the name of the territory,\nthe country and\n\n455\n00:23:25.448 --> 00:23:27.916\nregion code, the group and so on, right?\n\n456\n00:23:27.916 --> 00:23:33.190\nNotice that there's nothing in here that\ntalks about who the salesperson is, right?\n\n457\n00:23:33.190 --> 00:23:35.990\nI don't have a salesperson ID mapped here,\nand\n\n458\n00:23:35.990 --> 00:23:39.913\nthat's because I might have 50\nsalespeople tied to Northwest.\n\n459\n00:23:39.913 --> 00:23:41.375\nI might have 50 tied to Northeast and so\n\n460\n00:23:41.375 --> 00:23:43.182\non, so\nit doesn't make sense to track that here.\n\n461\n00:23:43.182 --> 00:23:48.051\nWe just have a TerritoryID, and\non each salesperson we have a TerritoryID.\n\n462\n00:23:48.051 --> 00:23:50.480\nSo I might wanna join those together,\nright?\n\n463\n00:23:50.480 --> 00:23:55.128\nSo I can join these to figure out which\nterritory each salesperson is in.\n\n464\n00:23:55.128 --> 00:24:00.830\nNow if I put the territory\nas the left table, right.\n\n465\n00:24:00.830 --> 00:24:03.860\nWell, if it's the left table,\nit's got all its information.\n\n466\n00:24:03.860 --> 00:24:07.080\nAnd I should have all my sales\npeople represented here.\n\n467\n00:24:07.080 --> 00:24:11.380\nBut what if one of sales\npeople has a territory of 11?\n\n468\n00:24:11.380 --> 00:24:12.566\nThat's not in this table, right?\n\n469\n00:24:12.566 --> 00:24:14.160\nIt's a territory that doesn't exist.\n\n470\n00:24:14.160 --> 00:24:16.686\nMaybe it's a mistake,\nmaybe I just haven't made it yet, right?\n\n471\n00:24:16.686 --> 00:24:20.720\nOr vice versa, I might have sales people\nwithout a territory, and I know I do.\n\n472\n00:24:20.720 --> 00:24:23.747\nSo if they don't match, I need to see\nthat to be able to find it, all right.\n\n473\n00:24:23.747 --> 00:24:29.261\nSo when I do a join here, right, let me go\nahead and write a query that does this.\n\n474\n00:24:29.261 --> 00:24:32.355\nSo I'm gonna say select star,\nor not, not star.\n\n475\n00:24:32.355 --> 00:24:34.152\nI'm gonna do a couple of columns.\n\n476\n00:24:34.152 --> 00:24:37.323\nI'm gonna say a star for now, just so\nI could get my IntelliSense to help out.\n\n477\n00:24:37.323 --> 00:24:40.401\n&gt;&gt; Okay.\n&gt;&gt; And I'm gonna say that I'm pulling from\n\n478\n00:24:40.401 --> 00:24:44.670\nSales.SalesTerritory, and\nI'm gonna shorten that for me,\n\n479\n00:24:44.670 --> 00:24:48.780\nI'll just do AS t, so\nI don't have to type it all out.\n\n480\n00:24:48.780 --> 00:24:53.770\nAnd I'm gonna do a JOIN,\nI'll just do a regular join to start with,\n\n481\n00:24:53.770 --> 00:24:58.063\nagainst Sales.SalesPerson,\nand I'll do that as p or s,\n\n482\n00:24:58.063 --> 00:25:01.679\nwhatever, but\nwhatever it is you like, right?\n\n483\n00:25:01.679 --> 00:25:04.320\nSo that's what I'll do on that one.\n\n484\n00:25:04.320 --> 00:25:07.240\nAnd then I'm gonna tie\nthe values together.\n\n485\n00:25:07.240 --> 00:25:11.439\nAnd I'll tie them together by saying\n\n486\n00:25:11.439 --> 00:25:16.727\nt.TerritoryID=s.TerritoryID, right?\n\n487\n00:25:16.727 --> 00:25:17.664\nThat's how they map together.\n\n488\n00:25:17.664 --> 00:25:21.480\nNow, I don't actually want every column.\n\n489\n00:25:21.480 --> 00:25:24.235\nSo I'm gonna shorten that up and\n\n490\n00:25:24.235 --> 00:25:30.470\nI'm gonna pull the BusinessEntityID,\nand the territory name.\n\n491\n00:25:30.470 --> 00:25:34.850\nSo I'm gonna see the BusinessEntityID,\nthe employee number for that person, and\n\n492\n00:25:34.850 --> 00:25:37.440\nthen what territory\nthey've been assigned to.\n\n493\n00:25:37.440 --> 00:25:41.970\nOkay, now in a normal join,\nI'm only gonna see the matches, right?\n\n494\n00:25:41.970 --> 00:25:45.300\nSo I know, you know, I should've paid\nattention to how many sales people I had.\n\n495\n00:25:45.300 --> 00:25:49.190\nI didn't actually see that,\nso let's redo that query.\n\n496\n00:25:49.190 --> 00:25:50.630\nIf I do a SELECT star-\n&gt;&gt; Yeah,\n\n497\n00:25:50.630 --> 00:25:53.710\nwe know we can't count on Cherokee to\nprovide that accurate information.\n\n498\n00:25:53.710 --> 00:25:54.511\n&gt;&gt; I know, and I'm not any better.\n\n499\n00:25:54.511 --> 00:25:55.931\n&gt;&gt; [LAUGH]\n&gt;&gt; So let's go in, and\n\n500\n00:25:55.931 --> 00:25:58.030\nI'm just gonna pull that up real quick.\n\n501\n00:25:58.030 --> 00:25:59.869\nSo I'll just pull that, in real life land,\n\n502\n00:25:59.869 --> 00:26:03.202\nthere's a function I can use called count,\nthat would just give me the number,\n\n503\n00:26:03.202 --> 00:26:06.721\nbut we haven't learned functions in this\nseries yet, so I'm holding off on that.\n\n504\n00:26:06.721 --> 00:26:09.420\nSo if I just do a straight\nup select on that one,\n\n505\n00:26:09.420 --> 00:26:11.716\nI can see that I have 17 sales people.\n\n506\n00:26:11.716 --> 00:26:12.651\n&gt;&gt; Okay.\n&gt;&gt; 17 rows,\n\n507\n00:26:12.651 --> 00:26:15.183\nthat's much easier to manage number,\nright?\n\n508\n00:26:15.183 --> 00:26:16.347\n&gt;&gt; Yeah [LAUGH] I think I can handle this.\n\n509\n00:26:16.347 --> 00:26:18.755\n[LAUGH]\n&gt;&gt; Okay, So I got 17 sales people, and\n\n510\n00:26:18.755 --> 00:26:21.010\nI can actually put that\nlittle note right here.\n\n511\n00:26:21.010 --> 00:26:27.071\nI've got 17 SalesPeople, and\nI've got 10, that didn't work.\n\n512\n00:26:27.071 --> 00:26:30.560\nAnd then I've got 10 Territories.\n\n513\n00:26:30.560 --> 00:26:33.800\nRight, so that's what I'm dealing with.\n\n514\n00:26:33.800 --> 00:26:37.512\nNow, if I come and run this query,\nit's doing a regular join, right?\n\n515\n00:26:37.512 --> 00:26:41.871\nAnd so I see my BusinessEntityID is being\nmatched up to what territory they're in,\n\n516\n00:26:41.871 --> 00:26:43.590\nthat's working great, okay.\n\n517\n00:26:43.590 --> 00:26:47.094\nBut if I look all the way down here,\nI can see that I only have 14 rows.\n\n518\n00:26:47.094 --> 00:26:47.713\n&gt;&gt; Yeah, so.\n\n519\n00:26:47.713 --> 00:26:53.720\n&gt;&gt; There were three sales people that\ndidn't have a territory attachment.\n\n520\n00:26:53.720 --> 00:26:59.880\nNow, when I defined it,\nI put t.Territory on the left,\n\n521\n00:26:59.880 --> 00:27:02.400\nand I put s.TerritoryID on the right.\n\n522\n00:27:02.400 --> 00:27:07.070\nSo the SalesPerson is my right table,\nnot my left table.\n\n523\n00:27:07.070 --> 00:27:11.094\nSo in this case,\nif I were to do a LEFT OUTER JOIN,\n\n524\n00:27:11.094 --> 00:27:14.760\nit's not gonna give me what I want, right?\n\n525\n00:27:14.760 --> 00:27:19.450\nBecause on the left table, I really didn't\nhave anything left out, or maybe I did.\n\n526\n00:27:19.450 --> 00:27:23.095\nMaybe I have some territories with\nno sales people attached, right?\n\n527\n00:27:23.095 --> 00:27:25.555\nSo if I run this query,\nI'll find that out.\n\n528\n00:27:25.555 --> 00:27:29.403\nAnd when I look, I can see that\nI actually got back 14 rows,\n\n529\n00:27:29.403 --> 00:27:34.345\ndown in the bottom corner there,\nI can see it, where I got 14 rows back.\n\n530\n00:27:34.345 --> 00:27:36.395\nSo I know that I got it all.\n\n531\n00:27:36.395 --> 00:27:41.055\nAnd then, if change that, I'll find\nout that I actually didn't get it all.\n\n532\n00:27:41.055 --> 00:27:45.252\nThat if I do a RIGHT OUTER JOIN,\nand I spell right the right way,\n\n533\n00:27:45.252 --> 00:27:50.245\nnow when I run it, I can look down here\nand I see, I got BusinessEntityID and\n\n534\n00:27:50.245 --> 00:27:55.580\nthen a name attached to it, and I can\nsee that 274 had no territory attached.\n\n535\n00:27:55.580 --> 00:27:58.104\nBut I see everybody else that\nhad a territory as well, and\n\n536\n00:27:58.104 --> 00:27:59.640\nthere were two more that didn't.\n\n537\n00:27:59.640 --> 00:28:01.980\nSo let me scroll down a bit here.\n\n538\n00:28:01.980 --> 00:28:04.122\nAnd we should see, there they are,\ntwo more, 285 and 287,\n\n539\n00:28:04.122 --> 00:28:04.972\nthey both don't have it.\n\n540\n00:28:04.972 --> 00:28:05.987\nOkay, now again,\n\n541\n00:28:05.987 --> 00:28:09.730\nI could have just straight up queried\nthe sales person table and said,\n\n542\n00:28:09.730 --> 00:28:14.780\ngive me anybody with a null value for the\nterritory, if I just wanted to see that.\n\n543\n00:28:14.780 --> 00:28:17.960\nBut if I wanted to see people that had\na territory right alongside the people\n\n544\n00:28:17.960 --> 00:28:20.340\nwithout it, that's where I need the join.\n\n545\n00:28:20.340 --> 00:28:22.725\nAnd in this case,\nI needed a right outer join.\n\n546\n00:28:22.725 --> 00:28:24.881\n&gt;&gt; Would you mind running\na full outer join?\n\n547\n00:28:24.881 --> 00:28:25.559\n&gt;&gt; Yeah.\n&gt;&gt; Just so\n\n548\n00:28:25.559 --> 00:28:28.266\nI can kind of mentally put\nthese things together?\n\n549\n00:28:28.266 --> 00:28:29.140\n[LAUGH]\n&gt;&gt; Sure.\n\n550\n00:28:29.140 --> 00:28:30.700\nJust like in the last example,\n\n551\n00:28:30.700 --> 00:28:34.340\nthere's not really gonna be a difference\nin this case between a full and a right.\n\n552\n00:28:34.340 --> 00:28:36.574\n&gt;&gt; Okay.\n&gt;&gt; Because the left table is my\n\n553\n00:28:36.574 --> 00:28:39.780\nterritories, and I 10 ten territories.\n\n554\n00:28:39.780 --> 00:28:43.390\nSo unless I have an employee\nwith a bad territory number,\n\n555\n00:28:43.390 --> 00:28:46.090\nthere's nothing extra in the left\ntable that this will add in.\n\n556\n00:28:46.090 --> 00:28:47.920\nSo we shouldn't see a difference.\n\n557\n00:28:47.920 --> 00:28:48.982\nI'm using my technical word of shouldn't.\n\n558\n00:28:48.982 --> 00:28:50.229\n&gt;&gt; [LAUGH] yeah [LAUGH].\n&gt;&gt; That way, if it does,\n\n559\n00:28:50.229 --> 00:28:51.400\nit's not my fault.\n\n560\n00:28:51.400 --> 00:28:55.060\nBut when I run it, we should get\nthe same basic information back.\n\n561\n00:28:55.060 --> 00:28:58.210\nAnd as I look at it here, so\nI'm now doing a FULL OUTER JOIN.\n\n562\n00:28:58.210 --> 00:28:59.520\nAnd [CROSSTALK] as I look at my entries.\n\n563\n00:28:59.520 --> 00:29:00.205\n&gt;&gt; I don't see the nulls,\nunless they put them at the bottom.\n\n564\n00:29:00.205 --> 00:29:05.020\n&gt;&gt; You know, it looks like it did,\nso let's go over here and yeah.\n\n565\n00:29:05.020 --> 00:29:05.520\n&gt;&gt; Okay.\n&gt;&gt; I must have-\n\n566\n00:29:05.520 --> 00:29:06.267\n&gt;&gt; Sort it.\n\n567\n00:29:06.267 --> 00:29:07.827\n&gt;&gt; Sometimes you hit an index,\n\n568\n00:29:07.827 --> 00:29:11.142\nand I talked about indexes\na little bit in the first episode,\n\n569\n00:29:11.142 --> 00:29:15.630\nwhere if there's an index created on\nthe table, it puts it in a certain order.\n\n570\n00:29:15.630 --> 00:29:19.310\nSometimes SQL will look at it and say,\nwell, it would be faster to use the index.\n\n571\n00:29:19.310 --> 00:29:22.760\nAnd the index happens to already be\nalphabetized or sorted or whatever.\n\n572\n00:29:22.760 --> 00:29:26.080\nOther times, it'll look at it and\nit'll say, there's no index, so\n\n573\n00:29:26.080 --> 00:29:29.311\nI just gotta go and look at the table and\nyou get a table or something.\n\n574\n00:29:29.311 --> 00:29:32.615\nIt might have been that or it might also\njust be the fact that we're pulling from\n\n575\n00:29:32.615 --> 00:29:36.045\ntwo different tables and there's nulls\nin each, so how does it organize those.\n\n576\n00:29:36.045 --> 00:29:37.275\nAnd so it lumps them down at the bottom,\nbut they are there.\n\n577\n00:29:37.275 --> 00:29:39.532\n&gt;&gt; [CROSSTALK] Does the yellow\nhave any tie in there?\n\n578\n00:29:39.532 --> 00:29:43.830\nI think you might have mentioned that\nbefore for the actual sorting there.\n\n579\n00:29:43.830 --> 00:29:46.544\n&gt;&gt; So null is special, and\nthat's why it's yellow.\n\n580\n00:29:46.544 --> 00:29:47.997\n&gt;&gt; Okay [LAUGH].\n&gt;&gt; Null, technically,\n\n581\n00:29:47.997 --> 00:29:49.325\nis absolutely nothing.\n\n582\n00:29:49.325 --> 00:29:52.160\n&gt;&gt; Right.\n&gt;&gt; So how do you sort absolutely nothing?\n\n583\n00:29:52.160 --> 00:29:53.050\nIt doesn't come before.\n\n584\n00:29:53.050 --> 00:29:53.710\nIt doesn't come after.\n\n585\n00:29:53.710 --> 00:29:55.060\nIt really can't be sorted, right?\n\n586\n00:29:55.060 --> 00:29:58.696\nAnd so it shows it yellow here, just it's\nkind of like a warning to let us know.\n\n587\n00:29:58.696 --> 00:29:59.580\n&gt;&gt; Okay.\n\n588\n00:29:59.580 --> 00:30:01.720\n&gt;&gt; I'm gonna write NULL in there, but\n\n589\n00:30:01.720 --> 00:30:06.240\nit's not actually the letters NULL,\nit's actually nothing.\n\n590\n00:30:06.240 --> 00:30:09.120\nI could create a territory and\ncall it NULL, right,\n\n591\n00:30:09.120 --> 00:30:12.172\nand then it will show up as white\nin here because it's just the text.\n\n592\n00:30:12.172 --> 00:30:14.545\n&gt;&gt; Okay.\n&gt;&gt; N-U-L-L, so that's why it's yellow,\n\n593\n00:30:14.545 --> 00:30:17.118\nis to give me that\ndifferentiation to know that,\n\n594\n00:30:17.118 --> 00:30:19.900\nthis is actually empty\nversus just making it empty.\n\n595\n00:30:19.900 --> 00:30:24.546\nBecause they can't make it truly empty\ncuz then we wouldn't be able to tell it\n\n596\n00:30:24.546 --> 00:30:25.521\napart-\n&gt;&gt; Have that in.\n\n597\n00:30:25.521 --> 00:30:26.627\n&gt;&gt; in space.\n&gt;&gt; Okay.\n\n598\n00:30:26.627 --> 00:30:29.617\n&gt;&gt; Like I could have a solid, just have\nspace in it, and it would look like null,\n\n599\n00:30:29.617 --> 00:30:30.270\nwhen it isn't.\n\n600\n00:30:30.270 --> 00:30:33.255\nSo it's really,\nnull is kind of a special thing.\n\n601\n00:30:33.255 --> 00:30:37.570\nWe're gonna talk about it in some of\nthe other episodes too, because it's\n\n602\n00:30:37.570 --> 00:30:42.850\nreally the absence of any data and that\nis a lot different than just being blank.\n\n603\n00:30:42.850 --> 00:30:43.730\n&gt;&gt; Okay.\n\n604\n00:30:43.730 --> 00:30:46.730\n&gt;&gt; But right there we get a chance\nto see that right outer join and\n\n605\n00:30:46.730 --> 00:30:48.330\nhow that one functions.\n\n606\n00:30:48.330 --> 00:30:50.830\nAt the end of the day, a right outer join,\n\n607\n00:30:50.830 --> 00:30:55.470\na left outer join, a full outer join,\nthey function the same way.\n\n608\n00:30:55.470 --> 00:30:56.661\nYou're just making a choice.\n\n609\n00:30:56.661 --> 00:31:01.315\nYou're making a choice between,\ndo I want all of the unmatching rows?\n\n610\n00:31:01.315 --> 00:31:02.746\nOr just the unmatching rows from the left?\n\n611\n00:31:02.746 --> 00:31:06.262\nOr just the unmatching rows from\nthe right and that's it, and\n\n612\n00:31:06.262 --> 00:31:10.060\nit's based on your needs which\none of these you're gonna choose.\n\n613\n00:31:10.060 --> 00:31:12.130\nSo if you don't need any one of them\nat all, in which case you'll say,\n\n614\n00:31:12.130 --> 00:31:15.320\nforget it I'm sticking with an INNER JOIN,\nI just get the matches that's got the data\n\n615\n00:31:15.320 --> 00:31:19.450\nthat I wanted, and you'll find that often\ntimes that's exactly what you want.\n\n616\n00:31:19.450 --> 00:31:21.690\n&gt;&gt; All right, we're getting\nclose on time for this show, but\n\n617\n00:31:21.690 --> 00:31:24.810\ndo you have any other surprises,\nany other types of joins that you'd like,\n\n618\n00:31:24.810 --> 00:31:26.512\nI mean this is like confession time, Don.\n\n619\n00:31:26.512 --> 00:31:28.100\n&gt;&gt; [LAUGH]\n&gt;&gt; [LAUGH]\n\n620\n00:31:28.100 --> 00:31:31.360\n&gt;&gt; I promise to show multiple joins.\n\n621\n00:31:31.360 --> 00:31:33.430\nYou asked about doing\nmore than two tables.\n\n622\n00:31:33.430 --> 00:31:35.215\n&gt;&gt; Yeah.\n&gt;&gt; And we've run out of time, so.\n\n623\n00:31:35.215 --> 00:31:37.108\n&gt;&gt; [LAUGH]\n&gt;&gt; Would it break the rules too bad if we\n\n624\n00:31:37.108 --> 00:31:37.791\ndid part three?\n\n625\n00:31:39.070 --> 00:31:39.860\n&gt;&gt; Well, you know.\n\n626\n00:31:39.860 --> 00:31:41.154\n&gt;&gt; Let's do a part three.\n\n627\n00:31:41.154 --> 00:31:43.570\n&gt;&gt; [LAUGH]\n&gt;&gt; I'll make an executive decision here.\n\n628\n00:31:43.570 --> 00:31:45.970\nWe'll do a part three and\nin part three, I wanna show you, guys,\n\n629\n00:31:45.970 --> 00:31:48.680\ndoing multiple joins.\n\n630\n00:31:48.680 --> 00:31:50.260\nAnd I also wanna show you,\n\n631\n00:31:50.260 --> 00:31:53.570\nthis is where we really kick\nthe stops off, nested joins.\n\n632\n00:31:53.570 --> 00:31:54.348\n&gt;&gt; [LAUGH] Nested joins okay.\n&gt;&gt; Nested joins, yup.\n\n633\n00:31:54.348 --> 00:31:58.772\nWhere you have a join where one of\nthe tables you're pulling from is\n\n634\n00:31:58.772 --> 00:32:01.310\nactually the result of another join.\n\n635\n00:32:01.310 --> 00:32:01.810\nIt's really-\n&gt;&gt; Good.\n\n636\n00:32:01.810 --> 00:32:04.794\n[LAUGH] &gt;&gt; It's kind of like Inception,\nif you've seen that movie.\n\n637\n00:32:04.794 --> 00:32:05.473\nYou know,\n\n638\n00:32:05.473 --> 00:32:06.914\nthe dream in a dream?\n&gt;&gt; [LAUGH]\n\n639\n00:32:06.914 --> 00:32:09.514\n&gt;&gt; But we'll get a chance to see that.\n\n640\n00:32:09.514 --> 00:32:12.840\nThose, again, are far less used, and\n\n641\n00:32:12.840 --> 00:32:14.520\nmultiple joins,\nthat's actually pretty common.\n\n642\n00:32:14.520 --> 00:32:16.950\nBut nested joins are less common, and\n\n643\n00:32:16.950 --> 00:32:20.660\nwe'll see why when we get to the derived\ntable section of this course.\n\n644\n00:32:20.660 --> 00:32:23.700\nThat derived tables usually\nreplace our need for that.\n\n645\n00:32:23.700 --> 00:32:26.142\nBut it is something you incur, so\nwe'll take a look at those in part three.\n\n646\n00:32:26.142 --> 00:32:27.370\n&gt;&gt; All right, sounds like a plan.\n\n647\n00:32:27.370 --> 00:32:28.270\nSo you don't want to miss that,\n\n648\n00:32:28.270 --> 00:32:32.911\nyou definitely want to join us for\nsome Twilight Zone in the next episode.\n\n649\n00:32:32.911 --> 00:32:34.891\n&gt;&gt; [LAUGH]\n&gt;&gt; But for this show we'll sign out.\n\n650\n00:32:34.891 --> 00:32:36.541\nI've been your host Cherokee Boose.\n\n651\n00:32:36.541 --> 00:32:37.366\n&gt;&gt; And I'm Don Pezet.\n\n652\n00:32:37.366 --> 00:32:39.074\n&gt;&gt; See you next time here at ITProTV.\n\n653\n00:32:39.074 --> 00:32:46.238\n[MUSIC]\n\n654\n00:32:46.238 --> 00:32:50.572\n&gt;&gt; Thank you for watching ITPRO.TV.\n\n",
          "vimeoId": "243363606"
        },
        {
          "description": "In this episode, Don wraps up discussing how to use the JOIN clause to combine results from multiple tables. He builds on part 1 and part 2 by explaining how multiple JOIN clauses can be nested together and that you can even perform a JOIN between a table and itself.",
          "length": "2125",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-3-combining_results_with_join_pt3-111717.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-3-combining_results_with_join_pt3-111717-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-1-3-3-combining_results_with_join_pt3-111717-sm.jpg",
          "title": "Combining Results with JOIN Part 3",
          "transcript": "",
          "vimeoId": "243683674"
        }
      ],
      "title": "Querying Data with T-SQL"
    },
    {
      "episodes": [
        {
          "description": "In this episode, Don explains how to add data to a table in SQL by using the INSERT statement. He demonstrates adding a single record, and explains a few methods for adding multiple records at the same time.",
          "length": "1204",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-1-1-adding_data_with_insert-111717-PGM.00_25_36_11.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-1-1-adding_data_with_insert-111717-PGM.00_25_36_11.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-1-1-adding_data_with_insert-111717-PGM.00_25_36_11.Still001-sm.jpg",
          "title": "Adding Data with INSERT",
          "transcript": "",
          "vimeoId": "243683283"
        },
        {
          "description": "In this episode, Don explains how to modify data in a SQL database table by using the UPDATE statement. He demonstrates modifying a single record, and explains a few methods for modifying multiple records at the same time. He ends the show by explaining a common mistake that can lead to data loss.",
          "length": "1193",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-2-1-changing_data_with_update-111717-PGM.00_27_57_01.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-2-1-changing_data_with_update-111717-PGM.00_27_57_01.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-2-1-changing_data_with_update-111717-PGM.00_27_57_01.Still001-sm.jpg",
          "title": "Changing Data with UPDATE",
          "transcript": "",
          "vimeoId": "243683479"
        },
        {
          "description": "In this episode, Don explains how to remove data from a SQL database table by using the DELETE statement. First, he demonstrates deleting a single value by using the UPDATE statement. Next, he demonstrates deleting a single record, and explains a few methods for deleting multiple records at the same time. He ends the show by explaining a common mistake that can lead to data loss.",
          "length": "1117",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-3-1-removing_data_with_delete-112017-PGM.00_18_24_08.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-3-1-removing_data_with_delete-112017-PGM.00_18_24_08.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-3-1-removing_data_with_delete-112017-PGM.00_18_24_08.Still001-sm.jpg",
          "title": "Removing Data with DELETE",
          "transcript": "",
          "vimeoId": "243915263"
        },
        {
          "description": "In this episode, Don introduces the viewers to the OUTPUT clause. He demonstrates how to use the OUTPUT clause to get better result feedback from SQL server, and he also demonstrates how the OUTPUT clause can be used for backup and auditing purposes.",
          "length": "2075",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-4-1-recording_changes_with_output-112017-PGM.00_34_22_21.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-4-1-recording_changes_with_output-112017-PGM.00_34_22_21.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-2-4-1-recording_changes_with_output-112017-PGM.00_34_22_21.Still001-sm.jpg",
          "title": "Recording Changes with OUTPUT",
          "transcript": "",
          "vimeoId": "243914951"
        }
      ],
      "title": "Modifying Data with T-SQL"
    },
    {
      "episodes": [
        {
          "description": "In this episode, Don introduces the viewers to SQL functions. He begins by demonstrating some simple functions and explains how to use more advanced functions that require input parameters.",
          "length": "1649",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-1-1-querying_data_with_functions-112817-PGM.00_28_20_21.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-1-1-querying_data_with_functions-112817-PGM.00_28_20_21.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-1-1-querying_data_with_functions-112817-PGM.00_28_20_21.Still001-sm.jpg",
          "title": "Querying Data with Functions",
          "transcript": "﻿WEBVTT\r\n\r\n1\r\n00:00:00.880 --> 00:00:05.047\r\n<v ->Welcome to ITPro.TV, I'm your host (chatter).</v>\r\n\r\n2\r\n00:00:08.906 --> 00:00:12.544 line:15% \r\n<v Announcer>You're watching ITPro.TV.</v>\r\n\r\n3\r\n00:00:12.544 --> 00:00:14.546 line:15% \r\n<v ->All right, greetings everyone, and welcome to</v>\r\n\r\n4\r\n00:00:14.546 --> 00:00:17.067 line:15% \r\nanother great episode of ITPro.TV.\r\n\r\n5\r\n00:00:17.067 --> 00:00:18.520 line:15% \r\nI'm your host, Daniel Lowrie,\r\n\r\n6\r\n00:00:18.520 --> 00:00:21.203 line:15% \r\nand in today's episode, well we're coming back at you\r\n\r\n7\r\n00:00:21.203 --> 00:00:23.750 line:15% \r\nwith more in our querying data with Transact SQL.\r\n\r\n8\r\n00:00:23.750 --> 00:00:25.692 line:15% \r\nJoining us back in the studio yet again,\r\n\r\n9\r\n00:00:25.692 --> 00:00:28.068\r\nour partner in crime, Mr. Don Pezet.\r\n\r\n10\r\n00:00:28.068 --> 00:00:29.304\r\nDon, welcome, how's it going today?\r\n\r\n11\r\n00:00:29.304 --> 00:00:31.003\r\n<v ->It is going great, Daniel, and I am</v>\r\n\r\n12\r\n00:00:31.003 --> 00:00:32.697\r\nreally excited about this episode,\r\n\r\n13\r\n00:00:32.697 --> 00:00:34.332 line:15% \r\nbecause we've filmed quite a bit\r\n\r\n14\r\n00:00:34.332 --> 00:00:35.590 line:15% \r\nof Transact SQL at this point,\r\n\r\n15\r\n00:00:35.590 --> 00:00:37.389 line:15% \r\nand I've kinda been doing the shows\r\n\r\n16\r\n00:00:37.389 --> 00:00:39.732 line:15% \r\nwith one arm tied behind my back\r\n\r\n17\r\n00:00:39.732 --> 00:00:43.816\r\nbecause I've wanted to use functions so many times,\r\n\r\n18\r\n00:00:43.816 --> 00:00:45.348\r\nbut we haven't learned them yet\r\n\r\n19\r\n00:00:45.348 --> 00:00:46.899\r\nso I've been holding off and trying\r\n\r\n20\r\n00:00:46.899 --> 00:00:48.785\r\nnot to use function where I could,\r\n\r\n21\r\n00:00:48.785 --> 00:00:51.305\r\nbut in this episode, we're finally going,\r\n\r\n22\r\n00:00:51.305 --> 00:00:53.376\r\nI probably should put this earlier in the series,\r\n\r\n23\r\n00:00:53.376 --> 00:00:55.716\r\nwe're gonna learn what functions are,\r\n\r\n24\r\n00:00:55.716 --> 00:00:57.987\r\nhow we use them, and how incredibly useful they are,\r\n\r\n25\r\n00:00:57.987 --> 00:01:00.435\r\nand then from here on out, I can guarantee you\r\n\r\n26\r\n00:01:00.435 --> 00:01:02.700\r\nwe'll use at least one function in every single episode\r\n\r\n27\r\n00:01:02.700 --> 00:01:04.572\r\n'cause they're so incredibly useful,\r\n\r\n28\r\n00:01:04.572 --> 00:01:06.246\r\nbut this is the episode where we finally get\r\n\r\n29\r\n00:01:06.246 --> 00:01:08.028\r\nto break that ice, see a function,\r\n\r\n30\r\n00:01:08.028 --> 00:01:09.939\r\nand figure out exactly what the heck they do.\r\n\r\n31\r\n00:01:09.939 --> 00:01:13.033\r\n<v ->Well, Don, since this is our first foray into functions</v>\r\n\r\n32\r\n00:01:13.033 --> 00:01:14.995\r\nI guess that's a great place for us to start,\r\n\r\n33\r\n00:01:14.995 --> 00:01:16.760\r\nat the very beginning of the book,\r\n\r\n34\r\n00:01:16.760 --> 00:01:18.267\r\nwhat is a function and how does it work?\r\n\r\n35\r\n00:01:18.267 --> 00:01:19.908\r\n<v ->All right, so what a function is,</v>\r\n\r\n36\r\n00:01:19.908 --> 00:01:22.212\r\nis really, it's like a collection of logic.\r\n\r\n37\r\n00:01:22.212 --> 00:01:24.962\r\nWhen I query data out of a table,\r\n\r\n38\r\n00:01:26.931 --> 00:01:29.019\r\nI just get the data that's in the table,\r\n\r\n39\r\n00:01:29.019 --> 00:01:31.284\r\nwhatever data's in there, and in all our earlier episodes,\r\n\r\n40\r\n00:01:31.284 --> 00:01:34.131\r\nwe did select, and inserts, and updates,\r\n\r\n41\r\n00:01:34.131 --> 00:01:36.053\r\nand deletes and all that good stuff.\r\n\r\n42\r\n00:01:36.053 --> 00:01:38.307\r\nWe're just getting data from the table,\r\n\r\n43\r\n00:01:38.307 --> 00:01:39.944\r\nand looking at it, maybe delete it,\r\n\r\n44\r\n00:01:39.944 --> 00:01:43.078\r\nmaybe changing it, but just getting what's there.\r\n\r\n45\r\n00:01:43.078 --> 00:01:46.404\r\nBut sometimes, I don't want exactly what's there.\r\n\r\n46\r\n00:01:46.404 --> 00:01:48.819\r\nI want something that's a little bit different.\r\n\r\n47\r\n00:01:48.819 --> 00:01:52.902\r\nMaybe I've got a column that has hire dates in it,\r\n\r\n48\r\n00:01:52.902 --> 00:01:55.011\r\nand the date is in one format.\r\n\r\n49\r\n00:01:55.011 --> 00:01:57.080\r\nIt's not quite the format that I want it.\r\n\r\n50\r\n00:01:57.080 --> 00:01:59.220\r\nI want it in a different format.\r\n\r\n51\r\n00:01:59.220 --> 00:02:02.025\r\nAll right, well, with a function,\r\n\r\n52\r\n00:02:02.025 --> 00:02:03.882\r\nI can tell the server, hey, when you give me\r\n\r\n53\r\n00:02:03.882 --> 00:02:08.024\r\nthis date column, change it to present it a different way,\r\n\r\n54\r\n00:02:08.024 --> 00:02:10.040\r\nso it's formatted the right way.\r\n\r\n55\r\n00:02:10.040 --> 00:02:11.495\r\nThat little collection of logic,\r\n\r\n56\r\n00:02:11.495 --> 00:02:14.233\r\nthe instructions that say here's how you change it,\r\n\r\n57\r\n00:02:14.233 --> 00:02:15.440\r\nthat's a function.\r\n\r\n58\r\n00:02:15.440 --> 00:02:16.899\r\nAnd we can do it on the client's side,\r\n\r\n59\r\n00:02:16.899 --> 00:02:18.502\r\nso if you're got some application\r\n\r\n60\r\n00:02:18.502 --> 00:02:19.635\r\nthat your company's developed\r\n\r\n61\r\n00:02:19.635 --> 00:02:20.912\r\nthat's actually interacting with this database,\r\n\r\n62\r\n00:02:20.912 --> 00:02:22.606\r\nyou can do it there, but if you've got\r\n\r\n63\r\n00:02:22.606 --> 00:02:24.981\r\nseveral different clients, you're having to re-write\r\n\r\n64\r\n00:02:24.981 --> 00:02:26.689\r\nthat code over and over and over again\r\n\r\n65\r\n00:02:26.689 --> 00:02:28.131\r\nin all these different platforms.\r\n\r\n66\r\n00:02:28.131 --> 00:02:29.244\r\nWouldn't it be nice if the server\r\n\r\n67\r\n00:02:29.244 --> 00:02:31.260\r\ncould just do it for you?\r\n\r\n68\r\n00:02:31.260 --> 00:02:32.699\r\nAnd if the server does it for you,\r\n\r\n69\r\n00:02:32.699 --> 00:02:34.159\r\nthat means it can be cached in RAM,\r\n\r\n70\r\n00:02:34.159 --> 00:02:35.547\r\nand so if you have a bunch of people\r\n\r\n71\r\n00:02:35.547 --> 00:02:37.150\r\ndoing the same thing at the same time,\r\n\r\n72\r\n00:02:37.150 --> 00:02:38.532\r\nthe results are already cached,\r\n\r\n73\r\n00:02:38.532 --> 00:02:41.432\r\nit gets returned faster and it's much more efficient.\r\n\r\n74\r\n00:02:41.432 --> 00:02:46.078\r\nFunctions are a great way to be able to ask the server\r\n\r\n75\r\n00:02:46.078 --> 00:02:47.931\r\nto do that work for us and get the data\r\n\r\n76\r\n00:02:47.931 --> 00:02:49.731\r\nin the format that we want.\r\n\r\n77\r\n00:02:49.731 --> 00:02:51.275\r\nI used the example of converting date.\r\n\r\n78\r\n00:02:51.275 --> 00:02:53.652\r\nThat's just one example.\r\n\r\n79\r\n00:02:53.652 --> 00:02:55.923\r\nThere are tons and tons of functions,\r\n\r\n80\r\n00:02:55.923 --> 00:02:57.791\r\nand we'll get to see a couple of them\r\n\r\n81\r\n00:02:57.791 --> 00:02:59.198\r\nhere in this episode as we run through how they work\r\n\r\n82\r\n00:02:59.198 --> 00:03:00.493\r\nand what they do.\r\n\r\n83\r\n00:03:00.493 --> 00:03:03.638\r\nThe main thing is, the server does the work\r\n\r\n84\r\n00:03:03.638 --> 00:03:06.862\r\nso that all we see is we get a table back\r\n\r\n85\r\n00:03:06.862 --> 00:03:08.865\r\nor we get our data back, just like normal,\r\n\r\n86\r\n00:03:08.865 --> 00:03:10.862\r\nexcept it's now changed in some way,\r\n\r\n87\r\n00:03:10.862 --> 00:03:13.127\r\nchanged the way we requested it\r\n\r\n88\r\n00:03:13.127 --> 00:03:14.601\r\nto get the information back that we were looking for.\r\n\r\n89\r\n00:03:14.601 --> 00:03:16.256\r\n<v ->Well, Don, I can see why you were</v>\r\n\r\n90\r\n00:03:16.256 --> 00:03:18.129\r\nchomping at the bit so hard to start using the functions\r\n\r\n91\r\n00:03:18.129 --> 00:03:21.964\r\n'cause it seems like they give you a lot of functionality\r\n\r\n92\r\n00:03:21.964 --> 00:03:23.529\r\nthat you don't have to reinvent the wheel.\r\n\r\n93\r\n00:03:23.529 --> 00:03:25.311\r\nA lot of times, you just call to the functions\r\n\r\n94\r\n00:03:25.311 --> 00:03:26.356\r\nand let them do the work.\r\n\r\n95\r\n00:03:26.356 --> 00:03:27.258\r\n<v Don>Yeah.</v>\r\n\r\n96\r\n00:03:27.258 --> 00:03:28.347\r\n<v ->That being said, how do I do it?</v>\r\n\r\n97\r\n00:03:28.347 --> 00:03:29.446\r\nNow that you've sold me on it,\r\n\r\n98\r\n00:03:29.446 --> 00:03:31.678\r\njust shut up and take my money, it's fantastic,\r\n\r\n99\r\n00:03:31.678 --> 00:03:33.660\r\nI need these functions in my life,\r\n\r\n100\r\n00:03:33.660 --> 00:03:34.990\r\nhow do I make that work?\r\n\r\n101\r\n00:03:34.990 --> 00:03:36.843\r\nHow do I say I want to use this function?\r\n\r\n102\r\n00:03:36.843 --> 00:03:38.499\r\n<v ->The first thing we need to do</v>\r\n\r\n103\r\n00:03:38.499 --> 00:03:41.057\r\nis we need to find out if there is a function\r\n\r\n104\r\n00:03:41.057 --> 00:03:42.675\r\nthat does what we want.\r\n\r\n105\r\n00:03:42.675 --> 00:03:44.316\r\nBecause there's a bunch of functions\r\n\r\n106\r\n00:03:44.316 --> 00:03:47.844\r\nthat are included by default with Microsoft SQL Server,\r\n\r\n107\r\n00:03:47.844 --> 00:03:49.786\r\nbut sometimes they're not perfect.\r\n\r\n108\r\n00:03:49.786 --> 00:03:50.940\r\nThey're not exactly what we want.\r\n\r\n109\r\n00:03:50.940 --> 00:03:52.935\r\nWe're talking about a slightly more advanced logic.\r\n\r\n110\r\n00:03:52.935 --> 00:03:56.052\r\nYou might have personal needs or kinda different.\r\n\r\n111\r\n00:03:56.052 --> 00:03:58.788\r\nThe first thing I need to do is figure out\r\n\r\n112\r\n00:03:58.788 --> 00:04:01.270\r\nwhether the function I want exists,\r\n\r\n113\r\n00:04:01.270 --> 00:04:03.305\r\nthen once I know it exists, I need to figure out\r\n\r\n114\r\n00:04:03.305 --> 00:04:05.139\r\nhow the heck to use the thing.\r\n\r\n115\r\n00:04:05.139 --> 00:04:09.459\r\nWhen I use a function, it has certain instructions,\r\n\r\n116\r\n00:04:09.459 --> 00:04:11.081\r\ncertain things that you feed to it\r\n\r\n117\r\n00:04:11.081 --> 00:04:13.347\r\nto tell it what to do, and I've got to know\r\n\r\n118\r\n00:04:13.347 --> 00:04:14.643\r\nwhat data it's expecting.\r\n\r\n119\r\n00:04:14.643 --> 00:04:16.121\r\nI need to know what to feed it\r\n\r\n120\r\n00:04:16.121 --> 00:04:17.973\r\nin order for it to do what I want.\r\n\r\n121\r\n00:04:17.973 --> 00:04:21.723\r\nAs an example, let me use, guess we could use\r\n\r\n122\r\n00:04:22.563 --> 00:04:25.318\r\nany number of functions, but the one that I've been\r\n\r\n123\r\n00:04:25.318 --> 00:04:26.921\r\ndying to use is the COUNT function.\r\n\r\n124\r\n00:04:26.921 --> 00:04:30.825\r\nCOUNT is such a handy one, 'cause it takes a table\r\n\r\n125\r\n00:04:30.825 --> 00:04:32.988\r\nand it counts the number of values that are there.\r\n\r\n126\r\n00:04:32.988 --> 00:04:34.644\r\nEver time I've run a query in this show\r\n\r\n127\r\n00:04:34.644 --> 00:04:36.281\r\nand I wanted to see how many rows there were,\r\n\r\n128\r\n00:04:36.281 --> 00:04:38.244\r\nI've been scrolling down to the bottom right\r\n\r\n129\r\n00:04:38.244 --> 00:04:40.042\r\nof my query analyzer and I see it down there\r\n\r\n130\r\n00:04:40.042 --> 00:04:42.761\r\nkind of tucked away, but to do that,\r\n\r\n131\r\n00:04:42.761 --> 00:04:44.940\r\nI had to get a whole table back,\r\n\r\n132\r\n00:04:44.940 --> 00:04:47.585\r\nand it was really my client that was counting those rows.\r\n\r\n133\r\n00:04:47.585 --> 00:04:48.934\r\nI could have just had the server count it.\r\n\r\n134\r\n00:04:48.934 --> 00:04:50.681\r\nI didn't actually want to see the rows,\r\n\r\n135\r\n00:04:50.681 --> 00:04:52.369\r\nI just wanted to know how many there were,\r\n\r\n136\r\n00:04:52.369 --> 00:04:54.602\r\nand I could have used the COUNT function to do that.\r\n\r\n137\r\n00:04:54.602 --> 00:04:56.349\r\nBut in order to do it, I would have to know\r\n\r\n138\r\n00:04:56.349 --> 00:04:58.385\r\nthat the COUNT function existed.\r\n\r\n139\r\n00:04:58.385 --> 00:05:00.502\r\nSo how do I know what functions exist?\r\n\r\n140\r\n00:05:00.502 --> 00:05:03.243\r\nFortunately, we've got the Microsoft web page\r\n\r\n141\r\n00:05:03.243 --> 00:05:04.611\r\nhere to help us.\r\n\r\n142\r\n00:05:04.611 --> 00:05:07.961\r\nWhen we go to, and let me pull up Microsoft's site here,\r\n\r\n143\r\n00:05:07.961 --> 00:05:10.371\r\nand I'll put the link for this in the show notes,\r\n\r\n144\r\n00:05:10.371 --> 00:05:12.497\r\nbut this is on docs.microsoft.com,\r\n\r\n145\r\n00:05:12.497 --> 00:05:14.583\r\ntheir documentation site, and they've got\r\n\r\n146\r\n00:05:14.583 --> 00:05:15.880\r\nthe SQL database functions.\r\n\r\n147\r\n00:05:15.880 --> 00:05:17.374\r\nThey've got all of them documented and stored right here\r\n\r\n148\r\n00:05:17.374 --> 00:05:19.515\r\nand they're divided into these categories\r\n\r\n149\r\n00:05:19.515 --> 00:05:21.166\r\nbased on what they do.\r\n\r\n150\r\n00:05:21.166 --> 00:05:23.100\r\nDifferent functions do different things.\r\n\r\n151\r\n00:05:23.100 --> 00:05:26.433\r\nI was talking about manipulating a date.\r\n\r\n152\r\n00:05:27.579 --> 00:05:29.614\r\nIf I wanted to change the format of a date\r\n\r\n153\r\n00:05:29.614 --> 00:05:32.835\r\nI could look in here and find date and time\r\n\r\n154\r\n00:05:32.835 --> 00:05:34.260\r\nand when I go under date and time\r\n\r\n155\r\n00:05:34.260 --> 00:05:36.309\r\nI start to see various functions that are in here\r\n\r\n156\r\n00:05:36.309 --> 00:05:39.226\r\nlike DATEPART and DATETIMEFROMPARTS\r\n\r\n157\r\n00:05:41.009 --> 00:05:44.033\r\nwhere I could start lifting time out of a field,\r\n\r\n158\r\n00:05:44.033 --> 00:05:47.543\r\nGETDATE, we've got DAY, MONTH, YEAR,\r\n\r\n159\r\n00:05:47.543 --> 00:05:50.227\r\neach of these are functions that we can use\r\n\r\n160\r\n00:05:50.227 --> 00:05:52.747\r\nto manipulate the format of date.\r\n\r\n161\r\n00:05:52.747 --> 00:05:54.633\r\nThere's another function called CONVERT\r\n\r\n162\r\n00:05:54.633 --> 00:05:56.143\r\nwhich is not here in the list\r\n\r\n163\r\n00:05:56.143 --> 00:05:58.055\r\n'cause CONVERT can be used with a lot more than just date,\r\n\r\n164\r\n00:05:58.055 --> 00:06:00.389\r\nyou can convert anything, so it's tucked away\r\n\r\n165\r\n00:06:00.389 --> 00:06:03.095\r\nunder one of these other, is that data type?\r\n\r\n166\r\n00:06:03.095 --> 00:06:04.156\r\nNope.\r\n\r\n167\r\n00:06:04.156 --> 00:06:05.861\r\nIf you can't find it, you've got a handy little filter\r\n\r\n168\r\n00:06:05.861 --> 00:06:08.404\r\nup here, and we can search and find CONvERT.\r\n\r\n169\r\n00:06:08.404 --> 00:06:11.591\r\nHere's the TRY_CONVERT and the CAST_AND_CONVERT.\r\n\r\n170\r\n00:06:11.591 --> 00:06:13.497\r\nTwo different functions they group together.\r\n\r\n171\r\n00:06:13.497 --> 00:06:16.089\r\nYou can find the functions that you're looking for\r\n\r\n172\r\n00:06:16.089 --> 00:06:18.393\r\nright here on their site, but this is a great way to learn.\r\n\r\n173\r\n00:06:18.393 --> 00:06:20.841\r\nIn the show, we're gonna use a lot of these functions,\r\n\r\n174\r\n00:06:20.841 --> 00:06:23.524\r\nnot just in this episode, but in every episode\r\n\r\n175\r\n00:06:23.524 --> 00:06:24.729\r\nthrough the end of this series,\r\n\r\n176\r\n00:06:24.729 --> 00:06:27.033\r\nwe're going to use a lot of different functions,\r\n\r\n177\r\n00:06:27.033 --> 00:06:28.655\r\nbut we're not gonna use them all,\r\n\r\n178\r\n00:06:28.655 --> 00:06:29.932\r\n'cause there's a ton of them.\r\n\r\n179\r\n00:06:29.932 --> 00:06:31.195\r\nIf you come here to the website,\r\n\r\n180\r\n00:06:31.195 --> 00:06:33.620\r\nyou can actually look through and see each one.\r\n\r\n181\r\n00:06:33.620 --> 00:06:36.500\r\nThe important part of this documentation,\r\n\r\n182\r\n00:06:36.500 --> 00:06:37.891\r\nI guess there's two important parts,\r\n\r\n183\r\n00:06:37.891 --> 00:06:39.364\r\none, figuring out the function exists.\r\n\r\n184\r\n00:06:39.364 --> 00:06:41.361\r\nI need to do something, can I do it?\r\n\r\n185\r\n00:06:41.361 --> 00:06:45.528\r\nMaybe I want to, I don't know, do the cosign of a number.\r\n\r\n186\r\n00:06:47.208 --> 00:06:49.532\r\nCan I do a cosign?\r\n\r\n187\r\n00:06:49.532 --> 00:06:51.962\r\nIf I go down here to mathematical,\r\n\r\n188\r\n00:06:51.962 --> 00:06:54.916\r\ninside of mathematical I can find cosign.\r\n\r\n189\r\n00:06:54.916 --> 00:06:56.695\r\nCOS, right there, right.\r\n\r\n190\r\n00:06:56.695 --> 00:06:58.929\r\nHere's the cosine, so I can take the cosine of a number\r\n\r\n191\r\n00:06:58.929 --> 00:07:02.011\r\nand it tells me how that function works.\r\n\r\n192\r\n00:07:02.011 --> 00:07:04.387\r\nAnd functions are usually pretty easy to spot\r\n\r\n193\r\n00:07:04.387 --> 00:07:06.632\r\nbecause they've got a name, let me zoom in on that a bit,\r\n\r\n194\r\n00:07:06.632 --> 00:07:09.460\r\nthey've got a name, this one's just COS,\r\n\r\n195\r\n00:07:09.460 --> 00:07:11.135\r\nand it's usually capitalized.\r\n\r\n196\r\n00:07:11.135 --> 00:07:13.655\r\nAnd then it's followed by an open parenthesis\r\n\r\n197\r\n00:07:13.655 --> 00:07:15.475\r\nand a closed parenthesis.\r\n\r\n198\r\n00:07:15.475 --> 00:07:18.494\r\nThose parenthesis right there are what's telling me hey,\r\n\r\n199\r\n00:07:18.494 --> 00:07:21.465\r\nthis is expecting some kind of input.\r\n\r\n200\r\n00:07:21.465 --> 00:07:24.057\r\nThis one is expecting a float expression,\r\n\r\n201\r\n00:07:24.057 --> 00:07:26.577\r\nin other words, a number to give it\r\n\r\n202\r\n00:07:26.577 --> 00:07:29.443\r\nso that it can perform the cosine of that number.\r\n\r\n203\r\n00:07:29.443 --> 00:07:32.121\r\nI need to know that information.\r\n\r\n204\r\n00:07:32.121 --> 00:07:35.779\r\nSome functions require more than one piece of input.\r\n\r\n205\r\n00:07:35.779 --> 00:07:38.260\r\nLike ROUND, if I want to round a number,\r\n\r\n206\r\n00:07:38.260 --> 00:07:39.806\r\nI take a look at ROUND.\r\n\r\n207\r\n00:07:39.806 --> 00:07:41.447\r\nWhen I look at ROUND, it's telling me\r\n\r\n208\r\n00:07:41.447 --> 00:07:43.732\r\nit wants a numerical expression, a length,\r\n\r\n209\r\n00:07:43.732 --> 00:07:46.147\r\nand optionally, another function.\r\n\r\n210\r\n00:07:46.147 --> 00:07:47.673\r\n'Cause you put a function inside --\r\n\r\n211\r\n00:07:47.673 --> 00:07:49.204\r\n<v ->Nesting functions, huh?</v>\r\n\r\n212\r\n00:07:49.204 --> 00:07:51.614\r\n<v ->Absolutely, and we'll see that more</v>\r\n\r\n213\r\n00:07:51.614 --> 00:07:52.982\r\nwhen we get into stored procedures,\r\n\r\n214\r\n00:07:52.982 --> 00:07:55.175\r\nI'll table that one for another episode, too,\r\n\r\n215\r\n00:07:55.175 --> 00:07:56.707\r\nit's a whole can of worms.\r\n\r\n216\r\n00:07:56.707 --> 00:07:58.451\r\nStored procedures are very, very awesome.\r\n\r\n217\r\n00:07:58.451 --> 00:08:01.641\r\nWith this one, I'm saying I want to round a number.\r\n\r\n218\r\n00:08:01.641 --> 00:08:05.808\r\nIf I say, hey Daniel, I want you to round the number seven\r\n\r\n219\r\n00:08:07.055 --> 00:08:08.351\r\nto the nearest tenth.\r\n\r\n220\r\n00:08:08.351 --> 00:08:09.269\r\n<v ->That would be 10.</v>\r\n\r\n221\r\n00:08:09.269 --> 00:08:11.774\r\n<v ->It would be 10, right, it's higher than five,</v>\r\n\r\n222\r\n00:08:11.774 --> 00:08:13.141\r\nor five and higher, so you round up 10.\r\n\r\n223\r\n00:08:13.141 --> 00:08:14.039\r\nIf it was four, you'd --\r\n\r\n224\r\n00:08:14.039 --> 00:08:15.695\r\n<v Daniel>Go one, or zero, zero, yeah.</v>\r\n\r\n225\r\n00:08:15.695 --> 00:08:18.171\r\n<v ->Zero, so simple rounding, right.</v>\r\n\r\n226\r\n00:08:18.171 --> 00:08:20.524\r\nSQL can do the rounding for us.\r\n\r\n227\r\n00:08:20.524 --> 00:08:23.662\r\nAnd that's important because I might have a currency column\r\n\r\n228\r\n00:08:23.662 --> 00:08:27.478\r\nthat has the currency calculated to eight decimal places.\r\n\r\n229\r\n00:08:27.478 --> 00:08:29.297\r\nI just want it down to two decimal places\r\n\r\n230\r\n00:08:29.297 --> 00:08:30.646\r\n'cause I need to turn this into pennies.\r\n\r\n231\r\n00:08:30.646 --> 00:08:32.336\r\nI can do a ROUND.\r\n\r\n232\r\n00:08:32.336 --> 00:08:34.568\r\nI would give it my number, but then would need\r\n\r\n233\r\n00:08:34.568 --> 00:08:36.349\r\nto give it a length.\r\n\r\n234\r\n00:08:36.349 --> 00:08:38.687\r\nHow many decimals places do I want to round to,\r\n\r\n235\r\n00:08:38.687 --> 00:08:40.169\r\nor how many tens or whole number places\r\n\r\n236\r\n00:08:40.169 --> 00:08:41.374\r\ndo I want to round to?\r\n\r\n237\r\n00:08:41.374 --> 00:08:43.564\r\nThose are our options that go into it,\r\n\r\n238\r\n00:08:43.564 --> 00:08:46.304\r\nthe input we feed into it for the function to work,\r\n\r\n239\r\n00:08:46.304 --> 00:08:47.297\r\nand this is optional.\r\n\r\n240\r\n00:08:47.297 --> 00:08:49.256\r\nSee how it's written in square brackets?\r\n\r\n241\r\n00:08:49.256 --> 00:08:50.967\r\nIn the documentation, when it's in square brackets,\r\n\r\n242\r\n00:08:50.967 --> 00:08:52.080\r\nthat means optional.\r\n\r\n243\r\n00:08:52.080 --> 00:08:53.374\r\nI don't have to have that.\r\n\r\n244\r\n00:08:53.374 --> 00:08:55.990\r\nIf there's no square bracket, it's required.\r\n\r\n245\r\n00:08:55.990 --> 00:08:57.737\r\nIn order to use this function, I have to give it\r\n\r\n246\r\n00:08:57.737 --> 00:08:59.897\r\ntwo pieces of information.\r\n\r\n247\r\n00:08:59.897 --> 00:09:01.913\r\nI've got to give it a number to round,\r\n\r\n248\r\n00:09:01.913 --> 00:09:05.096\r\nand how much I want to round it.\r\n\r\n249\r\n00:09:05.096 --> 00:09:08.600\r\nSome functions might have a default value, ROUND does not.\r\n\r\n250\r\n00:09:08.600 --> 00:09:11.303\r\nThere's no default length that it'll round to\r\n\r\n251\r\n00:09:11.303 --> 00:09:15.470\r\nbecause this is considered a precision calculation.\r\n\r\n252\r\n00:09:16.902 --> 00:09:18.704\r\nI know that doesn't sound right, 'cause we're rounding,\r\n\r\n253\r\n00:09:18.704 --> 00:09:21.584\r\nit's not precision, but by precision I mean\r\n\r\n254\r\n00:09:21.584 --> 00:09:23.221\r\nthat it should always return the same value,\r\n\r\n255\r\n00:09:23.221 --> 00:09:25.418\r\nand if there's a default, the default could be different\r\n\r\n256\r\n00:09:25.418 --> 00:09:27.881\r\non different systems, and now you wouldn't necessarily\r\n\r\n257\r\n00:09:27.881 --> 00:09:28.784\r\nget the same value.\r\n\r\n258\r\n00:09:28.784 --> 00:09:30.616\r\nThat's why they require you to put in that value.\r\n\r\n259\r\n00:09:30.616 --> 00:09:33.445\r\nYou'll see that, and the only way you can know this,\r\n\r\n260\r\n00:09:33.445 --> 00:09:36.485\r\nthere's two ways, one way is memorize it, that's one way.\r\n\r\n261\r\n00:09:36.485 --> 00:09:38.360\r\nBut for normal people like myself,\r\n\r\n262\r\n00:09:38.360 --> 00:09:40.228\r\nit's to use the documentation.\r\n\r\n263\r\n00:09:40.228 --> 00:09:43.217\r\nIntelliSense will help you with some of this stuff.\r\n\r\n264\r\n00:09:43.217 --> 00:09:45.651\r\nIntelliSense knows when you're doing a function.\r\n\r\n265\r\n00:09:45.651 --> 00:09:48.185\r\nIf I go back to my query analyzer,\r\n\r\n266\r\n00:09:48.185 --> 00:09:49.736\r\nand I just start typing.\r\n\r\n267\r\n00:09:49.736 --> 00:09:51.949\r\nI want to use the ROUND function.\r\n\r\n268\r\n00:09:51.949 --> 00:09:56.048\r\nI'm going to type ROUND, and see how ROUND turned pink?\r\n\r\n269\r\n00:09:56.048 --> 00:09:58.353\r\nPink means it knows this is a function.\r\n\r\n270\r\n00:09:58.353 --> 00:09:59.920\r\nI just typed a function name.\r\n\r\n271\r\n00:09:59.920 --> 00:10:01.059\r\nMaybe that's not what I wanted,\r\n\r\n272\r\n00:10:01.059 --> 00:10:03.003\r\nmaybe I've got a column that's just named ROUND,\r\n\r\n273\r\n00:10:03.003 --> 00:10:04.670\r\nand so in that case, I would need to put\r\n\r\n274\r\n00:10:04.670 --> 00:10:06.459\r\nthe square brackets around it and it knows,\r\n\r\n275\r\n00:10:06.459 --> 00:10:07.967\r\noh, you're just doing the word round.\r\n\r\n276\r\n00:10:07.967 --> 00:10:09.699\r\nIf I take that back out, it turns pink,\r\n\r\n277\r\n00:10:09.699 --> 00:10:11.294\r\nso it knows this is a function.\r\n\r\n278\r\n00:10:11.294 --> 00:10:13.385\r\nAnd functions should always be followed\r\n\r\n279\r\n00:10:13.385 --> 00:10:15.565\r\nwith an open and closed parenthesis.\r\n\r\n280\r\n00:10:15.565 --> 00:10:19.145\r\nEven if the function doesn't require any input.\r\n\r\n281\r\n00:10:19.145 --> 00:10:21.478\r\nAn example of that, GETDATE.\r\n\r\n282\r\n00:10:22.352 --> 00:10:24.781\r\nGETDATE just says give me the current date,\r\n\r\n283\r\n00:10:24.781 --> 00:10:28.001\r\nand it doesn't need any input, I can just run GETDATE,\r\n\r\n284\r\n00:10:28.001 --> 00:10:30.305\r\nbut I still put the open and closed parenthesis,\r\n\r\n285\r\n00:10:30.305 --> 00:10:32.307\r\nand that's because I need to let it know\r\n\r\n286\r\n00:10:32.307 --> 00:10:35.437\r\nthis is a function, and I need you to do something,\r\n\r\n287\r\n00:10:35.437 --> 00:10:36.445\r\ndo your logic.\r\n\r\n288\r\n00:10:36.445 --> 00:10:37.649\r\nYour logic doesn't require input,\r\n\r\n289\r\n00:10:37.649 --> 00:10:39.147\r\nbut I need you to do it anyway.\r\n\r\n290\r\n00:10:39.147 --> 00:10:41.985\r\nROUND on the other hand, needs input,\r\n\r\n291\r\n00:10:41.985 --> 00:10:45.229\r\nand it's gonna be unhappy if I just leave it the way it is.\r\n\r\n292\r\n00:10:45.229 --> 00:10:48.881\r\nWhen I'm typing, right now, see this little\r\n\r\n293\r\n00:10:48.881 --> 00:10:50.917\r\nsquiggly underline that I've got right here,\r\n\r\n294\r\n00:10:50.917 --> 00:10:53.475\r\nit's telling me I've got an error,\r\n\r\n295\r\n00:10:53.475 --> 00:10:55.400\r\nand IntelliSense isn't helping me,\r\n\r\n296\r\n00:10:55.400 --> 00:10:57.723\r\nit's not popping up and giving me any suggestions.\r\n\r\n297\r\n00:10:57.723 --> 00:11:01.664\r\nFunctions aren't really designed to be run alone.\r\n\r\n298\r\n00:11:01.664 --> 00:11:04.112\r\nThey're expected to be used as part of another query.\r\n\r\n299\r\n00:11:04.112 --> 00:11:08.989\r\nI might be selecting a query, the data from a table,\r\n\r\n300\r\n00:11:08.989 --> 00:11:11.312\r\nand then I use a function inside of it.\r\n\r\n301\r\n00:11:11.312 --> 00:11:14.639\r\nAn example of that, one that I actually did have to cheat\r\n\r\n302\r\n00:11:14.639 --> 00:11:17.177\r\nand use it in one of the episodes,\r\n\r\n303\r\n00:11:17.177 --> 00:11:20.177\r\nif I want to select, I'll do * FROM,\r\n\r\n304\r\n00:11:21.535 --> 00:11:24.285\r\nand I'll pull from my SalesOrder,\r\n\r\n305\r\n00:11:26.773 --> 00:11:31.184\r\nso if I query on this table, when I run that query,\r\n\r\n306\r\n00:11:31.184 --> 00:11:35.648\r\nit's gonna go, and it's gonna pull a bunch of rows.\r\n\r\n307\r\n00:11:35.648 --> 00:11:37.405\r\nI'll do that thing which I said I hate\r\n\r\n308\r\n00:11:37.405 --> 00:11:39.157\r\nwhich is to look down here, but down at the bottom right,\r\n\r\n309\r\n00:11:39.157 --> 00:11:43.693\r\nI can look down, I can see that I just queries 31,465 rows.\r\n\r\n310\r\n00:11:43.693 --> 00:11:47.307\r\nMaybe I didn't actually want all 31,000 rows.\r\n\r\n311\r\n00:11:47.307 --> 00:11:48.140\r\nI just got them.\r\n\r\n312\r\n00:11:48.140 --> 00:11:48.973\r\n<v Daniel>Yup.</v>\r\n\r\n313\r\n00:11:48.973 --> 00:11:50.227\r\n<v ->So this already is a bit of work.</v>\r\n\r\n314\r\n00:11:50.227 --> 00:11:52.995\r\nMaybe I just wanted the first five rows.\r\n\r\n315\r\n00:11:52.995 --> 00:11:55.646\r\nI could use the TOP function.\r\n\r\n316\r\n00:11:55.646 --> 00:12:00.269\r\nTOP by itself isn't even recognized as a function.\r\n\r\n317\r\n00:12:00.269 --> 00:12:02.558\r\nSee how it is blue instead of pink?\r\n\r\n318\r\n00:12:02.558 --> 00:12:04.661\r\nThat's because the TOP function\r\n\r\n319\r\n00:12:04.661 --> 00:12:08.011\r\nis actually built in to the SELECT command,\r\n\r\n320\r\n00:12:08.011 --> 00:12:10.205\r\nand so it's a little bit of a special example\r\n\r\n321\r\n00:12:10.205 --> 00:12:11.429\r\nand we'll see a few of those,\r\n\r\n322\r\n00:12:11.429 --> 00:12:13.070\r\nCOUNT is another one that's kind of special.\r\n\r\n323\r\n00:12:13.070 --> 00:12:16.487\r\nI could say that I want to return the TOP\r\n\r\n324\r\n00:12:18.754 --> 00:12:21.087\r\nand then I'll say five rows.\r\n\r\n325\r\n00:12:23.438 --> 00:12:26.438\r\nSee how I'm calling the TOP function\r\n\r\n326\r\n00:12:27.934 --> 00:12:30.221\r\nand in parentheses, I'm giving it some input.\r\n\r\n327\r\n00:12:30.221 --> 00:12:32.775\r\nI'm saying, I just want five rows, or I can do 50 rows,\r\n\r\n328\r\n00:12:32.775 --> 00:12:34.397\r\nor 100 rows, I think this one actually does\r\n\r\n329\r\n00:12:34.397 --> 00:12:36.539\r\nhave a default of 10 rows if I leave it empty,\r\n\r\n330\r\n00:12:36.539 --> 00:12:39.293\r\nbut I just want the top five rows.\r\n\r\n331\r\n00:12:39.293 --> 00:12:42.263\r\nI want all the columns of those rows,\r\n\r\n332\r\n00:12:42.263 --> 00:12:43.776\r\nbut I just want the top five.\r\n\r\n333\r\n00:12:43.776 --> 00:12:47.717\r\nWhen I run that, now the server knows what to do,\r\n\r\n334\r\n00:12:47.717 --> 00:12:50.309\r\nand it only gives me the top five rows.\r\n\r\n335\r\n00:12:50.309 --> 00:12:51.878\r\nThat's a valid function.\r\n\r\n336\r\n00:12:51.878 --> 00:12:56.357\r\nMost functions are expected to be used inside of a query.\r\n\r\n337\r\n00:12:56.357 --> 00:12:59.275\r\nIf you want to call a function by itself,\r\n\r\n338\r\n00:12:59.275 --> 00:13:01.647\r\nwe have to trick the system a little bit.\r\n\r\n339\r\n00:13:01.647 --> 00:13:03.576\r\nFor example, GETDATE.\r\n\r\n340\r\n00:13:03.576 --> 00:13:06.471\r\nI know that GETDATE will give me today's date,\r\n\r\n341\r\n00:13:06.471 --> 00:13:09.300\r\nbut if I just try and run that, I'm gonna get an error.\r\n\r\n342\r\n00:13:09.300 --> 00:13:12.053\r\nIncorrect syntax near closed parentheses.\r\n\r\n343\r\n00:13:12.053 --> 00:13:13.634\r\nIt doesn't know what to do.\r\n\r\n344\r\n00:13:13.634 --> 00:13:15.887\r\nWe have to trick it just a little bit.\r\n\r\n345\r\n00:13:15.887 --> 00:13:17.294\r\nThis is important.\r\n\r\n346\r\n00:13:17.294 --> 00:13:18.859\r\nYou don't do this in production so much\r\n\r\n347\r\n00:13:18.859 --> 00:13:21.038\r\nbut as you're learning, just to test out functions,\r\n\r\n348\r\n00:13:21.038 --> 00:13:22.440\r\nit's important to be able to do this.\r\n\r\n349\r\n00:13:22.440 --> 00:13:27.374\r\nWe can say SELECT GETDATE, I want to get the date,\r\n\r\n350\r\n00:13:27.374 --> 00:13:29.928\r\nI'm going to select against it as if it was a table.\r\n\r\n351\r\n00:13:29.928 --> 00:13:31.436\r\nThe problem is, it's not a table,\r\n\r\n352\r\n00:13:31.436 --> 00:13:32.713\r\nand it's going to return a value,\r\n\r\n353\r\n00:13:32.713 --> 00:13:33.885\r\nand it's not going to be happy about it.\r\n\r\n354\r\n00:13:33.885 --> 00:13:37.454\r\nI need to say AS and give it some kind of name\r\n\r\n355\r\n00:13:37.454 --> 00:13:39.557\r\nand so now it knows that I'm going to treat this\r\n\r\n356\r\n00:13:39.557 --> 00:13:40.550\r\nlike a table.\r\n\r\n357\r\n00:13:40.550 --> 00:13:41.990\r\nAnd see how my little squiggly underlines\r\n\r\n358\r\n00:13:41.990 --> 00:13:43.934\r\njust went away and now it looks happy,\r\n\r\n359\r\n00:13:43.934 --> 00:13:47.606\r\nand if I run that, I get a result, and there's my date.\r\n\r\n360\r\n00:13:47.606 --> 00:13:49.008\r\nAnd it just came back right here.\r\n\r\n361\r\n00:13:49.008 --> 00:13:50.357\r\nWhere did that date come from?\r\n\r\n362\r\n00:13:50.357 --> 00:13:53.688\r\nWell, there's no table that contains the date.\r\n\r\n363\r\n00:13:53.688 --> 00:13:55.465\r\nThe server figured it out.\r\n\r\n364\r\n00:13:55.465 --> 00:13:59.105\r\nThe GETDATE function, which lives on the server,\r\n\r\n365\r\n00:13:59.105 --> 00:14:01.502\r\nwhen you call it, it figures out a date.\r\n\r\n366\r\n00:14:01.502 --> 00:14:03.878\r\nThe date on the server.\r\n\r\n367\r\n00:14:03.878 --> 00:14:06.398\r\nThe date on my computer could be completely wrong,\r\n\r\n368\r\n00:14:06.398 --> 00:14:09.365\r\nbut now I get the accurate date from the server\r\n\r\n369\r\n00:14:09.365 --> 00:14:11.131\r\nand that's really incredibly useful\r\n\r\n370\r\n00:14:11.131 --> 00:14:12.605\r\nespecially when you're doing calculations.\r\n\r\n371\r\n00:14:12.605 --> 00:14:15.269\r\n<v ->Don, is that why you're calling it as a table</v>\r\n\r\n372\r\n00:14:15.269 --> 00:14:17.141\r\nso that it goes from that server?\r\n\r\n373\r\n00:14:17.141 --> 00:14:18.619\r\nIt just seems a little convoluted,\r\n\r\n374\r\n00:14:18.619 --> 00:14:22.507\r\ngoing around your elbow to get to your back kind of thing\r\n\r\n375\r\n00:14:22.507 --> 00:14:25.781\r\nto say GETDATE, but I have to do it as a table.\r\n\r\n376\r\n00:14:25.781 --> 00:14:28.681\r\nIt's very strange, why is it that they do that?\r\n\r\n377\r\n00:14:28.681 --> 00:14:30.731\r\n<v ->It's because we're always expected to be working</v>\r\n\r\n378\r\n00:14:30.731 --> 00:14:32.082\r\nwith tables or views.\r\n\r\n379\r\n00:14:32.082 --> 00:14:34.677\r\nInside of a database, where's your data?\r\n\r\n380\r\n00:14:34.677 --> 00:14:37.802\r\nAs long as you're using DML, Data Manipulation Language.\r\n\r\n381\r\n00:14:37.802 --> 00:14:40.434\r\nIf you're doing Data Definition Language, DDL,\r\n\r\n382\r\n00:14:40.434 --> 00:14:42.001\r\nnow you're building tables,\r\n\r\n383\r\n00:14:42.001 --> 00:14:43.441\r\nyou're building indexes and things,\r\n\r\n384\r\n00:14:43.441 --> 00:14:45.344\r\nthen it's a whole different story.\r\n\r\n385\r\n00:14:45.344 --> 00:14:46.765\r\nAs long as you're working with data,\r\n\r\n386\r\n00:14:46.765 --> 00:14:49.774\r\nyour data lives in a table, that's where the data is,\r\n\r\n387\r\n00:14:49.774 --> 00:14:52.150\r\nand so that's how functions are expected to be used.\r\n\r\n388\r\n00:14:52.150 --> 00:14:54.651\r\nI'm kind of going against the grain.\r\n\r\n389\r\n00:14:54.651 --> 00:14:57.493\r\nWhat good did I just do pulling that date?\r\n\r\n390\r\n00:14:57.493 --> 00:14:58.326\r\nNot much.\r\n\r\n391\r\n00:14:59.362 --> 00:15:00.785\r\nMeanwhile, what I could have done was\r\n\r\n392\r\n00:15:00.785 --> 00:15:02.952\r\nI might say that I want to\r\n\r\n393\r\n00:15:05.321 --> 00:15:07.861\r\nlet's get rid of this for a second,\r\n\r\n394\r\n00:15:07.861 --> 00:15:10.760\r\nlet's say I'm going to pull from,\r\n\r\n395\r\n00:15:10.760 --> 00:15:13.510\r\nwe'll do HumanResources.Employee.\r\n\r\n396\r\n00:15:14.413 --> 00:15:16.553\r\nI'm going to pull up my employee list\r\n\r\n397\r\n00:15:16.553 --> 00:15:20.278\r\nand I could pull all of the columns that are available.\r\n\r\n398\r\n00:15:20.278 --> 00:15:21.449\r\nMaybe I don't want all of that.\r\n\r\n399\r\n00:15:21.449 --> 00:15:25.032\r\nMaybe I just want job title and hire dates.\r\n\r\n400\r\n00:15:26.325 --> 00:15:27.949\r\nThat's what I'm gonna pull.\r\n\r\n401\r\n00:15:27.949 --> 00:15:30.756\r\nNow, I'm querying, I'm getting that data.\r\n\r\n402\r\n00:15:30.756 --> 00:15:34.949\r\nThe hire date's cool, but I kind of want to know\r\n\r\n403\r\n00:15:34.949 --> 00:15:37.918\r\nwhat's today's date, and I did put this in perspective.\r\n\r\n404\r\n00:15:37.918 --> 00:15:39.809\r\nI've been in a time machine for a long time.\r\n\r\n405\r\n00:15:39.809 --> 00:15:40.712\r\n(laughing)\r\n\r\n406\r\n00:15:40.712 --> 00:15:42.421\r\nAnd I gotta find out --\r\n\r\n407\r\n00:15:42.421 --> 00:15:43.606\r\n<v ->How long have these people worked here?</v>\r\n\r\n408\r\n00:15:43.606 --> 00:15:44.509\r\n(laughing)\r\n\r\n409\r\n00:15:44.509 --> 00:15:45.950\r\n<v ->I could add another column here</v>\r\n\r\n410\r\n00:15:45.950 --> 00:15:50.427\r\nand I could do GETDATE, and I can give it that name.\r\n\r\n411\r\n00:15:50.427 --> 00:15:53.759\r\nI'll just say as date or current date or whatever.\r\n\r\n412\r\n00:15:53.759 --> 00:15:55.752\r\nHere, I'll make it say current date.\r\n\r\n413\r\n00:15:55.752 --> 00:15:59.342\r\nSo now, I'm pulling data from the table,\r\n\r\n414\r\n00:15:59.342 --> 00:16:01.300\r\nand I'm adding more data to it,\r\n\r\n415\r\n00:16:01.300 --> 00:16:03.407\r\ndata that doesn't exist right now,\r\n\r\n416\r\n00:16:03.407 --> 00:16:06.758\r\nbut when it runs, it's gonna execute GETDATE\r\n\r\n417\r\n00:16:06.758 --> 00:16:09.671\r\nto populate that other column and fill that out.\r\n\r\n418\r\n00:16:09.671 --> 00:16:11.161\r\nThat's a better example of how\r\n\r\n419\r\n00:16:11.161 --> 00:16:12.404\r\nwe might use it in production.\r\n\r\n420\r\n00:16:12.404 --> 00:16:14.822\r\nThis could actually be useful versus\r\n\r\n421\r\n00:16:14.822 --> 00:16:16.118\r\njust pulling the individual date.\r\n\r\n422\r\n00:16:16.118 --> 00:16:18.134\r\nWhat I showed you where I did the SELECT\r\n\r\n423\r\n00:16:18.134 --> 00:16:20.058\r\nand just the function by itself,\r\n\r\n424\r\n00:16:20.058 --> 00:16:22.022\r\nthat's something we do when we're learning.\r\n\r\n425\r\n00:16:22.022 --> 00:16:24.182\r\nOr, maybe you are just trying to explore\r\n\r\n426\r\n00:16:24.182 --> 00:16:25.508\r\na little bit on the server.\r\n\r\n427\r\n00:16:25.508 --> 00:16:26.918\r\nMaybe you just want to know what the date is on the server\r\n\r\n428\r\n00:16:26.918 --> 00:16:30.038\r\nand you've only got access, you might do that.\r\n\r\n429\r\n00:16:30.038 --> 00:16:31.818\r\nData Definition Language, there's several cases\r\n\r\n430\r\n00:16:31.818 --> 00:16:33.208\r\nwhere you do that.\r\n\r\n431\r\n00:16:33.208 --> 00:16:35.709\r\nWhen actually working with your true data, it's not,\r\n\r\n432\r\n00:16:35.709 --> 00:16:38.877\r\nit's normally done inside a SELECT statement of some sort.\r\n\r\n433\r\n00:16:38.877 --> 00:16:41.541\r\nAnd when I run that, it's gonna grab my data\r\n\r\n434\r\n00:16:41.541 --> 00:16:44.978\r\nand looking at it down here, I've got job title,\r\n\r\n435\r\n00:16:44.978 --> 00:16:48.112\r\nhire date, and right beside it is the current date,\r\n\r\n436\r\n00:16:48.112 --> 00:16:53.042\r\nand even though I returned, I don't know, some 290 rows,\r\n\r\n437\r\n00:16:53.042 --> 00:16:55.058\r\nif you look at the time, see how the time\r\n\r\n438\r\n00:16:55.058 --> 00:16:56.965\r\nis identical on all of these?\r\n\r\n439\r\n00:16:56.965 --> 00:17:00.136\r\nIt actually ran it, how many rows did I get, 290,\r\n\r\n440\r\n00:17:00.136 --> 00:17:02.368\r\nit ran that function 290 times,\r\n\r\n441\r\n00:17:02.368 --> 00:17:04.528\r\nbut it did it so fast as part of\r\n\r\n442\r\n00:17:04.528 --> 00:17:06.487\r\nthe query execution plan, it pulled that data\r\n\r\n443\r\n00:17:06.487 --> 00:17:09.332\r\nall at the same time, so they all end up with\r\n\r\n444\r\n00:17:09.332 --> 00:17:10.682\r\nthe same current date.\r\n\r\n445\r\n00:17:10.682 --> 00:17:12.948\r\nBut it did actually run over and over again for each row\r\n\r\n446\r\n00:17:12.948 --> 00:17:14.623\r\nbecause it might be processing something\r\n\r\n447\r\n00:17:14.623 --> 00:17:15.775\r\nfor each individual row.\r\n\r\n448\r\n00:17:15.775 --> 00:17:18.620\r\nThat's kind of an example of how that would be done.\r\n\r\n449\r\n00:17:18.620 --> 00:17:21.160\r\nThis one was a pretty simple function,\r\n\r\n450\r\n00:17:21.160 --> 00:17:23.786\r\nbecause GETDATE doesn't really take input,\r\n\r\n451\r\n00:17:23.786 --> 00:17:26.632\r\nbut let's take a look at one that does.\r\n\r\n452\r\n00:17:26.632 --> 00:17:28.989\r\nI mentioned the number rounding.\r\n\r\n453\r\n00:17:28.989 --> 00:17:31.656\r\nLet's say that I've got a number\r\n\r\n454\r\n00:17:33.072 --> 00:17:34.989\r\nand we'll do 123.45678.\r\n\r\n455\r\n00:17:38.512 --> 00:17:41.494\r\nSo, one, two, three, four, five, six, seven, eight,\r\n\r\n456\r\n00:17:41.494 --> 00:17:43.586\r\nand I want to round it.\r\n\r\n457\r\n00:17:43.586 --> 00:17:45.650\r\nI know I've got the ROUND function\r\n\r\n458\r\n00:17:45.650 --> 00:17:48.045\r\nand if I were to, just kinda move down here,\r\n\r\n459\r\n00:17:48.045 --> 00:17:52.314\r\nI'll say SELECT ROUND, I'll open up the parenthesis,\r\n\r\n460\r\n00:17:52.314 --> 00:17:54.618\r\nand IntelliSense is happy now,\r\n\r\n461\r\n00:17:54.618 --> 00:17:56.637\r\n'cause I'm in a SELECT statement.\r\n\r\n462\r\n00:17:56.637 --> 00:17:58.581\r\nAnd if I look at IntelliSense, it's telling me\r\n\r\n463\r\n00:17:58.581 --> 00:18:01.317\r\nI want to do a ROUND, I need to provide an expression.\r\n\r\n464\r\n00:18:01.317 --> 00:18:02.215\r\n<v Daniel>Oh, that's nice.</v>\r\n\r\n465\r\n00:18:02.215 --> 00:18:04.328\r\n<v ->Yeah, not a whole lotta help there,</v>\r\n\r\n466\r\n00:18:04.328 --> 00:18:08.527\r\nand then a precision integer, and a function as an integer.\r\n\r\n467\r\n00:18:08.527 --> 00:18:12.694\r\nPrecision, that's how long I want this rounding to be.\r\n\r\n468\r\n00:18:14.738 --> 00:18:16.394\r\nAnd then the function integer\r\n\r\n469\r\n00:18:16.394 --> 00:18:18.103\r\nwould be some other function that provides\r\n\r\n470\r\n00:18:18.103 --> 00:18:20.983\r\ndata back into it, and then it's gonna return\r\n\r\n471\r\n00:18:20.983 --> 00:18:22.617\r\nan expression of some type.\r\n\r\n472\r\n00:18:22.617 --> 00:18:24.386\r\nIt's gonna return a number in my case,\r\n\r\n473\r\n00:18:24.386 --> 00:18:25.714\r\n'cause I'm feeding it an integer,\r\n\r\n474\r\n00:18:25.714 --> 00:18:27.367\r\nI'm gonna get an integer back.\r\n\r\n475\r\n00:18:27.367 --> 00:18:29.642\r\nNow, this is not all that detailed,\r\n\r\n476\r\n00:18:29.642 --> 00:18:31.100\r\nbut I could go to Microsoft's webpage\r\n\r\n477\r\n00:18:31.100 --> 00:18:33.546\r\nwhere they have not only more detail\r\n\r\n478\r\n00:18:33.546 --> 00:18:35.258\r\nbut they have examples.\r\n\r\n479\r\n00:18:35.258 --> 00:18:37.202\r\nWhen I come in here, they're showing me\r\n\r\n480\r\n00:18:37.202 --> 00:18:39.597\r\nthat same basic syntax, there's not very detailed.\r\n\r\n481\r\n00:18:39.597 --> 00:18:42.384\r\nBut if I scroll down, you see the arguments,\r\n\r\n482\r\n00:18:42.384 --> 00:18:44.205\r\nthey explain each one.\r\n\r\n483\r\n00:18:44.205 --> 00:18:47.157\r\nWhat is length or precision, what is the function?\r\n\r\n484\r\n00:18:47.157 --> 00:18:48.970\r\nAnd then the return types, they explain the numbers\r\n\r\n485\r\n00:18:48.970 --> 00:18:50.265\r\nthat we can get back.\r\n\r\n486\r\n00:18:50.265 --> 00:18:52.625\r\nAnd then they usually give a handful of examples\r\n\r\n487\r\n00:18:52.625 --> 00:18:54.675\r\nthat we can see right here, much more detailed.\r\n\r\n488\r\n00:18:54.675 --> 00:18:57.271\r\nSo using Microsoft's webpage, get way to get in here\r\n\r\n489\r\n00:18:57.271 --> 00:18:58.980\r\nand learn how these work.\r\n\r\n490\r\n00:18:58.980 --> 00:19:02.004\r\nJust messing around with it is not that hard, either.\r\n\r\n491\r\n00:19:02.004 --> 00:19:03.967\r\nI can take this number, and I want to round it.\r\n\r\n492\r\n00:19:03.967 --> 00:19:06.954\r\nWell, that's the first value that I need to feed into this,\r\n\r\n493\r\n00:19:06.954 --> 00:19:09.981\r\nand once I feed it that, I need to tell it\r\n\r\n494\r\n00:19:09.981 --> 00:19:12.319\r\nhow much I want to round it.\r\n\r\n495\r\n00:19:12.319 --> 00:19:14.426\r\nLet's treat it like currency.\r\n\r\n496\r\n00:19:14.426 --> 00:19:16.548\r\nCurrency we usually take to two decimals places,\r\n\r\n497\r\n00:19:16.548 --> 00:19:20.185\r\nso I'll do a two right here, and that's gonna round it,\r\n\r\n498\r\n00:19:20.185 --> 00:19:22.489\r\nand so I should end up, if it works --\r\n\r\n499\r\n00:19:22.489 --> 00:19:23.671\r\n<v Daniel>With two decimal places.</v>\r\n\r\n500\r\n00:19:23.671 --> 00:19:26.642\r\n<v ->And it would be 123.46, right,</v>\r\n\r\n501\r\n00:19:26.642 --> 00:19:29.475\r\nbecause this six is higher than --\r\n\r\n502\r\n00:19:30.452 --> 00:19:31.285\r\n<v Daniel>Five.</v>\r\n\r\n503\r\n00:19:31.285 --> 00:19:35.786\r\n<v ->Five or it'll round up so it should be 123.46,</v>\r\n\r\n504\r\n00:19:35.786 --> 00:19:37.889\r\nassuming I did it right.\r\n\r\n505\r\n00:19:37.889 --> 00:19:41.796\r\nNow, where it gets interesting, just make sure we're right,\r\n\r\n506\r\n00:19:41.796 --> 00:19:45.452\r\nthere we go, yup, so I can see it rounded to 123.46.\r\n\r\n507\r\n00:19:45.452 --> 00:19:47.431\r\nIt rounded the way that I wanted to.\r\n\r\n508\r\n00:19:47.431 --> 00:19:48.959\r\nStill got the trailing decimals on there,\r\n\r\n509\r\n00:19:48.959 --> 00:19:50.724\r\nI could cut those off.\r\n\r\n510\r\n00:19:50.724 --> 00:19:52.235\r\nThere's another function call TRIM,\r\n\r\n511\r\n00:19:52.235 --> 00:19:54.074\r\nwhere you can trim off part.\r\n\r\n512\r\n00:19:54.074 --> 00:19:56.468\r\nThere's also CONVERT, and there's several other functions\r\n\r\n513\r\n00:19:56.468 --> 00:19:58.788\r\nwe could use to eliminate those trailing zeros\r\n\r\n514\r\n00:19:58.788 --> 00:20:00.895\r\nif we nest the functions together.\r\n\r\n515\r\n00:20:00.895 --> 00:20:03.434\r\nOne thing that I might not know,\r\n\r\n516\r\n00:20:03.434 --> 00:20:04.927\r\nthis makes a lot of sense so far.\r\n\r\n517\r\n00:20:04.927 --> 00:20:06.981\r\nIf I want five decimals places, I put a five.\r\n\r\n518\r\n00:20:06.981 --> 00:20:09.410\r\nIf I want one, I put a one, easy.\r\n\r\n519\r\n00:20:09.410 --> 00:20:11.733\r\nBut, what if I don't want to round the decimals?\r\n\r\n520\r\n00:20:11.733 --> 00:20:15.150\r\nWhat if I want to round the whole number?\r\n\r\n521\r\n00:20:16.702 --> 00:20:18.391\r\nWell, how do I do that?\r\n\r\n522\r\n00:20:18.391 --> 00:20:19.941\r\nA negative number.\r\n\r\n523\r\n00:20:19.941 --> 00:20:22.295\r\nIf I do a negative number for the length,\r\n\r\n524\r\n00:20:22.295 --> 00:20:25.106\r\nit starts rounding to the left of the decimal.\r\n\r\n525\r\n00:20:25.106 --> 00:20:28.058\r\nIf I do a positive number, it's to the right of the decimal.\r\n\r\n526\r\n00:20:28.058 --> 00:20:29.416\r\nAnd I know that sounds weird,\r\n\r\n527\r\n00:20:29.416 --> 00:20:31.476\r\nbut they're thinking there is that\r\n\r\n528\r\n00:20:31.476 --> 00:20:32.916\r\npeople are usually rounding decimals.\r\n\r\n529\r\n00:20:32.916 --> 00:20:34.280\r\nThey're not rounding whole numbers.\r\n\r\n530\r\n00:20:34.280 --> 00:20:36.840\r\nAnd so, do the positive on the one they do the most.\r\n\r\n531\r\n00:20:36.840 --> 00:20:39.669\r\nBut if I want to round this all the way up\r\n\r\n532\r\n00:20:39.669 --> 00:20:41.628\r\nto the whole number, I could say, well,\r\n\r\n533\r\n00:20:41.628 --> 00:20:46.111\r\ndo I want to round just the first digit or the first two?\r\n\r\n534\r\n00:20:46.111 --> 00:20:47.460\r\nAnd if I want to do the first two,\r\n\r\n535\r\n00:20:47.460 --> 00:20:50.325\r\nthen I would actually change this to be a negative two.\r\n\r\n536\r\n00:20:50.325 --> 00:20:54.408\r\nNow I'm rounding 123.45678 to negative two places\r\n\r\n537\r\n00:20:56.028 --> 00:21:00.276\r\nand when I run that, it rounds it to a nice, even 100.\r\n\r\n538\r\n00:21:00.276 --> 00:21:03.372\r\nIt rounded off those two, the ones and the tens\r\n\r\n539\r\n00:21:03.372 --> 00:21:04.903\r\nare now rounded, so I've got a nice\r\n\r\n540\r\n00:21:04.903 --> 00:21:07.404\r\nhundreds whole value right there.\r\n\r\n541\r\n00:21:07.404 --> 00:21:09.706\r\nI wouldn't have know to do that from IntelliSense.\r\n\r\n542\r\n00:21:09.706 --> 00:21:11.850\r\nIntelliSense doesn't give me enough information.\r\n\r\n543\r\n00:21:11.850 --> 00:21:14.010\r\nThe documentation is really what you're gonna rely on\r\n\r\n544\r\n00:21:14.010 --> 00:21:15.525\r\nas you start learning these functions\r\n\r\n545\r\n00:21:15.525 --> 00:21:18.026\r\nand providing the input, telling them what to do\r\n\r\n546\r\n00:21:18.026 --> 00:21:19.773\r\nand actually getting where you can use the function.\r\n\r\n547\r\n00:21:19.773 --> 00:21:22.255\r\n<v ->And there's obviously a multitude of functions</v>\r\n\r\n548\r\n00:21:22.255 --> 00:21:24.898\r\nthat we saw on Microsoft's website.\r\n\r\n549\r\n00:21:24.898 --> 00:21:26.575\r\nSo yeah, you're probably going to spend\r\n\r\n550\r\n00:21:26.575 --> 00:21:29.848\r\nquite a bit of time and effort in that documentation\r\n\r\n551\r\n00:21:29.848 --> 00:21:31.812\r\nlooking at the specific things that you need,\r\n\r\n552\r\n00:21:31.812 --> 00:21:32.763\r\nand that's cool, right?\r\n\r\n553\r\n00:21:32.763 --> 00:21:34.821\r\nThey've got all that stuff, it's already built out for you,\r\n\r\n554\r\n00:21:34.821 --> 00:21:37.557\r\nbut Don, I've done a little bit of programming,\r\n\r\n555\r\n00:21:37.557 --> 00:21:39.247\r\nand anybody that's done a little bit of programming,\r\n\r\n556\r\n00:21:39.247 --> 00:21:42.523\r\nwhether it be T-SQL or any other language,\r\n\r\n557\r\n00:21:42.523 --> 00:21:44.647\r\nis yeah, functions are cool, and there's,\r\n\r\n558\r\n00:21:44.647 --> 00:21:46.556\r\nI've got Standard Library and Python,\r\n\r\n559\r\n00:21:46.556 --> 00:21:49.975\r\nwe got these built in functions here in T-SQL,\r\n\r\n560\r\n00:21:49.975 --> 00:21:51.756\r\nbut they don't catch everything.\r\n\r\n561\r\n00:21:51.756 --> 00:21:52.692\r\n(laughing)\r\n\r\n562\r\n00:21:52.692 --> 00:21:54.909\r\nEvery now and then, you're like I keep writing this\r\n\r\n563\r\n00:21:54.909 --> 00:21:57.050\r\nover and over and over again,\r\n\r\n564\r\n00:21:57.050 --> 00:21:59.426\r\nbut man, it would be nice if it was a function,\r\n\r\n565\r\n00:21:59.426 --> 00:22:02.303\r\nand those other languages I'm able to create that function,\r\n\r\n566\r\n00:22:02.303 --> 00:22:03.580\r\ncreate a library of functions.\r\n\r\n567\r\n00:22:03.580 --> 00:22:05.167\r\nCan I do the same thing in T-SQL?\r\n\r\n568\r\n00:22:05.167 --> 00:22:07.615\r\n<v ->You can, and these functions,</v>\r\n\r\n569\r\n00:22:07.615 --> 00:22:11.450\r\nthis is where we start getting away from regular SQL\r\n\r\n570\r\n00:22:11.450 --> 00:22:14.690\r\nand becoming Microsoft's Transact SQL.\r\n\r\n571\r\n00:22:14.690 --> 00:22:17.424\r\nThat if you're on an Oracle server,\r\n\r\n572\r\n00:22:17.424 --> 00:22:19.711\r\nthere's a collection of functions that Oracle includes,\r\n\r\n573\r\n00:22:19.711 --> 00:22:21.345\r\nand if you're on a Microsoft SQL server,\r\n\r\n574\r\n00:22:21.345 --> 00:22:22.716\r\nthere's a collection of functions,\r\n\r\n575\r\n00:22:22.716 --> 00:22:23.940\r\nand they don't always match.\r\n\r\n576\r\n00:22:23.940 --> 00:22:26.532\r\nIt may be that I have a function on some other server,\r\n\r\n577\r\n00:22:26.532 --> 00:22:28.710\r\nand here I am on a Microsoft SQL server\r\n\r\n578\r\n00:22:28.710 --> 00:22:30.204\r\nand I don't have that function any more.\r\n\r\n579\r\n00:22:30.204 --> 00:22:31.106\r\nYou can build it.\r\n\r\n580\r\n00:22:31.106 --> 00:22:33.338\r\nYou can create what's called a user defined function.\r\n\r\n581\r\n00:22:33.338 --> 00:22:35.661\r\nOr maybe, you just have some specialized function\r\n\r\n582\r\n00:22:35.661 --> 00:22:36.775\r\nthat only you need.\r\n\r\n583\r\n00:22:36.775 --> 00:22:38.428\r\nNo one else on the planet needs this function, just you.\r\n\r\n584\r\n00:22:38.428 --> 00:22:40.826\r\nVery, very specialized.\r\n\r\n585\r\n00:22:40.826 --> 00:22:43.918\r\nYou can create a user defined function that does that.\r\n\r\n586\r\n00:22:43.918 --> 00:22:47.051\r\nNow, that requires doing Data Definition Language, DDL,\r\n\r\n587\r\n00:22:47.051 --> 00:22:49.951\r\nthat we actually have to create the function on the server,\r\n\r\n588\r\n00:22:49.951 --> 00:22:51.552\r\nand I'm gonna say that we're gonna do\r\n\r\n589\r\n00:22:51.552 --> 00:22:53.316\r\na whole section on creating things on the server,\r\n\r\n590\r\n00:22:53.316 --> 00:22:56.143\r\nso we have stored procedures, views, tables even,\r\n\r\n591\r\n00:22:56.143 --> 00:22:58.174\r\njust all that stuff, we'll put all that together\r\n\r\n592\r\n00:22:58.174 --> 00:23:02.138\r\nlater in the series, but with the built in functions,\r\n\r\n593\r\n00:23:02.138 --> 00:23:04.082\r\nthere's a ton of stuff you can do.\r\n\r\n594\r\n00:23:04.082 --> 00:23:05.964\r\nSometimes you don't need to make your own function.\r\n\r\n595\r\n00:23:05.964 --> 00:23:07.106\r\nSometimes you just need to stick\r\n\r\n596\r\n00:23:07.106 --> 00:23:09.141\r\nmore than one function together\r\n\r\n597\r\n00:23:09.141 --> 00:23:11.495\r\nand now you can get what it is that you need.\r\n\r\n598\r\n00:23:11.495 --> 00:23:12.540\r\nMakes it more complex.\r\n\r\n599\r\n00:23:12.540 --> 00:23:14.215\r\nWould be nice to have one function\r\n\r\n600\r\n00:23:14.215 --> 00:23:15.723\r\nthat did it and made it easy,\r\n\r\n601\r\n00:23:15.723 --> 00:23:17.690\r\nbut you don't have to have that.\r\n\r\n602\r\n00:23:17.690 --> 00:23:19.740\r\nWhen you look at Microsoft's site,\r\n\r\n603\r\n00:23:19.740 --> 00:23:21.756\r\nwhat they're showing us are all those built ins.\r\n\r\n604\r\n00:23:21.756 --> 00:23:24.670\r\nAll the functions that come with the system.\r\n\r\n605\r\n00:23:24.670 --> 00:23:26.815\r\nThey've divided them into categories\r\n\r\n606\r\n00:23:26.815 --> 00:23:28.327\r\nbecause there's so many different things\r\n\r\n607\r\n00:23:28.327 --> 00:23:30.415\r\nthat you might be expecting to do\r\n\r\n608\r\n00:23:30.415 --> 00:23:33.006\r\nand some of these are super, super powerful.\r\n\r\n609\r\n00:23:33.006 --> 00:23:35.925\r\nMathematical, we use that all the time.\r\n\r\n610\r\n00:23:35.925 --> 00:23:38.551\r\nAny time you're doing math, it's easy to use a function\r\n\r\n611\r\n00:23:38.551 --> 00:23:40.423\r\nto call it and do it, and I'm talking about advanced math.\r\n\r\n612\r\n00:23:40.423 --> 00:23:43.735\r\nYou can do simple math just in regular SQL.\r\n\r\n613\r\n00:23:43.735 --> 00:23:46.523\r\nDoing crazy things, like cosine,\r\n\r\n614\r\n00:23:46.523 --> 00:23:48.108\r\nwhich granted, I don't do every single day,\r\n\r\n615\r\n00:23:48.108 --> 00:23:50.953\r\ndifferentials and integrals, you can do those as well\r\n\r\n616\r\n00:23:50.953 --> 00:23:53.455\r\nall through various functions that are available.\r\n\r\n617\r\n00:23:53.455 --> 00:23:55.702\r\nDate and time manipulations, data type,\r\n\r\n618\r\n00:23:55.702 --> 00:23:57.468\r\nthose are all really common ones.\r\n\r\n619\r\n00:23:57.468 --> 00:24:00.780\r\nThere's some edge case options in here,\r\n\r\n620\r\n00:24:00.780 --> 00:24:03.031\r\nsome that aren't used very often.\r\n\r\n621\r\n00:24:03.031 --> 00:24:04.939\r\nThings like OPENROWSET.\r\n\r\n622\r\n00:24:04.939 --> 00:24:07.979\r\nROWSET is really, really cool.\r\n\r\n623\r\n00:24:07.979 --> 00:24:11.887\r\nI might have all of my data in a Microsoft SQL server,\r\n\r\n624\r\n00:24:11.887 --> 00:24:14.691\r\nor I might have some data on one server\r\n\r\n625\r\n00:24:14.691 --> 00:24:16.332\r\nand some data on another server.\r\n\r\n626\r\n00:24:16.332 --> 00:24:18.960\r\nI might have some data in a Microsoft SQL server\r\n\r\n627\r\n00:24:18.960 --> 00:24:22.363\r\nand other data in JSON text files located somewhere else,\r\n\r\n628\r\n00:24:22.363 --> 00:24:24.487\r\nor XML or something like that.\r\n\r\n629\r\n00:24:24.487 --> 00:24:28.228\r\nYou can use OPENROWSET to be able to reach out\r\n\r\n630\r\n00:24:28.228 --> 00:24:30.789\r\nand talk to another server and be able to get data\r\n\r\n631\r\n00:24:30.789 --> 00:24:33.002\r\nfrom one of their tables and bring it into your table\r\n\r\n632\r\n00:24:33.002 --> 00:24:34.476\r\nand do a join and combine the stuff\r\n\r\n633\r\n00:24:34.476 --> 00:24:36.597\r\nand really get some amazing stuff.\r\n\r\n634\r\n00:24:36.597 --> 00:24:38.599\r\nIf it's an XML, if it's a query\r\n\r\n635\r\n00:24:38.599 --> 00:24:40.902\r\non another relational database server,\r\n\r\n636\r\n00:24:40.902 --> 00:24:43.726\r\nif it's a row on another Microsoft SQL server,\r\n\r\n637\r\n00:24:43.726 --> 00:24:47.781\r\nif it's a JSON file or just a straight up ODBC data source,\r\n\r\n638\r\n00:24:47.781 --> 00:24:51.698\r\nwhich means Oracle, MySQL, MariaDB, PostgreSQL,\r\n\r\n639\r\n00:24:53.343 --> 00:24:54.712\r\nall those other guys that are out there\r\n\r\n640\r\n00:24:54.712 --> 00:24:56.509\r\nthat you can connect to using OPENDATASOURCE,\r\n\r\n641\r\n00:24:56.509 --> 00:24:59.551\r\neven Microsoft Access, you can connect to that\r\n\r\n642\r\n00:24:59.551 --> 00:25:00.792\r\nand pull in data.\r\n\r\n643\r\n00:25:00.792 --> 00:25:02.666\r\nThat's really powerful stuff you can do\r\n\r\n644\r\n00:25:02.666 --> 00:25:04.320\r\nright here with a function.\r\n\r\n645\r\n00:25:04.320 --> 00:25:07.672\r\nYou'd be surprised the things that you can do,\r\n\r\n646\r\n00:25:07.672 --> 00:25:09.184\r\nbut you can go even further when\r\n\r\n647\r\n00:25:09.184 --> 00:25:11.143\r\nyou create a custom function, so I wanted to mention that\r\n\r\n648\r\n00:25:11.143 --> 00:25:12.117\r\nhere in this episode.\r\n\r\n649\r\n00:25:12.117 --> 00:25:13.792\r\nWe're not gonna do it here, but we'll see it\r\n\r\n650\r\n00:25:13.792 --> 00:25:15.175\r\nlater on in the series.\r\n\r\n651\r\n00:25:15.175 --> 00:25:17.331\r\nLet's focus on the ones that are built in to the system\r\n\r\n652\r\n00:25:17.331 --> 00:25:18.631\r\nbefore we start getting in there\r\n\r\n653\r\n00:25:18.631 --> 00:25:19.912\r\nand really kind of cranking in\r\n\r\n654\r\n00:25:19.912 --> 00:25:21.567\r\nand starting to customize things.\r\n\r\n655\r\n00:25:21.567 --> 00:25:23.671\r\n<v ->Well Don, I guess that leaves us with</v>\r\n\r\n656\r\n00:25:23.671 --> 00:25:26.013\r\none good question is, we've talked about\r\n\r\n657\r\n00:25:26.013 --> 00:25:28.893\r\nthe functions that are there, that are created\r\n\r\n658\r\n00:25:28.893 --> 00:25:30.602\r\nand available for us, then we have the ones\r\n\r\n659\r\n00:25:30.602 --> 00:25:32.008\r\nthat we can't create.\r\n\r\n660\r\n00:25:32.008 --> 00:25:33.175\r\nDo they have to be one or the other,\r\n\r\n661\r\n00:25:33.175 --> 00:25:34.653\r\ncan you combine the two as well?\r\n\r\n662\r\n00:25:34.653 --> 00:25:37.154\r\n<v ->Yeah, you can do a lot.</v>\r\n\r\n663\r\n00:25:37.154 --> 00:25:38.305\r\n(laughing)\r\n\r\n664\r\n00:25:38.305 --> 00:25:39.208\r\nAnd the sky's the limit.\r\n\r\n665\r\n00:25:39.208 --> 00:25:40.754\r\nIt really, it sounds kind of cheesy,\r\n\r\n666\r\n00:25:40.754 --> 00:25:42.952\r\nbut you're really only limited by your own knowledge.\r\n\r\n667\r\n00:25:42.952 --> 00:25:46.696\r\nFunctions, by definition, can do anything you can think of.\r\n\r\n668\r\n00:25:46.696 --> 00:25:49.072\r\nYou can write the code for it.\r\n\r\n669\r\n00:25:49.072 --> 00:25:50.455\r\nThere's times when a stored procedure\r\n\r\n670\r\n00:25:50.455 --> 00:25:52.183\r\nworks a little better, but the function,\r\n\r\n671\r\n00:25:52.183 --> 00:25:54.483\r\nit can do a ton of magic.\r\n\r\n672\r\n00:25:54.483 --> 00:25:55.946\r\nThe trick is just knowing what's available,\r\n\r\n673\r\n00:25:55.946 --> 00:25:57.405\r\nwhat's there, knowing that documentation,\r\n\r\n674\r\n00:25:57.405 --> 00:25:58.861\r\nthat's a big part of it.\r\n\r\n675\r\n00:25:58.861 --> 00:26:00.084\r\nNow, what I've shown you so far\r\n\r\n676\r\n00:26:00.084 --> 00:26:01.293\r\nwas basically an introduction.\r\n\r\n677\r\n00:26:01.293 --> 00:26:02.983\r\nWe saw how to use a function,\r\n\r\n678\r\n00:26:02.983 --> 00:26:04.423\r\nwe saw how to feed it some input,\r\n\r\n679\r\n00:26:04.423 --> 00:26:07.144\r\nand we saw some data come back, we rounded a number.\r\n\r\n680\r\n00:26:07.144 --> 00:26:08.402\r\nVery exciting.\r\n\r\n681\r\n00:26:08.402 --> 00:26:11.623\r\nYou can do that across entire tables,\r\n\r\n682\r\n00:26:11.623 --> 00:26:13.461\r\nand you can even do it in other areas\r\n\r\n683\r\n00:26:13.461 --> 00:26:15.799\r\nwhere you want more specialized data to come back,\r\n\r\n684\r\n00:26:15.799 --> 00:26:16.984\r\nand I want to talk about that,\r\n\r\n685\r\n00:26:16.984 --> 00:26:18.584\r\nbut I know I'm running a little bit low on time.\r\n\r\n686\r\n00:26:18.584 --> 00:26:19.503\r\n<v Daniel>Just a little bit.</v>\r\n\r\n687\r\n00:26:19.503 --> 00:26:21.395\r\n<v ->Let's do this, let's break in to part two,</v>\r\n\r\n688\r\n00:26:21.395 --> 00:26:24.005\r\nand in part two, I want to start talking about\r\n\r\n689\r\n00:26:24.005 --> 00:26:27.155\r\nthe different ways that functions --\r\n\r\n690\r\n00:26:27.155 --> 00:26:28.215\r\n<v Daniel>Function (laughing).</v>\r\n\r\n691\r\n00:26:28.215 --> 00:26:30.591\r\n<v ->Function, all right, it's kind of a bit redundant there.</v>\r\n\r\n692\r\n00:26:30.591 --> 00:26:33.217\r\nThere are actually different types.\r\n\r\n693\r\n00:26:33.217 --> 00:26:35.866\r\nWhen I look on Microsoft's site and I see mathematical,\r\n\r\n694\r\n00:26:35.866 --> 00:26:37.882\r\nthat's kind of a category of functions,\r\n\r\n695\r\n00:26:37.882 --> 00:26:39.188\r\nand there's all these different\r\n\r\n696\r\n00:26:39.188 --> 00:26:40.633\r\nmathematical functions available,\r\n\r\n697\r\n00:26:40.633 --> 00:26:43.153\r\nbut they work in different ways.\r\n\r\n698\r\n00:26:43.153 --> 00:26:45.063\r\nSome of them work one way,\r\n\r\n699\r\n00:26:45.063 --> 00:26:46.287\r\nothers work a slightly different way,\r\n\r\n700\r\n00:26:46.287 --> 00:26:47.387\r\nand it's important to understand\r\n\r\n701\r\n00:26:47.387 --> 00:26:48.971\r\nwhat type of data we're getting back,\r\n\r\n702\r\n00:26:48.971 --> 00:26:50.195\r\n'cause that's going to influence\r\n\r\n703\r\n00:26:50.195 --> 00:26:51.289\r\nthe way that we're able to use these.\r\n\r\n704\r\n00:26:51.289 --> 00:26:52.604\r\nI want to spend some time on that,\r\n\r\n705\r\n00:26:52.604 --> 00:26:54.116\r\nand we'll have to do that in part two.\r\n\r\n706\r\n00:26:54.116 --> 00:26:55.177\r\n<v ->All right, not a problem,</v>\r\n\r\n707\r\n00:26:55.177 --> 00:26:56.761\r\nwe'll definitely break out into that part two.\r\n\r\n708\r\n00:26:56.761 --> 00:26:58.220\r\nDefinitely join us back there.\r\n\r\n709\r\n00:26:58.220 --> 00:26:59.749\r\nDon, thanks for getting us this far\r\n\r\n710\r\n00:26:59.749 --> 00:27:02.251\r\nand when it comes to functions inside of T-SQL\r\n\r\n711\r\n00:27:02.251 --> 00:27:04.595\r\nlooking forward to seeing how that culminates\r\n\r\n712\r\n00:27:04.595 --> 00:27:07.292\r\nin some of the more advanced functionality in part two.\r\n\r\n713\r\n00:27:07.292 --> 00:27:08.444\r\nJoin us for that.\r\n\r\n714\r\n00:27:08.444 --> 00:27:09.615\r\nAs for this episode, though,\r\n\r\n715\r\n00:27:09.615 --> 00:27:11.179 line:15% \r\nwe're going to go ahead and call it a day.\r\n\r\n716\r\n00:27:11.179 --> 00:27:13.859 line:15% \r\nSigning off for ITPro.TV, I've been your host Daniel Lowrie.\r\n\r\n717\r\n00:27:13.859 --> 00:27:15.028 line:15% \r\n<v ->And I'm Don Pezet.</v>\r\n\r\n718\r\n00:27:15.028 --> 00:27:17.549 line:15% \r\n<v ->We'll see you next time.</v>\r\n\r\n719\r\n00:27:17.549 --> 00:27:20.216 line:15% \r\n(intense music)\r\n\r\n720\r\n00:27:23.527 --> 00:27:27.444\r\n<v Announcer>Thank you for watching ITPro.TV.`</v>\r\n\r\n",
          "vimeoId": "245016305"
        },
        {
          "description": "In this episode, Don continues exploring functions in Transact-SQL. He explains some of the variations found between functions. Examples include scalar vs table-valued functions as well as deterministic vs non-deterministic functions",
          "length": "982",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-1-2-querying_data_with_functions_pt2-112817-PGM.00_17_55_11.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-1-2-querying_data_with_functions_pt2-112817-PGM.00_17_55_11.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-1-2-querying_data_with_functions_pt2-112817-PGM.00_17_55_11.Still001-sm.jpg",
          "title": "Querying Data with Functions Part 2",
          "transcript": "",
          "vimeoId": "245015279"
        },
        {
          "description": "In this episode, Don demonstrates how to combine multiple results together in order to meet the needs of your organization. He shows how to use the GROUP BY and HAVING clauses to aggregate results into a smaller data set.",
          "length": "2040",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-2-1-aggregating_data-112817-PGM.00_34_53_08.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-2-1-aggregating_data-112817-PGM.00_34_53_08.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-2-1-aggregating_data-112817-PGM.00_34_53_08.Still001-sm.jpg",
          "title": "Aggregating Data",
          "transcript": "",
          "vimeoId": "245013906"
        },
        {
          "description": "In this episode, Don continues working with functions in Transact-SQL. This time, he focuses on performing arithmetic by making use of the numerous matehmatical functions included with T-SQL.",
          "length": "1354",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-3-1-performing_arithmetic-112917-PGM.00_25_11_19.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-3-1-performing_arithmetic-112917-PGM.00_25_11_19.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-3-1-performing_arithmetic-112917-PGM.00_25_11_19.Still001-sm.jpg",
          "title": "Performing Arithmetic",
          "transcript": "",
          "vimeoId": "245248884"
        },
        {
          "description": "In this episode, Don examins how Transact-SQL handles dates. He demontrates multiple ways to retrieve the current date and time from a SQL server. He then demonstrates a series of functions that can be used to modify the date to support your queries.",
          "length": "1682",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-4-1-working_with_dates-112917-PGM.00_30_09_23.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-4-1-working_with_dates-112917-PGM.00_30_09_23.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-4-1-working_with_dates-112917-PGM.00_30_09_23.Still001-sm.jpg",
          "title": "Working with Dates",
          "transcript": "",
          "vimeoId": "245249890"
        },
        {
          "description": "In this episode, Don wraps up the series on functions by examining some of the system functions built into Microsoft SQL server. He explains how user and session data can be retrieved and then demonstrates how to combine that data with the OUTPUT clause to create a better logging and auditing solution.",
          "length": "1713",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-5-1-system_functions-112917-PGM.00_28_19_17.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-5-1-system_functions-112917-PGM.00_28_19_17.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-3-5-1-system_functions-112917-PGM.00_28_19_17.Still001-sm.jpg",
          "title": "System Functions",
          "transcript": "",
          "vimeoId": "245250429"
        }
      ],
      "title": "Working with Functions"
    },
    {
      "episodes": [
        {
          "description": "In this episode, Don introduces the viewers to SQL data types. He explains what data types do and then walks the viewers through several of the default data types found in Microsoft SQL Server. He ends the show by demonstrating how data types can support and interfere with your queries.",
          "length": "1935",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-1-1-data_types-121117-PGM.00_32_02_19.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-1-1-data_types-121117-PGM.00_32_02_19.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-1-1-data_types-121117-PGM.00_32_02_19.Still001-sm.jpg",
          "title": "Data Types",
          "transcript": "",
          "vimeoId": "247018066"
        },
        {
          "description": "In this episode, Don continues discussing SQL data types. He demonstrates how data types can effect your queries. At the end of the show, he discusses the IDENTITY special modifier that can significantly impact how data types are applied.",
          "length": "1422",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-1-2-data_types_pt2-121117.00_23_30_06.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-1-2-data_types_pt2-121117.00_23_30_06.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-1-2-data_types_pt2-121117.00_23_30_06.Still001-sm.jpg",
          "title": "Data Types Part 2",
          "transcript": "",
          "vimeoId": "247018623"
        },
        {
          "description": "In this episode, Don discusses how you can create custom data types to meet the needs of your organization. He explains how programatic data types can be developed with the Microsoft .NET Framework and he also shows how custom data types can be easily deployed via aliases in Transact-SQL.",
          "length": "886",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-2-1-custom_data_types-121117.00_14_34_17.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-2-1-custom_data_types-121117.00_14_34_17.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-2-1-custom_data_types-121117.00_14_34_17.Still001-sm.jpg",
          "title": "Custom Data Types",
          "transcript": "",
          "vimeoId": "247018416"
        },
        {
          "description": "a",
          "length": "1450",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-3-1-converting_data_types-121217-PGM.00_23_56_20.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-3-1-converting_data_types-121217-PGM.00_23_56_20.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-3-1-converting_data_types-121217-PGM.00_23_56_20.Still001-sm.jpg",
          "title": "Converting Data Types",
          "transcript": "",
          "vimeoId": "247018890"
        },
        {
          "description": "In this episode, Don explains the challenges of working with multiple data types. He then demonstrates how to use CAST and CONVERT to alter the data type of query results to meet our needs.",
          "length": "1275",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-3-2-converting_data_types_pt2-121217-PGM.00_22_39_13.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-3-2-converting_data_types_pt2-121217-PGM.00_22_39_13.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-3-2-converting_data_types_pt2-121217-PGM.00_22_39_13.Still001-sm.jpg",
          "title": "Converting Data Types Part 2",
          "transcript": "",
          "vimeoId": "247151390"
        },
        {
          "description": "In this episode, Don explains how NULL values can impact our queries. He then demonstrates using CASE, ISNULL and COALESCE to ensure we get the results we need.",
          "length": "1765",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-4-1-conditions_and_nulls-121317-PGM.00_29_11_29.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-4-1-conditions_and_nulls-121317-PGM.00_29_11_29.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-4-4-1-conditions_and_nulls-121317-PGM.00_29_11_29.Still001-sm.jpg",
          "title": "Conditions and Nulls",
          "transcript": "WEBVTT\n\n1\n00:00:00.240 --> 00:00:01.354\nWelcome to ITProTV.\n\n2\n00:00:01.354 --> 00:00:02.415\nI'm your host Don.\n\n3\n00:00:02.415 --> 00:00:06.528\n[CROSSTALK]\n\n4\n00:00:06.528 --> 00:00:08.263\n[MUSIC]\n\n5\n00:00:08.263 --> 00:00:11.480\n&gt;&gt; You're watching ITProTV.\n\n6\n00:00:11.480 --> 00:00:12.022\n&gt;&gt; Hello and\n\n7\n00:00:12.022 --> 00:00:16.210\nthank you for choosing ITProTV\nhelping you learn everywhere you go.\n\n8\n00:00:16.210 --> 00:00:20.700\nI'm your host Zach Memos as we continue\non with querying data with Transact-SQL.\n\n9\n00:00:20.700 --> 00:00:23.230\nIn this episode, conditions and NULLs.\n\n10\n00:00:23.230 --> 00:00:25.375\nAha, that's interesting topics.\n\n11\n00:00:25.375 --> 00:00:27.650\n[LAUGH] And if I'm getting talking\nwith Don Pezet about that.\n\n12\n00:00:27.650 --> 00:00:29.210\nDon great to have you here, thanks.\n\n13\n00:00:29.210 --> 00:00:29.729\n&gt;&gt; Great to be back Zack.\n\n14\n00:00:29.729 --> 00:00:32.420\nLike you said we are gonna talk about\nconditions and NULLs during this episode.\n\n15\n00:00:32.420 --> 00:00:35.486\nAnd I know those are two terms that\nwe haven't really worked with so\n\n16\n00:00:35.486 --> 00:00:39.266\nfar that I've thrown together, if you've\nbeen watching the episodes in order,\n\n17\n00:00:39.266 --> 00:00:42.150\nwe've spent the last few\ntalking about datatypes.\n\n18\n00:00:42.150 --> 00:00:45.340\nAnd there's some special\nscenarios that can occur\n\n19\n00:00:45.340 --> 00:00:47.910\nthat kind of goes along with data\ntypes that I wanted to cover,\n\n20\n00:00:47.910 --> 00:00:50.610\nbut didn't quite fit into\nany of those episodes.\n\n21\n00:00:50.610 --> 00:00:55.280\nSo this one is gonna be a little more\nlike in TV when they do the recap episode\n\n22\n00:00:55.280 --> 00:00:58.810\nwhere we'll throw together a couple\nof topics that just didn't quite fit.\n\n23\n00:00:58.810 --> 00:01:02.200\nWe're gonna talk about conditions\napplied with the CASE command.\n\n24\n00:01:02.200 --> 00:01:06.446\nWe're gonna talk about testing for\nnulls using is NULL and is not NULL.\n\n25\n00:01:06.446 --> 00:01:08.890\nAnd we're gonna talk a little\nbit about the coalesce command.\n\n26\n00:01:08.890 --> 00:01:13.294\nAll three help us to deal with situations\nwhere you have null values, and how you\n\n27\n00:01:13.294 --> 00:01:17.897\ncan handle that, because it doesn't matter\nwhat data type you've got assigned,\n\n28\n00:01:17.897 --> 00:01:19.757\nif a value is NULL, it's empty.\n\n29\n00:01:19.757 --> 00:01:21.302\nAnd we've got to know how to handle and\n\n30\n00:01:21.302 --> 00:01:23.290\nwork with that, so\nit doesn't break our query.\n\n31\n00:01:23.290 --> 00:01:25.960\nSo we're gonna see all that\nright here in this episode.\n\n32\n00:01:25.960 --> 00:01:28.800\n&gt;&gt; So Dylan, what kind of\nconditions can we implement in SQL?\n\n33\n00:01:28.800 --> 00:01:33.340\n&gt;&gt; All right, so conditions,\nif you think about the word conditions,\n\n34\n00:01:33.340 --> 00:01:34.510\nit can mean a lot of things.\n\n35\n00:01:34.510 --> 00:01:38.970\nLike you can give somebody an ultimatum,\nthat you clean your room or\n\n36\n00:01:38.970 --> 00:01:40.135\nyou're grounded for six months.\n\n37\n00:01:40.135 --> 00:01:42.226\n&gt;&gt; [LAUGH]\n&gt;&gt; And so that's the conditions that you\n\n38\n00:01:42.226 --> 00:01:44.170\ngive them, like terms of surrender.\n\n39\n00:01:44.170 --> 00:01:49.241\nBut a condition can also be used for\nother things to say like,\n\n40\n00:01:49.241 --> 00:01:55.120\nif a certain test comes back with one\nresult then we make one decision.\n\n41\n00:01:55.120 --> 00:01:57.630\nIf a test comes back with a different\nresult we make a different decision.\n\n42\n00:01:57.630 --> 00:01:59.520\nAnd we can do the same\nthing with our data.\n\n43\n00:01:59.520 --> 00:02:03.840\nWe can say, hey if there's a value present\nwe're going to take one action, and\n\n44\n00:02:03.840 --> 00:02:06.650\nif it's NULL or if it's empty,\nwe'll take some other action, or\n\n45\n00:02:06.650 --> 00:02:08.860\nwe'll put a fake value in there.\n\n46\n00:02:08.860 --> 00:02:12.840\nMaybe it's, you've got an orders table,\nand in the orders table,\n\n47\n00:02:12.840 --> 00:02:16.300\nwhen somebody buys something,\nthere's a dollar value associated with it.\n\n48\n00:02:16.300 --> 00:02:18.445\nWell, maybe the order was voided,\nso it never went through, so\n\n49\n00:02:18.445 --> 00:02:20.573\nthere is no dollar value associated\nwith it, it's just NULL.\n\n50\n00:02:20.573 --> 00:02:23.570\nWell in a report,\nthat's gonna screw things up.\n\n51\n00:02:23.570 --> 00:02:28.450\nSo instead, I might create a condition\nthat says, if I find an order\n\n52\n00:02:28.450 --> 00:02:33.080\nthat has a NULL value assigned for\nits dollar amount, make it a zero instead.\n\n53\n00:02:33.080 --> 00:02:36.490\nAnd now I give it this criteria of,\nwell make it a zero, and\n\n54\n00:02:36.490 --> 00:02:37.630\na zero won't break my report.\n\n55\n00:02:37.630 --> 00:02:40.340\nNow I see, yeah, there was a $0\ntransaction because it was a void.\n\n56\n00:02:40.340 --> 00:02:42.000\nIt makes sense.\n\n57\n00:02:42.000 --> 00:02:46.810\nSo that's what conditions are all about\nis defining how to change data from\n\n58\n00:02:46.810 --> 00:02:49.660\none particular value to another\nunder certain circumstances.\n\n59\n00:02:49.660 --> 00:02:53.770\nIt's an incredibly useful\nthing in other areas as well.\n\n60\n00:02:53.770 --> 00:02:56.308\nThe command that we use\nis actually called CASE.\n\n61\n00:02:56.308 --> 00:02:56.839\n&gt;&gt; Mm-hm.\n\n62\n00:02:56.839 --> 00:03:02.034\n&gt;&gt; So think about just in case.\n\n63\n00:03:02.034 --> 00:03:06.590\nSo in case this happens to be one thing,\nI'm gonna do this other.\n\n64\n00:03:06.590 --> 00:03:10.040\nSo we're kind of planning contingencies\nwith how the data comes through.\n\n65\n00:03:10.040 --> 00:03:11.302\nAnd we can use it for\na lot of really cool things.\n\n66\n00:03:11.302 --> 00:03:16.345\nMaybe I want to have a database\nthat indexes all the movies.\n\n67\n00:03:16.345 --> 00:03:21.266\nSo I've got all these movies indexed and\nin each line, each row I've got the movie\n\n68\n00:03:21.266 --> 00:03:24.990\ntitle, the director, the actors,\nand the year it came out.\n\n69\n00:03:26.200 --> 00:03:30.250\nWell, in the movie world,\nthey have these, they call them the ages.\n\n70\n00:03:30.250 --> 00:03:32.110\nLike the age of the silver screen, and\n\n71\n00:03:32.110 --> 00:03:37.360\nthen you have your classic movies which\nall came out mostly in the 20s to 40s.\n\n72\n00:03:37.360 --> 00:03:38.300\n&gt;&gt; Like genres.\n\n73\n00:03:38.300 --> 00:03:38.850\n&gt;&gt; Yeah.\n\n74\n00:03:38.850 --> 00:03:39.795\n&gt;&gt; Yeah.\n\n75\n00:03:39.795 --> 00:03:42.200\n&gt;&gt; And I might not store that\nin the database to say like,\n\n76\n00:03:42.200 --> 00:03:45.600\nthis movie came out in 1925, and\nso it's considered a classic.\n\n77\n00:03:45.600 --> 00:03:50.640\nThis other movie came out in 1997, it's\nnot considered a classic, it's modern.\n\n78\n00:03:50.640 --> 00:03:55.180\nSo, I could use a condition to say,\nwhen I retrieve this data,\n\n79\n00:03:55.180 --> 00:04:00.500\ndon't show me that the movie was made in\n1920, show me that the movie is classic.\n\n80\n00:04:00.500 --> 00:04:06.635\nAnd I can set that up to say,\nif the year is between 1910 and\n\n81\n00:04:06.635 --> 00:04:09.370\n1940, show that it's a classic.\n\n82\n00:04:09.370 --> 00:04:16.440\nIf it's between 1941 and 1980, show it\nas a vintage, or something like that.\n\n83\n00:04:16.440 --> 00:04:18.560\nAnd then if it's 1980 or\nnewer, show it as modern.\n\n84\n00:04:18.560 --> 00:04:20.400\nAnd so I'm changing the value.\n\n85\n00:04:20.400 --> 00:04:25.180\nIn the database, I actually have a number\nstored but I don't want that in my report.\n\n86\n00:04:25.180 --> 00:04:27.450\nI want to know which of these\ncriterias it falls under.\n\n87\n00:04:27.450 --> 00:04:30.210\nOr you might do it like low risk,\nmoderate, high risk or\n\n88\n00:04:30.210 --> 00:04:31.840\nhowever it is you want to classify things.\n\n89\n00:04:31.840 --> 00:04:34.280\nThat's what the CASE command lets us do.\n\n90\n00:04:34.280 --> 00:04:39.280\nAnd if you got NULLs you can say,\nif it's NULL put it like this and\n\n91\n00:04:39.280 --> 00:04:40.770\nhave it say, unknown.\n\n92\n00:04:40.770 --> 00:04:43.065\nOr have it say zero, or\nhave a say whatever you want.\n\n93\n00:04:43.065 --> 00:04:47.250\nSo you can test and check for that,\nand now you've got a value provided.\n\n94\n00:04:47.250 --> 00:04:50.030\nThat's gonna help ensure that\nwhen you run your queries,\n\n95\n00:04:50.030 --> 00:04:52.035\nif you come across a NULL value,\nit won't break your query.\n\n96\n00:04:52.035 --> 00:04:53.045\nIt doesn't mess things up.\n\n97\n00:04:53.045 --> 00:04:56.830\nEspecially if you're grouping by a column,\nthen any NULL value in there will get\n\n98\n00:04:56.830 --> 00:05:00.350\ngrouped together based on this NULL,\nbased on this absence of something.\n\n99\n00:05:00.350 --> 00:05:01.928\nIt's not normally something\nyou want to group by.\n\n100\n00:05:01.928 --> 00:05:05.340\nWell here, we can change it to a different\nvalue and it makes a little more sense.\n\n101\n00:05:06.700 --> 00:05:10.030\n&gt;&gt; Can you give us an example\nof how CASE is gonna be used?\n\n102\n00:05:10.030 --> 00:05:12.410\n&gt;&gt; Yeah, sure,\nthe CASE command is kind of a weird one.\n\n103\n00:05:12.410 --> 00:05:15.050\nSo the way the syntax works for\nit is strange.\n\n104\n00:05:15.050 --> 00:05:16.370\nLet me show you how it works.\n\n105\n00:05:16.370 --> 00:05:18.020\nI'm gonna pull some data out of a table.\n\n106\n00:05:18.020 --> 00:05:21.850\nAnd I'm not gonna use the CASE\ncommand right here in the beginning.\n\n107\n00:05:21.850 --> 00:05:23.940\nI'm just gonna do a straight\nup SELECT statement.\n\n108\n00:05:23.940 --> 00:05:28.060\nI'm gonna SELECT the ProductID and\n\n109\n00:05:28.060 --> 00:05:31.970\nthe name from a table.\n\n110\n00:05:31.970 --> 00:05:36.500\nSo I'm pulling just these two columns,\nand I'm gonna pull them from\n\n111\n00:05:36.500 --> 00:05:41.340\nthe Production.Product table.\n\n112\n00:05:41.340 --> 00:05:44.140\nSo that's what I'm gonna query, and\nI'm gonna get some information back.\n\n113\n00:05:44.140 --> 00:05:48.090\nSo I'm seeing a list of my products and\ntheir ProductID.\n\n114\n00:05:48.090 --> 00:05:52.513\nAnd if I look around in there, you know,\nthis is just standard information here,\n\n115\n00:05:52.513 --> 00:05:56.758\nthey each have their ProductIDs, and\nI shouldn't have any NULL values in here.\n\n116\n00:05:56.758 --> 00:06:00.570\nWhen you create a table like this,\nit's gotta have some critical things.\n\n117\n00:06:00.570 --> 00:06:02.180\nA ProductID is pretty critical.\n\n118\n00:06:02.180 --> 00:06:05.750\nSo that's more than likely an identity\ncolumn, or at least a unique column,\n\n119\n00:06:05.750 --> 00:06:08.050\nto ensure I don't have two\nproducts with the same ID.\n\n120\n00:06:08.050 --> 00:06:10.080\nSo I don't expect to find any NULLs.\n\n121\n00:06:10.080 --> 00:06:11.210\nThere's 500 rows though, and\n\n122\n00:06:11.210 --> 00:06:13.188\nI don't expect to stand here and\nlook at each one either.\n\n123\n00:06:13.188 --> 00:06:13.840\n&gt;&gt; [LAUGH] No.\n\n124\n00:06:13.840 --> 00:06:15.460\n&gt;&gt; But\nodds are there's not gonna be any NULLs.\n\n125\n00:06:15.460 --> 00:06:17.360\nI'll bring in some columns\nwith NULLs in a moment.\n\n126\n00:06:17.360 --> 00:06:20.238\nBut right now as I look\nat these ProductIDs,\n\n127\n00:06:20.238 --> 00:06:24.590\neach ProductID is incrementing\nby a certain number.\n\n128\n00:06:24.590 --> 00:06:28.840\nAnd maybe there's categories\nassociated with these numbers.\n\n129\n00:06:28.840 --> 00:06:33.900\nSo for example, this sample database that\nMicrosoft provides, it's supposed to be a,\n\n130\n00:06:33.900 --> 00:06:37.180\nlike a sports outfitter,\na company that sells outdoor equipment.\n\n131\n00:06:37.180 --> 00:06:39.150\n&gt;&gt; Mm-hm.\n&gt;&gt; And a lot of them are bike parts.\n\n132\n00:06:39.150 --> 00:06:40.850\nSo when you look you see baring ball and\n\n133\n00:06:40.850 --> 00:06:45.060\nbike wash and other things that\nare kind of bicycle related.\n\n134\n00:06:45.060 --> 00:06:49.920\nSo maybe I've got categories,\nwhere if it's a mountain bike,\n\n135\n00:06:49.920 --> 00:06:53.163\nthen the ProductID will be in the 200s.\n\n136\n00:06:53.163 --> 00:06:57.820\nAnd if it's a street bike\na ProductID will be in the 300s.\n\n137\n00:06:57.820 --> 00:07:01.031\nOr if it's a racing bike\nthe ProductID will be in the 400s.\n\n138\n00:07:01.031 --> 00:07:03.898\nSo I might want to add another\ncolumn here that shows me,\n\n139\n00:07:03.898 --> 00:07:07.254\nis it a mountain bike, a racing bike,\na street bike, what is it?\n\n140\n00:07:07.254 --> 00:07:12.520\nAnd based on what that ProductID is,\nI can use CASE to do that.\n\n141\n00:07:12.520 --> 00:07:16.210\nIn CASE, the ProductID is this number,\n\n142\n00:07:16.210 --> 00:07:19.470\nthen the category will be this\nother thing, so we can define that.\n\n143\n00:07:19.470 --> 00:07:22.330\nAnd that's what makes this a little\nweird is we have to communicate all that\n\n144\n00:07:22.330 --> 00:07:23.850\nin Transact-SQL.\n\n145\n00:07:23.850 --> 00:07:27.680\nSo the way it looks is we just\ntake a query like this, and\n\n146\n00:07:27.680 --> 00:07:31.150\nwe're gonna add what is\neffectively a derived column.\n\n147\n00:07:31.150 --> 00:07:33.860\nI want a column called Category.\n\n148\n00:07:33.860 --> 00:07:37.480\nSo I'm gonna be creating this Category,\nor I might call it product category so\n\n149\n00:07:37.480 --> 00:07:39.720\nI don't overlap with something,\nbut I'll just call it Category.\n\n150\n00:07:40.860 --> 00:07:42.050\nAnd I need to derive that.\n\n151\n00:07:42.050 --> 00:07:44.690\nWell I'm gonna derive\nit from a CASE command.\n\n152\n00:07:44.690 --> 00:07:49.150\nSo I'm gonna just press Enter\na couple times to make some room.\n\n153\n00:07:49.150 --> 00:07:52.130\nAnd after the SELECT statement,\nI pick my first two columns,\n\n154\n00:07:52.130 --> 00:07:53.530\nthose come right out of the table.\n\n155\n00:07:53.530 --> 00:07:55.783\nAnd then I'm gonna say CASE.\n\n156\n00:07:55.783 --> 00:07:58.101\nAnd technically,\nthis is another column name.\n\n157\n00:07:58.101 --> 00:08:02.522\nSee, I'm still before the FROM command,\nFROM is when we switch over to do WHERE,\n\n158\n00:08:02.522 --> 00:08:04.909\nORDER BY and HAVING, all that other stuff.\n\n159\n00:08:04.909 --> 00:08:06.426\nSo I'm still before that.\n\n160\n00:08:06.426 --> 00:08:08.782\nI'm in my column name area.\n\n161\n00:08:08.782 --> 00:08:10.236\nI'm gonna say case.\n\n162\n00:08:10.236 --> 00:08:15.450\nAnd then I can define\na series of conditions.\n\n163\n00:08:15.450 --> 00:08:18.600\nIf this one thing happens,\ndo this other thing.\n\n164\n00:08:18.600 --> 00:08:23.070\nAnd after I define all those\nconditions I need the word AND\n\n165\n00:08:23.070 --> 00:08:25.670\nto let it know the conditions are over.\n\n166\n00:08:25.670 --> 00:08:29.760\nAnd then I can say that I want this to be\nnamed the category column as category.\n\n167\n00:08:29.760 --> 00:08:34.840\nSo that's just gonna be one column that\ngoes inside of this query for a result.\n\n168\n00:08:34.840 --> 00:08:39.000\nAnd all the conditions, I'll list\nright here in between case and end.\n\n169\n00:08:39.000 --> 00:08:42.470\nI'm gonna do four conditions for this one.\n\n170\n00:08:42.470 --> 00:08:44.710\nJust to give us some good examples here.\n\n171\n00:08:44.710 --> 00:08:46.960\nThe way you write these conditions,\nthat's really easy.\n\n172\n00:08:46.960 --> 00:08:50.170\nMost of the time you're gonna be\ndoing mathematical comparisons.\n\n173\n00:08:50.170 --> 00:08:54.720\nAnd so you can use greater than, equal,\ngreater than or equal, not equal.\n\n174\n00:08:54.720 --> 00:08:57.620\nSo you can use all those modifiers\nthat we saw way back in the beginning\n\n175\n00:08:57.620 --> 00:08:58.550\nof the series.\n\n176\n00:08:58.550 --> 00:09:02.140\nI'm gonna say when ProductId\n\n177\n00:09:04.640 --> 00:09:08.330\nis greater than or equal to 300, and\n\n178\n00:09:10.340 --> 00:09:14.660\nProductID is less than 400.\n\n179\n00:09:14.660 --> 00:09:20.820\nSo if it is from 300 all the way to 399,\nthis condition will be met.\n\n180\n00:09:20.820 --> 00:09:27.510\nAnd then I will say, Then this column\nwill have a value of mountain.\n\n181\n00:09:27.510 --> 00:09:30.670\nThose are my mountain bikes, right?\n\n182\n00:09:30.670 --> 00:09:34.810\nAnd after that, I can then start\nto list my other requirements.\n\n183\n00:09:34.810 --> 00:09:38.090\nAnd since I've already got this one\nwritten I can cheat just a little bit\n\n184\n00:09:38.090 --> 00:09:41.750\nhere, and I can copy and\npaste it, save it some time.\n\n185\n00:09:41.750 --> 00:09:45.320\nAnd so I'm gonna come through,\nand whoops, and paste that.\n\n186\n00:09:45.320 --> 00:09:47.990\nAnd I'm just gonna change the numbers\nto match with what I want.\n\n187\n00:09:47.990 --> 00:09:51.985\nThis next one's gonna be 400 through\n499 and then 500 through 599.\n\n188\n00:09:51.985 --> 00:09:55.144\nSo I just need to update\nthese values to reflect that.\n\n189\n00:09:55.144 --> 00:09:57.569\nOkay, and, I don't want them\nall to be mountain bikes.\n\n190\n00:09:57.569 --> 00:10:03.223\nI'll do road bikes and\ntouring bikes, like that.\n\n191\n00:10:03.223 --> 00:10:05.623\nOkay, so there's my three conditions.\n\n192\n00:10:05.623 --> 00:10:10.138\nNow, I could stop here, but\nI'm going to have a little problem, right?\n\n193\n00:10:10.138 --> 00:10:11.744\nWhat about this guy?\n\n194\n00:10:11.744 --> 00:10:15.816\nWho has a product idea of one, or\nthis guy who has a product idea of 712?\n\n195\n00:10:15.816 --> 00:10:17.013\nWhere do they fit?\n\n196\n00:10:17.013 --> 00:10:19.029\nThey don't match any of my cases, right?\n\n197\n00:10:19.029 --> 00:10:22.726\nIf somebody has a null,\nthey're not going to match my case.\n\n198\n00:10:22.726 --> 00:10:27.624\nSo what you typically wanna do is\nadd one more entry, that says, else.\n\n199\n00:10:27.624 --> 00:10:30.498\nSo if nothing matches, what do you put?\n\n200\n00:10:30.498 --> 00:10:35.342\nAnd I'll just put that that is\na uncategorized bike, or parked or\n\n201\n00:10:35.342 --> 00:10:37.027\nwhatever it is right.\n\n202\n00:10:37.027 --> 00:10:38.421\nIt's uncategorized.\n\n203\n00:10:38.421 --> 00:10:42.111\nSo that's the text that is gonna\nmake up this third column.\n\n204\n00:10:42.111 --> 00:10:46.225\nAnd it's all being build based off\nof whatever it is in the product id,\n\n205\n00:10:46.225 --> 00:10:48.401\nthe ranges that I'm defining here.\n\n206\n00:10:48.401 --> 00:10:52.174\nThese are conditional statements they\nare gonna result and derive columns so\n\n207\n00:10:52.174 --> 00:10:54.330\nI actually get the information.\n\n208\n00:10:54.330 --> 00:10:57.300\nAnd if I run that It runs, and\n\n209\n00:10:57.300 --> 00:11:00.220\nthen right over here on the left\nside I start to see that category.\n\n210\n00:11:00.220 --> 00:11:03.400\nAnd I've got a bunch of uncategorized\nones right here at the beginning.\n\n211\n00:11:03.400 --> 00:11:07.010\nSo I should probably sort\nthis thing by category,\n\n212\n00:11:07.010 --> 00:11:09.110\nbut I'm going to just kind of\nscroll down and we'll find some.\n\n213\n00:11:09.110 --> 00:11:10.295\nHere we go.\n\n214\n00:11:10.295 --> 00:11:11.579\nThere's some mountain bikes, right?\n\n215\n00:11:11.579 --> 00:11:14.486\nThese are ones that are between 300 and\n399.\n\n216\n00:11:14.486 --> 00:11:15.965\nSo I can see those mountain bikes.\n\n217\n00:11:15.965 --> 00:11:18.344\nI'm sure I've got some others touring.\n\n218\n00:11:18.344 --> 00:11:22.003\nRight there, that one's got a ID of 505,\nso it's showing his touring and so\n\n219\n00:11:22.003 --> 00:11:22.612\non, right?\n\n220\n00:11:22.612 --> 00:11:25.331\nEach one is populated with a value.\n\n221\n00:11:25.331 --> 00:11:29.502\nAnd because I have an L statement,\neven if somebody had a null value\n\n222\n00:11:29.502 --> 00:11:33.239\nIt won't be empty here,\nit'll actually have something.\n\n223\n00:11:33.239 --> 00:11:35.749\nIt will say, uncategorized,\nit'll fill it in.\n\n224\n00:11:35.749 --> 00:11:39.593\nBut I can put in as many of these\nconditions as I want to achieve my goal\n\n225\n00:11:39.593 --> 00:11:41.492\nand get it all set up and in place.\n\n226\n00:11:41.492 --> 00:11:43.361\n&gt;&gt; Well Don, what if the value is null?\n\n227\n00:11:43.361 --> 00:11:45.922\n&gt;&gt; All right, so it's one thing for\nme to say it'll work, but\n\n228\n00:11:45.922 --> 00:11:49.014\nI didn't actually have any null values,\nso we didn't see it, right?\n\n229\n00:11:49.014 --> 00:11:51.963\nSo let me show you an example\nthat does involve a null,\n\n230\n00:11:51.963 --> 00:11:54.662\nI'm gonna bring in a little\nmore data into this.\n\n231\n00:11:54.662 --> 00:11:58.890\nNow the else should catch\nany no value that I have.\n\n232\n00:11:58.890 --> 00:12:03.770\nLet's assume it's not\nrequired I'm just not sure.\n\n233\n00:12:03.770 --> 00:12:08.600\nNow we can check and see if it is no and\nthen take some kind of action.\n\n234\n00:12:08.600 --> 00:12:13.104\nYou actually have a command\nwhich is the ISNULL.\n\n235\n00:12:13.104 --> 00:12:14.480\nSee how that turned purple?\n\n236\n00:12:14.480 --> 00:12:16.763\nThat's letting you know that you can test.\n\n237\n00:12:16.763 --> 00:12:20.453\nSo up here when we say when product\nID is greater than or equal.\n\n238\n00:12:20.453 --> 00:12:24.102\nWhen product ID is null.\n\n239\n00:12:24.102 --> 00:12:26.929\nAnd it'll do a test to\nfind out is it null?\n\n240\n00:12:26.929 --> 00:12:27.999\nIs it empty?\n\n241\n00:12:27.999 --> 00:12:34.299\nAnd if it is empty, the more that we do,\nand that's a lot different than saying,\n\n242\n00:12:34.299 --> 00:12:39.041\nwhere project id equals, and\nthen two back ticks like that.\n\n243\n00:12:39.041 --> 00:12:41.073\nBecause, that's not null.\n\n244\n00:12:41.073 --> 00:12:46.145\nThat's just a blank and\nsince they're ruling null in the database,\n\n245\n00:12:46.145 --> 00:12:50.612\nyou need to be testing for\nactual nulls and looking for that.\n\n246\n00:12:50.612 --> 00:12:55.628\nSo the ISNULL command is pretty handy one\nto use to be able to track that down.\n\n247\n00:12:55.628 --> 00:12:58.534\nIf you wanna see an example,\nlet's see how can I leverage that.\n\n248\n00:12:58.534 --> 00:13:02.494\nI'm gonna bring in another\ncolumn which is going\n\n249\n00:13:02.494 --> 00:13:06.077\nto be the Product Subcategory, all right?\n\n250\n00:13:06.077 --> 00:13:10.351\nSo it turns out in my company I've\ngot not just a ProductID, but\n\n251\n00:13:10.351 --> 00:13:12.379\nI also have a SubcategoryID.\n\n252\n00:13:12.379 --> 00:13:15.693\nSo maybe inside of mountain bikes,\nI then break it up by brand,\n\n253\n00:13:15.693 --> 00:13:16.824\na lot of bike brands.\n\n254\n00:13:16.824 --> 00:13:21.069\nMaybe it's like Huffy and Mongoose and\nwhatever the kids are riding these days.\n\n255\n00:13:21.069 --> 00:13:23.450\nSo I have these sub categories, right?\n\n256\n00:13:23.450 --> 00:13:25.017\nAnd in ProductSubcategory,\n\n257\n00:13:25.017 --> 00:13:29.279\nmaybe it's pretty frequent that I have\na bike that doesn't have A sub category,\n\n258\n00:13:29.279 --> 00:13:32.864\nthere's a lot of nulls in there,\nthat could certainly be the case.\n\n259\n00:13:32.864 --> 00:13:37.376\nIn fact, let me comment out\nthis whole case part here and\n\n260\n00:13:37.376 --> 00:13:39.968\njust run the query like this,\n\n261\n00:13:39.968 --> 00:13:45.835\nI've got a stray ISNULL down there at\nthe bottom, let me get rid of that.\n\n262\n00:13:45.835 --> 00:13:48.211\nAnd when I run it, here we go.\n\n263\n00:13:48.211 --> 00:13:51.511\nSee how my ProductID and Name are\npopulated, but here's this subcategory and\n\n264\n00:13:51.511 --> 00:13:54.215\nI got a bunch of NULLs right here\nat the beginning, I lucked out.\n\n265\n00:13:54.215 --> 00:13:56.944\nIf I keep scrolling down though,\nI'll see they're not all NULL.\n\n266\n00:13:56.944 --> 00:13:59.873\nOr I'm a liar, let's see,\nmaybe they are all NULL.\n\n267\n00:13:59.873 --> 00:14:00.473\nThere we go!\n\n268\n00:14:00.473 --> 00:14:03.250\nAll right, so these guys have\nSubcategoryIDs, right here.\n\n269\n00:14:03.250 --> 00:14:07.413\nI had to get all the way to the 600s\nbefore I started getting these\n\n270\n00:14:07.413 --> 00:14:08.610\nsubcategory IDs.\n\n271\n00:14:08.610 --> 00:14:11.110\nSo like it's null for about half,\n\n272\n00:14:11.110 --> 00:14:15.261\nabout 50% of my records\ndon't have a subcategory ID.\n\n273\n00:14:15.261 --> 00:14:18.550\nSo if I start working with this,\nhow do I handle this?\n\n274\n00:14:18.550 --> 00:14:19.500\nHow do I handle those values?\n\n275\n00:14:19.500 --> 00:14:23.690\nWell let's take our query and\nwork that in, okay.\n\n276\n00:14:23.690 --> 00:14:25.915\nI need an extra comma.\n\n277\n00:14:25.915 --> 00:14:28.203\nIs gonna get mad of me and\nI’ll get rid of that comment.\n\n278\n00:14:28.203 --> 00:14:29.439\nThere, all right.\n\n279\n00:14:29.439 --> 00:14:33.756\nSo right now,\nI'm keying all of this off of Product ID.\n\n280\n00:14:33.756 --> 00:14:37.818\nAnd I need to key it off of the product\nsub category ID instead to be able to\n\n281\n00:14:37.818 --> 00:14:39.770\nreally capture things.\n\n282\n00:14:39.770 --> 00:14:42.240\nSo I'm gonna change\nwhat I'm keying off of.\n\n283\n00:14:42.240 --> 00:14:45.510\nAnd I'll just cut and paste that.\n\n284\n00:14:45.510 --> 00:14:47.156\nNow I'm looking for that sub category ID.\n\n285\n00:14:47.156 --> 00:14:49.170\nNow, the numbers I was using before.\n\n286\n00:14:49.170 --> 00:14:52.089\nThey were 300, 400, 500.\n\n287\n00:14:52.089 --> 00:14:52.872\nCategory idea.\n\n288\n00:14:52.872 --> 00:14:54.656\nIt looks like it's number 0 to 20.\n\n289\n00:14:54.656 --> 00:14:55.780\nIt didn't go very high.\n\n290\n00:14:55.780 --> 00:14:59.328\nThe highest number I think I saw was 14.\n\n291\n00:14:59.328 --> 00:15:01.686\nI don't think I saw any that were higher.\n\n292\n00:15:01.686 --> 00:15:02.693\n37.\n\n293\n00:15:02.693 --> 00:15:03.907\nGood that we looked.\n\n294\n00:15:03.907 --> 00:15:06.403\nSo I can start to spot what those are and\nI can set conditions.\n\n295\n00:15:06.403 --> 00:15:09.366\nI might have a condition for\neach individual one.\n\n296\n00:15:09.366 --> 00:15:12.948\nIf product subcategory is 20,\nthen it's gonna be mongoose.\n\n297\n00:15:12.948 --> 00:15:15.536\nIf it's 25 it's gonna be huffy or\nwhatever.\n\n298\n00:15:15.536 --> 00:15:17.154\nI could do it that way,\nor I could do the ranges.\n\n299\n00:15:17.154 --> 00:15:18.340\nAnd stick with that.\n\n300\n00:15:18.340 --> 00:15:20.438\nIf it's 20 to 30 then this is what it is.\n\n301\n00:15:20.438 --> 00:15:23.330\nOr if it's 10 to 19 then\nthis is what it is.\n\n302\n00:15:23.330 --> 00:15:26.081\nAnd if it's null, what do we do then?\n\n303\n00:15:26.081 --> 00:15:29.275\nSo if I wanna change this to reflect that,\nI'll just do the first couple.\n\n304\n00:15:29.275 --> 00:15:34.410\nI'll say like,\nif the product ID equals one.\n\n305\n00:15:34.410 --> 00:15:37.090\nSo I'm not going to do a full-on\ncomparison, just if it's one,\n\n306\n00:15:37.090 --> 00:15:42.510\nthen I'll flag it as,\nwe could just take it as a non-bike.\n\n307\n00:15:42.510 --> 00:15:43.285\nIt'll be a non-bike.\n\n308\n00:15:43.285 --> 00:15:50.172\nIf the category ID is 2,\nthen we'll make it a road bike.\n\n309\n00:15:50.172 --> 00:15:56.900\nAnd if the product ID equals three,\nthen we'll make that touring.\n\n310\n00:15:56.900 --> 00:15:58.543\nSo, whoops, let's apply that, there we go.\n\n311\n00:15:58.543 --> 00:15:59.464\nAnd then otherwise,\n\n312\n00:15:59.464 --> 00:16:02.752\nit's just gonna be uncategorized, so\nit's not gonna have a sub category.\n\n313\n00:16:02.752 --> 00:16:07.242\nSo I'm keying off that other column\nThe nulls should get captured with\n\n314\n00:16:07.242 --> 00:16:08.392\nuncategorized.\n\n315\n00:16:08.392 --> 00:16:12.670\nAnd I saw a bunch up here,\nabout 50% of them that had nulls,\n\n316\n00:16:12.670 --> 00:16:15.642\nall these guys right here, okay?\n\n317\n00:16:15.642 --> 00:16:18.920\nSo like 16 through 21,\nthose all have a null value.\n\n318\n00:16:18.920 --> 00:16:22.450\nAnd if I run that, just like it is,\nwithout really changing anything else,\n\n319\n00:16:22.450 --> 00:16:25.700\nit's gonna run across, and\nthe nulls become uncategorized.\n\n320\n00:16:25.700 --> 00:16:32.460\nIt just handled it, so I don't need the is\nnull test if I'm using an else like this.\n\n321\n00:16:32.460 --> 00:16:33.210\nRight?\n\n322\n00:16:33.210 --> 00:16:35.460\nBut what if I don't want that, right?\n\n323\n00:16:35.460 --> 00:16:39.250\nIf it's null, maybe that's a problem,\nthat's an error we need to be aware of.\n\n324\n00:16:39.250 --> 00:16:43.200\nAnd so that's different than just not\nhaving one, two, or three, right?\n\n325\n00:16:43.200 --> 00:16:46.900\nIf I come across category 16,\nI just don't know what 16 is, and so\n\n326\n00:16:46.900 --> 00:16:47.820\nit's uncategorized.\n\n327\n00:16:47.820 --> 00:16:48.902\nI haven't given it a name,\n\n328\n00:16:48.902 --> 00:16:51.908\nright, or we might even change\nthat to say unnamed, right.\n\n329\n00:16:51.908 --> 00:16:54.970\nSo it's in an unnamed category,\nwhich I think I am spelling unnamed wrong,\n\n330\n00:16:54.970 --> 00:16:57.370\nbut we'll survive.\n\n331\n00:16:57.370 --> 00:17:01.280\nSo whatever it is, we'll do nameless\ncuz I think I can spell that right.\n\n332\n00:17:01.280 --> 00:17:05.340\nSo, I don't want null to be nameless,\nI want null to be an error.\n\n333\n00:17:05.340 --> 00:17:08.320\nThis is a warning, this is bad,\nI shouldn't have this in here.\n\n334\n00:17:08.320 --> 00:17:13.190\nSo in that scenario I can come back in,\nand I can address it here, and check, and\n\n335\n00:17:13.190 --> 00:17:17.540\nsay like,\nwhen product sub category ID is null or\n\n336\n00:17:17.540 --> 00:17:20.240\nequals null, you can do either one.\n\n337\n00:17:20.240 --> 00:17:25.610\nThen, and take some action there,\nor I could just filter it out.\n\n338\n00:17:25.610 --> 00:17:28.260\nAnd I could say, you know what,\nI just I don't want the nulls.\n\n339\n00:17:28.260 --> 00:17:30.040\nJust leave the nulls out,\ndon't even bring them in.\n\n340\n00:17:30.040 --> 00:17:35.650\nAnd if we wanna leave them out, you can\njust add a little extra to the query here.\n\n341\n00:17:35.650 --> 00:17:43.940\nSo after the from, I'm gonna add where\nproduct SubCategoryID IS NOT NULL,\n\n342\n00:17:43.940 --> 00:17:49.460\nI said is null a moment ago,\nthis is is not null.\n\n343\n00:17:49.460 --> 00:17:53.210\nSo I'm filtering it to say, you know what,\nI just don't wanna see the nulls,\n\n344\n00:17:53.210 --> 00:17:57.030\nif there's no subcategory just leave them\nout and don't bother me with the, right?\n\n345\n00:17:57.030 --> 00:18:01.100\nRight now, when I run my query\nI'm getting 504 rows back, and\n\n346\n00:18:01.100 --> 00:18:03.220\nI know at least half of\nthem have that null.\n\n347\n00:18:03.220 --> 00:18:08.650\nAnd so if I run that, it's gonna run,\nand this time I only got 295 rows back.\n\n348\n00:18:08.650 --> 00:18:11.190\nSo it's actually a little\nless than half had nulls.\n\n349\n00:18:11.190 --> 00:18:14.100\nBut now I'm just seeing the ones\nthat actually have a subcategory.\n\n350\n00:18:14.100 --> 00:18:18.270\nAnd many of them are nameless, cuz I've\nonly identified one, two, and three.\n\n351\n00:18:18.270 --> 00:18:22.300\nBut if I scroll down and find somebody\nwho's got a one, two, or three,\n\n352\n00:18:22.300 --> 00:18:28.130\nthere, the ones are mountain, the twos\nare road, and I didn't see any threes.\n\n353\n00:18:28.130 --> 00:18:28.944\nThey're in there somewhere I'm sure,\nand we can find them there.\n\n354\n00:18:28.944 --> 00:18:32.136\n&gt;&gt; [LAUGH]\n&gt;&gt; So a few different ways that we can\n\n355\n00:18:32.136 --> 00:18:36.390\nhandle testing for null, and identifying\nit, representing it on the screen.\n\n356\n00:18:36.390 --> 00:18:40.030\nAll important ways to make sure\nthat null doesn't break our query,\n\n357\n00:18:40.030 --> 00:18:42.440\nand that we are getting\nthe information that we want.\n\n358\n00:18:42.440 --> 00:18:46.360\n&gt;&gt; Well, are there any other special\nways that we can handle null values?\n\n359\n00:18:46.360 --> 00:18:48.470\n&gt;&gt; Yeah, there's a few,\n\n360\n00:18:48.470 --> 00:18:53.830\nthis scenerio works really well when we're\ndealing with column data, with tuples.\n\n361\n00:18:53.830 --> 00:18:57.510\nSo I'm really just checking for null in\nproducts of category ID, and that's it.\n\n362\n00:18:58.550 --> 00:19:01.388\nIt gets a little more tricky when\nyou're going horizontally like this,\n\n363\n00:19:01.388 --> 00:19:03.075\nwhen you're actually checking a record.\n\n364\n00:19:03.075 --> 00:19:06.998\nSo, for example,\nI might wanna pull record 864, and\n\n365\n00:19:06.998 --> 00:19:12.258\nI know that a couple of columns here\nmight be null, they might be populated.\n\n366\n00:19:12.258 --> 00:19:16.632\nSo maybe I have a table structured,\nlet me do a new query so\n\n367\n00:19:16.632 --> 00:19:19.285\nthis doesn't get too confusing.\n\n368\n00:19:19.285 --> 00:19:24.155\nMaybe I'll get a table structured\nwhere I have some kind of product ID,\n\n369\n00:19:24.155 --> 00:19:27.930\nand it's followed by a name for\nthe product.\n\n370\n00:19:27.930 --> 00:19:32.680\nAnd then I have things like small,\nmedium, large,\n\n371\n00:19:32.680 --> 00:19:38.400\nI'm thinking clothing here,\nextra large, 2XL, and 3XL.\n\n372\n00:19:38.400 --> 00:19:44.220\nAnd when I put in a new\nshirt into my system,\n\n373\n00:19:44.220 --> 00:19:46.540\nI come and I populate it,\nI give it an ID, I give it a name.\n\n374\n00:19:46.540 --> 00:19:49.187\nSo this is going to be a shirt, right.\n\n375\n00:19:49.187 --> 00:19:52.044\nAnd then maybe these are binary bits,\nso 0 or 1.\n\n376\n00:19:52.044 --> 00:19:56.609\nIf they're available in small, I may get\na 1, if they're not available in small,\n\n377\n00:19:56.609 --> 00:19:57.396\nI make it a 0.\n\n378\n00:19:57.396 --> 00:20:00.722\nOr maybe I don't even bother\nwith the binary thing,\n\n379\n00:20:00.722 --> 00:20:04.359\nI just say if there's a value in here,\nI have it in small.\n\n380\n00:20:04.359 --> 00:20:08.250\nIf it's null,\nthen I don't have it in small, right?\n\n381\n00:20:08.250 --> 00:20:09.893\nMaybe we're using null for that purpose.\n\n382\n00:20:09.893 --> 00:20:15.717\nAnd so, I might have, like where\nit's null for the first two sizes,\n\n383\n00:20:15.717 --> 00:20:21.654\nand then we say maybe even a quantity\nnumber, like I have 15 or 16.\n\n384\n00:20:21.654 --> 00:20:28.596\nI have no small, no medium, 16 large,\n30 extra large, and so on, right?\n\n385\n00:20:28.596 --> 00:20:33.310\nSo, I'm identifying based on whether\nthere's a number in that field.\n\n386\n00:20:33.310 --> 00:20:36.670\nNow, normally I would do this with a 0,\nI don't have any small, I put a 0.\n\n387\n00:20:36.670 --> 00:20:39.740\nBut if the shirt's never\nbeen available in a small,\n\n388\n00:20:39.740 --> 00:20:43.260\nthen putting a 0 there might make it seem\nlike I could order it if I needed it.\n\n389\n00:20:43.260 --> 00:20:44.943\nI might want it to be null to\nindicate I can't even order it,\n\n390\n00:20:44.943 --> 00:20:45.729\nit's just not available.\n\n391\n00:20:45.729 --> 00:20:51.218\nWell, when you query horizontally\nlike this, if I wanna say,\n\n392\n00:20:51.218 --> 00:20:56.826\nfor shirt number one what's\nthe smallest size I can get, okay?\n\n393\n00:20:56.826 --> 00:20:59.849\nWhat I'm really looking for here is,\n\n394\n00:20:59.849 --> 00:21:03.820\nwhich of these is the first\none that's not empty?\n\n395\n00:21:03.820 --> 00:21:06.560\nWhich is the first one that's not null?\n\n396\n00:21:06.560 --> 00:21:08.579\nAnd so you can do that,\nyou can tell it to search and\n\n397\n00:21:08.579 --> 00:21:10.184\nfind the first value that's not null.\n\n398\n00:21:10.184 --> 00:21:15.409\nI did shirt sizes here,\na real world example of how I've used this\n\n399\n00:21:15.409 --> 00:21:20.547\nis dealing with like people,\nusually payroll, with payroll.\n\n400\n00:21:20.547 --> 00:21:23.927\nIf I am tracking an employee's pay and\nit's arranged horizontally, which I hate,\n\n401\n00:21:23.927 --> 00:21:25.750\nI usually try to go\nvertically on this stuff.\n\n402\n00:21:25.750 --> 00:21:29.290\nWhere each month they've got a salary\namount, or an hourly amount, or\n\n403\n00:21:29.290 --> 00:21:33.302\nmaybe you're tracking bonuses,\ncommissions, and they've done monthly, so\n\n404\n00:21:33.302 --> 00:21:35.310\neach call represents a month.\n\n405\n00:21:35.310 --> 00:21:40.000\nWell, if somebody's hired in May and\nI'm tracking for the entire year of 2017,\n\n406\n00:21:40.000 --> 00:21:44.240\nthen January, February, March,\nand April are all gonna be null.\n\n407\n00:21:44.240 --> 00:21:46.960\nThey weren't working here,\nthose are empty, they had no sales.\n\n408\n00:21:46.960 --> 00:21:47.910\nSo I might say,\n\n409\n00:21:47.910 --> 00:21:52.670\nI need to start with the first one that\nactually has a value that's not null.\n\n410\n00:21:52.670 --> 00:21:55.940\nAnd I could do a test on each individual\none, but if there's 1,000 of them,\n\n411\n00:21:55.940 --> 00:21:57.670\nthat's a lot of tests.\n\n412\n00:21:57.670 --> 00:22:00.650\nSo there's actually a built in command\nthat we can use to do this, and\n\n413\n00:22:00.650 --> 00:22:03.140\nit's kind of an edge case,\nit's not something everyone's gonna use.\n\n414\n00:22:03.140 --> 00:22:07.310\nBut the command is called coalesce, and\nwhat coalesce does is it says get me this\n\n415\n00:22:07.310 --> 00:22:12.410\ndata, but\nskip to the first value that's not null.\n\n416\n00:22:12.410 --> 00:22:14.620\nGive me just that first\nvalue that's not null.\n\n417\n00:22:14.620 --> 00:22:17.470\nThe sample database that\nMicrosoft has here doesn't\n\n418\n00:22:17.470 --> 00:22:21.780\nhave a great example built into it, but I\ncan show you one its just not necessarily\n\n419\n00:22:23.570 --> 00:22:25.840\nexactly like we'd use it in real life.\n\n420\n00:22:25.840 --> 00:22:33.880\nSo if I wanna find something, let me pull\nup a little table that we've got here.\n\n421\n00:22:33.880 --> 00:22:39.471\nI'm gonna pull the [Name],\nand Class, Color,\n\n422\n00:22:39.471 --> 00:22:45.585\nand ProductNumber From the production,\n\n423\n00:22:45.585 --> 00:22:50.326\nwhoops, from the production.product\ntable is where I'm gonna pull this from.\n\n424\n00:22:50.326 --> 00:22:54.456\nAnd that table contains all\nthe information about our products in this\n\n425\n00:22:54.456 --> 00:22:55.158\ndatabase.\n\n426\n00:22:55.158 --> 00:22:58.310\nSo when I query that,\nit's gonna pull it up.\n\n427\n00:22:58.310 --> 00:23:01.910\nAnd look right here in the beginning,\nI've got this adjustable race bike.\n\n428\n00:23:01.910 --> 00:23:04.685\nAnd it doesn't have a class,\nit doesn't have a color, but\n\n429\n00:23:04.685 --> 00:23:05.700\nit does have a product number.\n\n430\n00:23:07.060 --> 00:23:09.780\nSo I'm might wanna query against this and\n\n431\n00:23:09.780 --> 00:23:13.430\nsay, give me the first\nvalue that's not null.\n\n432\n00:23:13.430 --> 00:23:17.160\nWell, it would skip null, it would\nskip null, and it would get AR-5381.\n\n433\n00:23:17.160 --> 00:23:21.480\nAssuming that I was just\ngrabbing these three columns.\n\n434\n00:23:21.480 --> 00:23:23.330\nAs it stands, they've all got a name and\n\n435\n00:23:23.330 --> 00:23:25.600\nthat's first, and so\nthat might be a problem.\n\n436\n00:23:25.600 --> 00:23:28.820\nAnd I can solve that pretty easily\njust by moving Name to the end, and\n\n437\n00:23:28.820 --> 00:23:30.100\nnow the NULL's be upfront.\n\n438\n00:23:30.100 --> 00:23:34.860\nBut we can actually correct that in\nthe command as well, so I'll correct it.\n\n439\n00:23:34.860 --> 00:23:36.930\nBut this is an example here\nwhere I've got NULLs and\n\n440\n00:23:36.930 --> 00:23:38.830\nI might want to just jump over to it.\n\n441\n00:23:38.830 --> 00:23:42.389\nLL Crankarm, whatever that is,\nit has a Class and a Color, so\n\n442\n00:23:42.389 --> 00:23:46.420\nit would return an L,\nyeah we can imagine what that does.\n\n443\n00:23:46.420 --> 00:23:50.130\nSo if I wanna see that where I grab\njust the first non null value,\n\n444\n00:23:50.130 --> 00:23:52.589\nI can add just a little\nmore to this query.\n\n445\n00:23:52.589 --> 00:23:56.925\nAnd I'm going to tell it to COALESCE,\n\n446\n00:23:56.925 --> 00:24:02.488\nthat's C-O-A-L-E-S-C-E, COALESCE.\n\n447\n00:24:02.488 --> 00:24:06.260\nAnd then in parenthesis I'm going\nto tell the columns to check.\n\n448\n00:24:06.260 --> 00:24:08.230\nRemember I said I could\nmove name to the end.\n\n449\n00:24:08.230 --> 00:24:12.490\nBut instead of moving name to the end I\ncan just only coalesce on these three\n\n450\n00:24:12.490 --> 00:24:13.520\ncolumns here.\n\n451\n00:24:13.520 --> 00:24:15.510\nThat's far easier, and\nthat's how you'll normally do it.\n\n452\n00:24:15.510 --> 00:24:18.767\nSo that's why I didn't change my actual\n&gt;&gt; Can you coalesce an entire table?\n\n453\n00:24:18.767 --> 00:24:20.360\n&gt;&gt; Yeah, absolutely.\n\n454\n00:24:20.360 --> 00:24:23.250\nTechnically I'm doing it right here\nbecause I haven't done any where\n\n455\n00:24:23.250 --> 00:24:24.330\nclause to limit this.\n\n456\n00:24:24.330 --> 00:24:28.390\nBut you can do a where clause to get\njust a piece versus the whole thing.\n\n457\n00:24:28.390 --> 00:24:31.390\nAnd there is a performance improvement for\ndoing that so you might want to.\n\n458\n00:24:31.390 --> 00:24:33.148\nI'm going to hit the whole table here.\n\n459\n00:24:33.148 --> 00:24:33.917\n&gt;&gt; Awesome.\n&gt;&gt; And so\n\n460\n00:24:33.917 --> 00:24:37.625\nwhen I coalesce I'm going to tell\nit though that I just want to\n\n461\n00:24:37.625 --> 00:24:40.840\npay attention to class,\ncolor and product number.\n\n462\n00:24:41.860 --> 00:24:44.930\nI don't want to pay attention\nto the other columns.\n\n463\n00:24:44.930 --> 00:24:47.310\nIf these were the short sizes,\nthis is where I would say,\n\n464\n00:24:47.310 --> 00:24:51.740\nI want to pay attention to the small,\nmedium, large, extra large, and that's it.\n\n465\n00:24:51.740 --> 00:24:54.050\nDon't pay attention to any other column.\n\n466\n00:24:54.050 --> 00:24:56.400\nSo I'm telling them to coalesce that.\n\n467\n00:24:56.400 --> 00:25:01.420\nAnd normally what I would do is if I was\njust interested in the first non-null\n\n468\n00:25:01.420 --> 00:25:04.560\nvalue, I wouldn't return\nall these columns.\n\n469\n00:25:04.560 --> 00:25:08.320\nAll I would do is return\nthe one coalesce column,\n\n470\n00:25:08.320 --> 00:25:09.980\nbecause it's gonna have\nthe information that I want.\n\n471\n00:25:09.980 --> 00:25:11.250\nWhat's the smallest\nshirt size that I have?\n\n472\n00:25:11.250 --> 00:25:12.120\nThat's all I care about.\n\n473\n00:25:12.120 --> 00:25:13.920\nI don't care about\nthe other ones being null.\n\n474\n00:25:13.920 --> 00:25:17.527\nBut just for the example here,\nI'm gonna leave those in place.\n\n475\n00:25:17.527 --> 00:25:18.755\nSo we're gonna get class, color and\n\n476\n00:25:18.755 --> 00:25:21.410\nproduct number just so\nwe can see that it found the right one.\n\n477\n00:25:21.410 --> 00:25:25.209\nAnd I'm gonna pull coalesce in\nof those three columns as, and\n\n478\n00:25:25.209 --> 00:25:30.480\nI'll just call it coalesced, so we can\nremember what we did that caused this.\n\n479\n00:25:30.480 --> 00:25:32.760\nAnd so I'll see that column\nthat's been coalesced.\n\n480\n00:25:32.760 --> 00:25:36.290\nAnd then we're just pulling that from\nthe table so this is going to search\n\n481\n00:25:36.290 --> 00:25:39.290\non the first non-null and\nreturn it in this final column.\n\n482\n00:25:39.290 --> 00:25:42.650\nSo when I run it, we'll see a new\ncolumn appear over here and\n\n483\n00:25:42.650 --> 00:25:46.060\nit should just contain the first\nvalue that's not null.\n\n484\n00:25:46.060 --> 00:25:48.620\nSo I'll run that there's my extra column.\n\n485\n00:25:48.620 --> 00:25:52.000\nAnd for these first five sure enough\nI can see a skipped class and\n\n486\n00:25:52.000 --> 00:25:54.200\ncolor and it grabbed product number.\n\n487\n00:25:54.200 --> 00:25:55.150\nSo these all have product numbers.\n\n488\n00:25:55.150 --> 00:25:59.050\nBut when I use it, the next one,\nthe LL Crank arm, it had a class.\n\n489\n00:25:59.050 --> 00:26:01.370\nThat was the first\nnon-null that returned it-\n\n490\n00:26:01.370 --> 00:26:03.410\n&gt;&gt; That must be crank arm again.\n\n491\n00:26:03.410 --> 00:26:06.400\n&gt;&gt; Yeah, and so this scenario,\n\n492\n00:26:06.400 --> 00:26:09.660\nwhat I was trying to say a moment ago\nis that it's not exactly real world.\n\n493\n00:26:09.660 --> 00:26:13.960\nLike when is a time that I would\nsay if it doesn't have a color,\n\n494\n00:26:13.960 --> 00:26:17.080\ngive me the product number,\nit doesn't really make sense.\n\n495\n00:26:17.080 --> 00:26:19.490\nBut if these were shirt sizes,\nright, I don't have small,\n\n496\n00:26:19.490 --> 00:26:21.250\nI don't have medium, but I've got large.\n\n497\n00:26:21.250 --> 00:26:25.230\nOkay, tell me that I've got\nthe large available and that's it.\n\n498\n00:26:25.230 --> 00:26:29.047\nAnd again,\ntypically we'd leave these columns off.\n\n499\n00:26:29.047 --> 00:26:31.740\nI don't need to see those columns,\ncuz they're null, they don't exist.\n\n500\n00:26:31.740 --> 00:26:33.680\nWhy return them to me, right?\n\n501\n00:26:33.680 --> 00:26:36.470\nInstead, just give me the ones\nthat I actually have.\n\n502\n00:26:36.470 --> 00:26:39.760\nAnd now it would return and I would\nsee large, or extra large, or small.\n\n503\n00:26:39.760 --> 00:26:43.150\nNow we're into the smallest shirt\nthat was available in that size or\n\n504\n00:26:43.150 --> 00:26:47.110\nthe first pay period for that employee.\n\n505\n00:26:47.110 --> 00:26:49.760\nI would see that first\nvalue that wasn't null.\n\n506\n00:26:49.760 --> 00:26:52.092\nThat's what coalesce does.\n\n507\n00:26:52.092 --> 00:26:55.830\nNow, normally, when a database is designed\nproperly, everything's done vertically.\n\n508\n00:26:55.830 --> 00:26:58.390\nAnd Case is perfect for that.\n\n509\n00:26:58.390 --> 00:26:59.100\nCase can handle it.\n\n510\n00:26:59.100 --> 00:26:59.630\nNo problem.\n\n511\n00:26:59.630 --> 00:27:01.730\nIt can grab the value,\nand you're in business.\n\n512\n00:27:01.730 --> 00:27:03.550\nOrder by and all that can really help.\n\n513\n00:27:03.550 --> 00:27:06.510\nAnd that's what you're going\nto use 99% of the time.\n\n514\n00:27:06.510 --> 00:27:09.860\nAnd the main reason is with horizontal\ndata, there's kind of a limit.\n\n515\n00:27:09.860 --> 00:27:13.370\nThere's only so many column you can\nhave before the table goes nuts.\n\n516\n00:27:13.370 --> 00:27:17.250\nAnd so if you're doing pay periods,\nand the person works for you for\n\n517\n00:27:17.250 --> 00:27:19.400\n20 years, that's a lot of columns.\n\n518\n00:27:19.400 --> 00:27:20.040\n&gt;&gt; A lot of them.\n\n519\n00:27:20.040 --> 00:27:20.910\n&gt;&gt; It should be vertical.\n\n520\n00:27:20.910 --> 00:27:24.980\nAnd by doing that way where each period\nis a row, it's far easier to work with.\n\n521\n00:27:24.980 --> 00:27:29.720\nUnfortunately, in real life when you don't\nget to design every database you work on,\n\n522\n00:27:29.720 --> 00:27:32.740\nand oftentimes they're designed by people\nwho don't have a lot of experience.\n\n523\n00:27:32.740 --> 00:27:36.540\nAnd so you may encounter these databases\nthat are just not structured right.\n\n524\n00:27:36.540 --> 00:27:37.950\nAnd that's where coalesce becomes reliant.\n\n525\n00:27:38.965 --> 00:27:40.610\n&gt;&gt; Another great episode,\nconditions and knowles.\n\n526\n00:27:40.610 --> 00:27:41.590\nThank you, Don.\n\n527\n00:27:41.590 --> 00:27:44.430\nAnd before we leave,\nwhat else would you like to say?\n\n528\n00:27:44.430 --> 00:27:47.430\n&gt;&gt; With all of these tools,\nfeel free to use them or not use them.\n\n529\n00:27:47.430 --> 00:27:50.800\nYou may not have a real world case\nscenario for some of these commands, but\n\n530\n00:27:50.800 --> 00:27:51.540\nmany of you will.\n\n531\n00:27:51.540 --> 00:27:53.690\nAnd you'll encounter\ntimes when the data and\n\n532\n00:27:53.690 --> 00:27:56.240\nthe database is just not\nthe way you want it.\n\n533\n00:27:56.240 --> 00:27:58.560\nWe don't have to change\nthe data in the database.\n\n534\n00:27:58.560 --> 00:28:00.620\nWe can just change our\nquery to account for\n\n535\n00:28:00.620 --> 00:28:03.960\nit, especially null values where\nwe don't expect null values to be.\n\n536\n00:28:03.960 --> 00:28:07.210\nData that's represented as a number,\nwe want it to be something else.\n\n537\n00:28:07.210 --> 00:28:09.420\nIn a previous episode we talked\nabout converting data types.\n\n538\n00:28:09.420 --> 00:28:11.202\nI can convert the data type but\n\n539\n00:28:11.202 --> 00:28:15.764\nCase, I can totally change the value\nto something completely different and\n\n540\n00:28:15.764 --> 00:28:19.483\nthose are very powerful ways to\nmake the data match our needs.\n\n541\n00:28:19.483 --> 00:28:22.790\nBut we've got to figure out which one\nis right for us, kind of like a puzzle.\n\n542\n00:28:22.790 --> 00:28:27.710\nSo when you approach a problem, I've given\nyou the tools now to solve those problems,\n\n543\n00:28:27.710 --> 00:28:30.430\nyou just got to figure out the right tool,\ndo I need a screwdriver, or\n\n544\n00:28:30.430 --> 00:28:31.760\ndo I need the wrench for this one?\n\n545\n00:28:31.760 --> 00:28:35.240\nDo I need coalesce, or can I use case,\nwhich one's going to match up for\n\n546\n00:28:35.240 --> 00:28:37.160\nwhat I want to do, and\nthen get it put in place.\n\n547\n00:28:37.160 --> 00:28:40.670\nAnd you might find that there's more than\none way to solve it, and at that point,\n\n548\n00:28:40.670 --> 00:28:44.010\nif I have two ways to solve it,\nI usually look at performance.\n\n549\n00:28:44.010 --> 00:28:48.200\nI pull up that query execution plan,\nCTRL+M in your query analyzer and\n\n550\n00:28:48.200 --> 00:28:49.290\nI do it both ways.\n\n551\n00:28:49.290 --> 00:28:50.280\nI see which one ran faster.\n\n552\n00:28:50.280 --> 00:28:52.530\nThe one that runs faster,\nthat's the one I'll go with and\n\n553\n00:28:52.530 --> 00:28:54.720\nthat is kind of a good\ntie breaker usually.\n\n554\n00:28:54.720 --> 00:28:55.320\n&gt;&gt; Awesome, Don.\n\n555\n00:28:55.320 --> 00:28:56.170\nThanks again.\n\n556\n00:28:56.170 --> 00:29:00.190\nAnd querying data with TransX SQL, watch\nevery episode you'll be glad you did.\n\n557\n00:29:00.190 --> 00:29:01.580\nWhen you're in the course library.\n\n558\n00:29:01.580 --> 00:29:05.420\nThere's hundreds of other videos and\nthey are there to help you go further.\n\n559\n00:29:05.420 --> 00:29:08.330\nAnd tell everybody you know about\nITPro.TV, it is binge worthy.\n\n560\n00:29:08.330 --> 00:29:10.070\nThank you for watching, I'm Zach Memos.\n\n561\n00:29:10.070 --> 00:29:10.830\n&gt;&gt; And I'm Don Pezet.\n\n562\n00:29:10.830 --> 00:29:11.849\n&gt;&gt; We will see you soon.\n\n563\n00:29:11.849 --> 00:29:19.083\n[MUSIC]\n\n564\n00:29:19.083 --> 00:29:22.198\n&gt;&gt; Thank you for watching ITPRO.TV.\n\n",
          "vimeoId": "248976064"
        }
      ],
      "title": "Working with Data Types"
    },
    {
      "episodes": [
        {
          "description": "In this episode, Don revisits the topic of functions. This time around, he demonstrates how to create custom functions that can directly support your business need. He wraps up by demonstrating how to create and use scalar and table-valued functions.",
          "length": "1962",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-1-1-user_defined_functions-121217.00_32_30_05.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-1-1-user_defined_functions-121217.00_32_30_05.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-1-1-user_defined_functions-121217.00_32_30_05.Still001-sm.jpg",
          "title": "User Defined Functions",
          "transcript": "",
          "vimeoId": "247150829"
        },
        {
          "description": "In this episode, Don explains what a stored function is in Microsoft SQL. He demonstrates several built-in stored procedures and then shows how to create and execute custom stored procedures to support your business needs.",
          "length": "2350",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-2-1-stored_procedures-121317.00_38_58_14.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-2-1-stored_procedures-121317.00_38_58_14.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-2-1-stored_procedures-121317.00_38_58_14.Still001-sm.jpg",
          "title": "Stored Procedures",
          "transcript": "",
          "vimeoId": "247375763"
        },
        {
          "description": "In this episode, Don explains how SQL Views function. He walks the viewers through several scenarios where views can be very useful and then demonstrates how to create and use views in Transact-SQL.",
          "length": "1669",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-3-1-creating_views-121317-PGM.00_29_44_23.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-3-1-creating_views-121317-PGM.00_29_44_23.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-3-1-creating_views-121317-PGM.00_29_44_23.Still001-sm.jpg",
          "title": "Creating Views",
          "transcript": "",
          "vimeoId": "247376904"
        },
        {
          "description": "In this episode, Don introduces the viewers to transactions. He explains how transactions function and demonstrates how they can protect your data in the event of a failed query. He wraps up the episode with an example of how transactions can be used for troubleshooting and auditing.",
          "length": "1861",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-4-1-transactions-121417-PGM.00_35_01_13.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-4-1-transactions-121417-PGM.00_35_01_13.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-4-1-transactions-121417-PGM.00_35_01_13.Still001-sm.jpg",
          "title": "Transactions",
          "transcript": "",
          "vimeoId": "247509320"
        },
        {
          "description": "In this episode, Don introduces the viewers to transactions. He explains how transactions function and demonstrates how they can protect your data in the event of a failed query. He wraps up the episode with an example of how transactions can be used for troubleshooting and auditing.",
          "length": "1559",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-4-2-transactions_pt2-121417-PGM.00_27_06_21.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-4-2-transactions_pt2-121417-PGM.00_27_06_21.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-4-2-transactions_pt2-121417-PGM.00_27_06_21.Still001-sm.jpg",
          "title": "Transactions Part 2",
          "transcript": "",
          "vimeoId": "247508448"
        },
        {
          "description": "In this episode, Don explains the importance of catching and reporting errors in your SQL scripts. He demonstrates how to use TRY/CATCH blocks, RAISERROR and THROW to collect and report error information. He ends the episode by updating an existing query to provide proper error handling.",
          "length": "1890",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-5-1-error_handling-011118.00_31_30_20.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-5-1-error_handling-011118.00_31_30_20.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-5-1-error_handling-011118.00_31_30_20.Still001-sm.jpg",
          "title": "Error Handling",
          "transcript": "",
          "vimeoId": "250857206"
        },
        {
          "description": "In this episode, Don explains the importance of catching and reporting errors in your SQL scripts. He demonstrates how to use TRY/CATCH blocks, RAISERROR and THROW to collect and report error information. He ends the episode by updating an existing query to provide proper error handling.",
          "length": "1081",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-5-2-error_handling_pt2-011118.00_29_02_06.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-5-2-error_handling_pt2-011118.00_29_02_06.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-5-5-2-error_handling_pt2-011118.00_29_02_06.Still001-sm.jpg",
          "title": "Error Handling Part 2",
          "transcript": "",
          "vimeoId": "250856256"
        }
      ],
      "title": "Programming Databases with T-SQL"
    },
    {
      "episodes": [
        {
          "description": "In this episode, Don demonstrates how to use subqueries to make complex queries more efficient. He explains how query execution plans are calculated and then shows how to measure whether or not a subquery can provide a performance improvement over a complex query.",
          "length": "1632",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-1-1-subqueries-010818-PGM.00_29_59_00.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-1-1-subqueries-010818-PGM.00_29_59_00.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-1-1-subqueries-010818-PGM.00_29_59_00.Still001-sm.jpg",
          "title": "Subqueries",
          "transcript": "WEBVTT\n\n1\n00:00:00.260 --> 00:00:02.923\nWelcome to ITPro TV,\nI'm your host Don Pezet.\n\n2\n00:00:02.923 --> 00:00:06.275\n[CROSSTALK]\n\n3\n00:00:06.275 --> 00:00:07.962\n[MUSIC]\n\n4\n00:00:07.962 --> 00:00:12.646\n&gt;&gt; You're watching ITPro TV.\n&gt;&gt; Hello,\n\n5\n00:00:12.646 --> 00:00:15.674\nwelcome to another exciting\nepisode here at ITPro TV.\n\n6\n00:00:15.674 --> 00:00:17.956\nI'm your host Mike Rodrick, and\n\n7\n00:00:17.956 --> 00:00:22.230\ntoday we're doing querying\ndata with SQL or Transact-SQL.\n\n8\n00:00:22.230 --> 00:00:23.850\nWith me today is Mr. Don Pezet.\n\n9\n00:00:23.850 --> 00:00:25.650\nHow you doing Don?\n&gt;&gt; I'm doing great, Mike,\n\n10\n00:00:25.650 --> 00:00:27.660\nready to dive right\nback into Transact-SQL.\n\n11\n00:00:27.660 --> 00:00:30.430\nAnd in this episode we're gonna be taking\na look at a really neat thing that's\n\n12\n00:00:30.430 --> 00:00:32.150\ncalled a subquery.\n\n13\n00:00:32.150 --> 00:00:36.950\nAnd this is where we take one query and we\nstick it inside of another query, right?\n\n14\n00:00:36.950 --> 00:00:40.660\nWhich we've kind of already seen\nwhen we did nested joins, right?\n\n15\n00:00:40.660 --> 00:00:43.028\nA nested join is technically a subquery.\n\n16\n00:00:43.028 --> 00:00:46.652\nBut in this scenario we're gonna see some\nslightly different uses for subqueries and\n\n17\n00:00:46.652 --> 00:00:48.120\nhow we can take advantage of that.\n\n18\n00:00:48.120 --> 00:00:50.228\nTo really get the data\nset that we want and\n\n19\n00:00:50.228 --> 00:00:52.584\nto find ways to do things\nmore efficiently and\n\n20\n00:00:52.584 --> 00:00:56.682\nbetter than we might have been able to\ndo through other, more complex things.\n\n21\n00:00:56.682 --> 00:00:58.882\nLike if you watch that\nnested join episode,\n\n22\n00:00:58.882 --> 00:01:01.030\nsome of that syntax got pretty cluttered.\n\n23\n00:01:01.030 --> 00:01:03.920\nThere was a lot of SQL written\non my screen for that.\n\n24\n00:01:03.920 --> 00:01:07.582\nWe'll see here that it's actually not so\nhard when we take advantage of subqueries.\n\n25\n00:01:07.582 --> 00:01:08.610\n&gt;&gt; Sounds good, Don,\n\n26\n00:01:08.610 --> 00:01:11.470\nI guess you kinda answered my question or\nsort of.\n\n27\n00:01:11.470 --> 00:01:14.580\nWhy would we want to use\nthese subqueries then?\n\n28\n00:01:14.580 --> 00:01:16.040\n&gt;&gt; There's a couple of motivations,right?\n\n29\n00:01:16.040 --> 00:01:18.650\nSo I mentioned being easier right,\nthat's one reason.\n\n30\n00:01:18.650 --> 00:01:21.480\nAnd it's not always easier, sometimes\nsubqueries are a little bit harder.\n\n31\n00:01:21.480 --> 00:01:25.270\nBut the main reason why we\nwant to learn about subqueries\n\n32\n00:01:25.270 --> 00:01:29.000\nis that they can be far more\nefficient than a regular query.\n\n33\n00:01:29.000 --> 00:01:32.680\nIn fact, a lot of what I'm gonna show you\nhere in this episode you could write as\n\n34\n00:01:32.680 --> 00:01:34.680\na single query if you wanted.\n\n35\n00:01:34.680 --> 00:01:38.260\nBut, if you do,\nyou may be getting poor performance,right?\n\n36\n00:01:38.260 --> 00:01:43.460\nSometimes what you have are a lot of\nexecutions that are a part of a query.\n\n37\n00:01:43.460 --> 00:01:46.100\nWhen you run a query,\nit's not just doing one simple thing.\n\n38\n00:01:46.100 --> 00:01:48.690\nIt's usually doing four or five different\nthings, and sticking them all together and\n\n39\n00:01:48.690 --> 00:01:50.220\ngiving you that information.\n\n40\n00:01:50.220 --> 00:01:51.850\nWhen you write it as one query,\n\n41\n00:01:51.850 --> 00:01:56.500\nthe server has to figure out how to deal\nwith that and treat it as one solid piece.\n\n42\n00:01:56.500 --> 00:02:01.130\nBut if we use subqueries, now things\nget broken up into smaller pieces, and\n\n43\n00:02:01.130 --> 00:02:02.920\nthat gives the server more options.\n\n44\n00:02:02.920 --> 00:02:06.990\nThe server can figure out more creative\nand official ways to run that query and\n\n45\n00:02:06.990 --> 00:02:09.600\nput the data together and\npresent it back to you.\n\n46\n00:02:09.600 --> 00:02:12.090\nAnd so, while sometimes it might a little\nbit harder to write it this way.\n\n47\n00:02:12.090 --> 00:02:16.180\nThe optimization benefit what we're really\nafter, and that's kind of the key thing.\n\n48\n00:02:16.180 --> 00:02:19.250\nRemember that, sub queries are optional,\n\n49\n00:02:19.250 --> 00:02:22.490\nso you could just it stop\nbutton right now in this video.\n\n50\n00:02:22.490 --> 00:02:24.320\nHe said they're optional,\nI'm gonna move on.\n\n51\n00:02:24.320 --> 00:02:27.240\nHey, everything we do here you can\nachieve with the normal query.\n\n52\n00:02:27.240 --> 00:02:31.060\nBut know this, in a test environment\nsure they're optional, but\n\n53\n00:02:31.060 --> 00:02:35.710\nin production, these types of subqueries\nare really, really important, right.\n\n54\n00:02:35.710 --> 00:02:38.265\nIf I told you that you\nhad a query that runs in\n\n55\n00:02:38.265 --> 00:02:41.208\none-tenth of a second and then\n&gt;&gt; That's\n\n56\n00:02:41.208 --> 00:02:42.250\nimpressive.\n&gt;&gt; It's fast.\n\n57\n00:02:42.250 --> 00:02:43.165\n&gt;&gt; I like it.\n\n58\n00:02:43.165 --> 00:02:44.173\n&gt;&gt; And then I said well,\n\n59\n00:02:44.173 --> 00:02:46.973\nif I wrote that as a single query and\ndidn't use a subquery,\n\n60\n00:02:46.973 --> 00:02:50.030\nit would take two-tenths of a second,\none-fifth of a second.\n\n61\n00:02:50.030 --> 00:02:55.980\nOne fifth of a second, that's still not a\nbig deal, if I'm just running it one time.\n\n62\n00:02:55.980 --> 00:02:59.810\nBut what if it's running\na thousand times per second?\n\n63\n00:02:59.810 --> 00:03:03.972\nLook at a database like Amazon's database\nthat is just being clobbered by tons of\n\n64\n00:03:03.972 --> 00:03:05.387\naccess all over the world.\n\n65\n00:03:05.387 --> 00:03:08.507\nThat, if we can get\nan extra tenth of a second,\n\n66\n00:03:08.507 --> 00:03:11.360\nmakes a big, big difference.\n&gt;&gt; Starts making\n\n67\n00:03:11.360 --> 00:03:13.714\nan impact in our performance.\n&gt;&gt; Absolutely and\n\n68\n00:03:13.714 --> 00:03:16.000\nthat's stuff that's hard to see in tests,\nright?\n\n69\n00:03:16.000 --> 00:03:19.715\nAnd that's where I see subqueries\nget kinda thrown by the wayside.\n\n70\n00:03:19.715 --> 00:03:22.610\nCuz lot of people will say, all right, I\nneed to write a query that does something.\n\n71\n00:03:22.610 --> 00:03:25.130\nLet me just figure out a way to do it.\n\n72\n00:03:25.130 --> 00:03:26.990\nAnd so they experiment around,\nthey try different ways, and\n\n73\n00:03:26.990 --> 00:03:30.570\nthey find some particular solution and\nthey get it working, and\n\n74\n00:03:30.570 --> 00:03:31.860\nit's all just one big single query.\n\n75\n00:03:31.860 --> 00:03:34.310\nAnd then they just stop and that's it.\n\n76\n00:03:34.310 --> 00:03:38.030\nBut if they come back and try to\noptimize it, they may find that, wow,\n\n77\n00:03:38.030 --> 00:03:40.790\nif I break that up into\nthese little pieces.\n\n78\n00:03:40.790 --> 00:03:42.690\nI can actually get it to run faster,\nright?\n\n79\n00:03:42.690 --> 00:03:44.230\nIt's all part of query optimization,\n\n80\n00:03:44.230 --> 00:03:48.416\nmaking things run better, more efficiently\nand getting that data the way we want it.\n\n81\n00:03:48.416 --> 00:03:51.310\nThat's really the true\npower behind a subquery.\n\n82\n00:03:51.310 --> 00:03:52.340\n&gt;&gt; Now Don,\n\n83\n00:03:52.340 --> 00:03:55.040\nyou said that subqueries\nare more efficient and\n\n84\n00:03:55.040 --> 00:03:57.570\nsome of our queries can be expensive.\n\n85\n00:03:57.570 --> 00:03:58.760\nWhat do you mean by expensive?\n\n86\n00:03:58.760 --> 00:04:02.010\nThere's no place for\nme to put my debit card in, so\n\n87\n00:04:02.010 --> 00:04:03.660\nwhat do we mean by that?\n&gt;&gt; All right,\n\n88\n00:04:03.660 --> 00:04:05.910\nI've used that word expensive\na few times in this shows, right.\n\n89\n00:04:05.910 --> 00:04:08.370\nThat we have expensive queries and\ncheap queries.\n\n90\n00:04:08.370 --> 00:04:12.000\nEvery query that runs has a cost, and that\ncost is not measured in dollars, right.\n\n91\n00:04:12.000 --> 00:04:16.310\nIt's measured in CPU time, it's\nmeasured in the memory they consume, or\n\n92\n00:04:16.310 --> 00:04:17.860\nthe disk IO, right.\n\n93\n00:04:17.860 --> 00:04:20.750\nAnd usually disk I/O and\nCPU time are the two we care about, but\n\n94\n00:04:20.750 --> 00:04:22.910\nmemory is certainly important as well.\n\n95\n00:04:22.910 --> 00:04:27.720\nSo if I write a really\nsuper mega complex query,\n\n96\n00:04:27.720 --> 00:04:30.340\nthat's not gonna be able to take advantage\nof a lot of things that are cached.\n\n97\n00:04:30.340 --> 00:04:33.190\nBecause the query is complex,\nit's unique, right?\n\n98\n00:04:33.190 --> 00:04:36.078\nSo it's going to need RAM to\nstore values in temporary,\n\n99\n00:04:36.078 --> 00:04:39.466\nit's going to need disk I/O to read and\ngather the information.\n\n100\n00:04:39.466 --> 00:04:44.710\nIt's going to need CPU time to sort out\nthat calculation, and get things done.\n\n101\n00:04:44.710 --> 00:04:48.910\nIf I have smaller, simpler queries,\nwell they may be able to leverage cache\n\n102\n00:04:48.910 --> 00:04:51.650\nresults better, or\nbuilt in indexes better.\n\n103\n00:04:51.650 --> 00:04:55.894\nThey may be able to use what's already\nin RAM and not have to hit the disc for\n\n104\n00:04:55.894 --> 00:04:56.797\npulling data.\n\n105\n00:04:56.797 --> 00:04:59.743\nOr consume CPU time for correlating\ninformation to a certain order,\n\n106\n00:04:59.743 --> 00:05:02.160\nbecause the data might\nalready be in that order.\n\n107\n00:05:02.160 --> 00:05:04.410\nThose are inexpensive quarries.\n\n108\n00:05:04.410 --> 00:05:07.550\nWe need to be looking not just at\nwhether our query works, I mean,\n\n109\n00:05:07.550 --> 00:05:09.130\nthat's certainly nice, right?\n\n110\n00:05:09.130 --> 00:05:12.840\nI have to achieve task A by tomorrow.\n\n111\n00:05:12.840 --> 00:05:14.600\nI'm not so\nworried about cost at that point,\n\n112\n00:05:14.600 --> 00:05:16.400\nwhatever it takes I just\nneed it working by tomorrow.\n\n113\n00:05:16.400 --> 00:05:18.580\nTomorrow I can come back and\noptimize it later.\n\n114\n00:05:18.580 --> 00:05:20.200\nBut when we're optimizing,\n\n115\n00:05:20.200 --> 00:05:23.860\nthat's when we need to say like\nhow can I reduce CPU time?\n\n116\n00:05:23.860 --> 00:05:26.840\nHow can I reduce the memory we consume?\n\n117\n00:05:26.840 --> 00:05:28.970\nAll of that stuff is\nkind of a part of that.\n\n118\n00:05:28.970 --> 00:05:31.730\nAnd it's easy to lose sight\nof with queries, right?\n\n119\n00:05:31.730 --> 00:05:35.010\nMostly because,\nwhen you're in the query analyzer,\n\n120\n00:05:35.010 --> 00:05:39.790\nand I run a simple query, here, I'll run\na simple query just to kinda show you.\n\n121\n00:05:39.790 --> 00:05:42.450\nSo let me do a join, right?\n\n122\n00:05:42.450 --> 00:05:47.240\nI'm gonna pull a list of all of my sales\npeople, and what bonus they got last year.\n\n123\n00:05:47.240 --> 00:05:49.610\nSo I'll do a select statement.\n\n124\n00:05:49.610 --> 00:05:55.840\nAnd I'm going to pull from\nthe person.person table,\n\n125\n00:05:55.840 --> 00:05:59.430\nwhich I'll just do an alias and call it P.\n\n126\n00:05:59.430 --> 00:06:02.585\nYou guys remember from earlier\nepisodes that person.person is a list\n\n127\n00:06:02.585 --> 00:06:04.995\nof all the contacts our\ncompany is aware of.\n\n128\n00:06:04.995 --> 00:06:08.145\nWe've got humanresources.employ,\nthose are our employees.\n\n129\n00:06:08.145 --> 00:06:10.195\nI just want sales people, right?\n\n130\n00:06:10.195 --> 00:06:11.785\nSo, we actually have a separate table for\nthat,\n\n131\n00:06:11.785 --> 00:06:14.055\nthat's why I'm gonna do\nan interjoin on this one.\n\n132\n00:06:14.055 --> 00:06:22.470\nSo, I will do a join against\nsales.salesperson as sp.\n\n133\n00:06:22.470 --> 00:06:27.450\nAnd those two are link together\nby the business entity ID.\n\n134\n00:06:27.450 --> 00:06:30.930\nSo let me tie those together real quick.\n\n135\n00:06:30.930 --> 00:06:33.630\nAnd once I've got that done,\nI'm gonna come up here and\n\n136\n00:06:33.630 --> 00:06:35.129\nshorten what I'm asking for.\n\n137\n00:06:35.129 --> 00:06:40.693\nCuz I really just want to get,\nlet's see I need their\n\n138\n00:06:40.693 --> 00:06:47.640\nfirst name I want their last name and\nI want their bonus, right?\n\n139\n00:06:47.640 --> 00:06:49.550\nThat's what this whole thing is about,\nright?\n\n140\n00:06:49.550 --> 00:06:51.330\nSo there's a simple query.\n\n141\n00:06:51.330 --> 00:06:53.570\nI say simple, it's a little more complex\nthan a normal simple statement, but\n\n142\n00:06:53.570 --> 00:06:54.770\nit is a simple join.\n\n143\n00:06:54.770 --> 00:06:59.082\nI can make this easier, I suppose,\nlike inner join is the default,\n\n144\n00:06:59.082 --> 00:07:01.664\nI can leave that out and\ndo it [INAUDIBLE].\n\n145\n00:07:01.664 --> 00:07:04.110\nSo, when I run this query,\nit's gonna reach out.\n\n146\n00:07:04.110 --> 00:07:06.360\nIt's getting data from\ntwo different tables and\n\n147\n00:07:06.360 --> 00:07:08.010\nit's gotta to put them together.\n\n148\n00:07:08.010 --> 00:07:12.006\nIt's gotta say, hey, person.person,\nthat has, I forget how many,\n\n149\n00:07:12.006 --> 00:07:14.443\nit's like over 5,000 contacts in it.\n\n150\n00:07:14.443 --> 00:07:16.590\nBut I've only got 17 sales people.\n\n151\n00:07:16.590 --> 00:07:20.960\nSo, it's gonna go to sales.salesperson\nto find these 17 sales people.\n\n152\n00:07:20.960 --> 00:07:23.910\nAnd then it's gotta get their first\nname and last name out of person.person.\n\n153\n00:07:23.910 --> 00:07:27.080\nSo it's looking at two different tables or\nrelating the data and\n\n154\n00:07:27.080 --> 00:07:29.460\nthen putting it together\ninto a resultant set.\n\n155\n00:07:29.460 --> 00:07:33.740\nAnd when I run that the query analyzer\ngives the information I want.\n\n156\n00:07:33.740 --> 00:07:37.810\nAnd it just gives me one simple\nmetric down at bottom right.\n\n157\n00:07:37.810 --> 00:07:40.940\nIf I zoom in actually my\nhead's gonna cover part of it,\n\n158\n00:07:40.940 --> 00:07:43.150\nis where I can see the query time.\n\n159\n00:07:43.150 --> 00:07:45.090\nAnd the query time here\nisn't even useful for\n\n160\n00:07:45.090 --> 00:07:47.040\nme because what does it say?\n&gt;&gt; Zero.\n\n161\n00:07:47.040 --> 00:07:48.050\n&gt;&gt; Zero, right?\n\n162\n00:07:48.050 --> 00:07:49.520\nAnd it didn't take zero seconds?\n\n163\n00:07:49.520 --> 00:07:51.950\nThe server didn't already\nknow this information.\n\n164\n00:07:51.950 --> 00:07:54.560\nWhat happened is it took less\nthan a tenth of a second, or\n\n165\n00:07:54.560 --> 00:07:56.632\nactually less than\na hundredth of a second.\n\n166\n00:07:56.632 --> 00:07:59.494\nSo it might have taken .009 seconds,\n\n167\n00:07:59.494 --> 00:08:03.023\nwell that won't show up on the at counter,\nright?\n\n168\n00:08:03.023 --> 00:08:07.462\nSo the one metric they give me is really\nonly useful When I'm running a big query,\n\n169\n00:08:07.462 --> 00:08:11.077\none that's got to get a lot of data and\ncan register on that timer.\n\n170\n00:08:11.077 --> 00:08:13.030\nOtherwise it's always going to be 0.\n\n171\n00:08:13.030 --> 00:08:17.142\nBut this query did have a cost,\nit might have been a very small cost, but\n\n172\n00:08:17.142 --> 00:08:20.103\nit did have one, and\nwe don't see that by default.\n\n173\n00:08:20.103 --> 00:08:23.499\nAnd in other episodes, I've shown\nyou guys the query execution plan.\n\n174\n00:08:23.499 --> 00:08:27.534\nAnd when you're optimizing a query, this\nis really important, up top is an icon,\n\n175\n00:08:27.534 --> 00:08:29.448\nit's three little boxes with arrows.\n\n176\n00:08:29.448 --> 00:08:31.108\nAnd I can never remember which icon it is,\n\n177\n00:08:31.108 --> 00:08:32.963\nbecause there's several\nthat look the same.\n\n178\n00:08:32.963 --> 00:08:35.619\nIt's Control M on the keyboard,\nis what I always hit.\n\n179\n00:08:35.619 --> 00:08:38.422\nAnd if you hit Control M,\nthat's going to tell you,\n\n180\n00:08:38.422 --> 00:08:40.538\nsee how that icon just boxed itself in?\n\n181\n00:08:40.538 --> 00:08:45.455\nThat's going to tell it to show me the\nquery execution plan when a query runs.\n\n182\n00:08:45.455 --> 00:08:50.778\nAnd if I rerun that query, I get the same\nresults, it still tells me it's 0 seconds.\n\n183\n00:08:50.778 --> 00:08:53.741\nBut I get a nice new little\ntab that shows up right here,\n\n184\n00:08:53.741 --> 00:08:55.427\nwhere it says Execution Plan.\n\n185\n00:08:55.427 --> 00:08:58.808\nAnd if I click on that,\nit will show me what that query did,\n\n186\n00:08:58.808 --> 00:09:01.782\nremember, I said we were\npulling from two tables?\n\n187\n00:09:01.782 --> 00:09:05.366\nWell, here's where it's doing\na clustering index scan of one table,\n\n188\n00:09:05.366 --> 00:09:06.626\nthe salesperson table.\n\n189\n00:09:06.626 --> 00:09:11.236\nAnd here's an index scan of\nthe person table, person.person, and\n\n190\n00:09:11.236 --> 00:09:12.834\nsales.salesperson.\n\n191\n00:09:12.834 --> 00:09:17.280\nAnd it's reaching out to them, and\nI can see that 71% of my time,\n\n192\n00:09:17.280 --> 00:09:20.331\nthe cost was spent in\nthe clustered indexing.\n\n193\n00:09:20.331 --> 00:09:22.154\nAnd I shouldn't say time,\n\n194\n00:09:22.154 --> 00:09:26.762\nbecause remember that cost is CPU\nutilization, memory, and so on.\n\n195\n00:09:26.762 --> 00:09:29.849\nThat two-thirds, more than two-thirds,\n\n196\n00:09:29.849 --> 00:09:33.269\nof my query was spent\nlooking at person.person.\n\n197\n00:09:33.269 --> 00:09:36.889\nWell, I've only got 17 salespeople.\n\n198\n00:09:36.889 --> 00:09:40.978\nIt had to peruse that database,\nthat table.\n\n199\n00:09:40.978 --> 00:09:44.278\nThrough thousands of records\nthat weren't salespeople,\n\n200\n00:09:44.278 --> 00:09:46.393\nand that's why that cost was so high.\n\n201\n00:09:46.393 --> 00:09:50.431\nThe overall query itself, if I go up here,\nI can see was pretty small.\n\n202\n00:09:50.431 --> 00:09:55.261\nAnd it says my estimated subtree cost\nhere was 0.011, now that's not time,\n\n203\n00:09:55.261 --> 00:09:56.599\nthat's not seconds.\n\n204\n00:09:56.599 --> 00:10:00.187\nThat's just what that cost is,\nand that's very small,\n\n205\n00:10:00.187 --> 00:10:03.114\nthe estimated operator cost, 0%, right?\n\n206\n00:10:03.114 --> 00:10:07.121\nCached plan size, 24k,\nthis is a very small, simple query.\n\n207\n00:10:07.121 --> 00:10:10.195\nBut, if I look at this, I can say, man,\n\n208\n00:10:10.195 --> 00:10:15.637\nthat's probably not the most efficient\nway to do this, or maybe it is.\n\n209\n00:10:15.637 --> 00:10:17.413\nIf these indexes didn't exist,\n\n210\n00:10:17.413 --> 00:10:21.099\nthere may have been something far\nmore expensive to go in and do that.\n\n211\n00:10:21.099 --> 00:10:24.579\nSo when we write queries,\neven if the query that we write works,\n\n212\n00:10:24.579 --> 00:10:27.291\nthis query works and\ngives me exactly what I want.\n\n213\n00:10:27.291 --> 00:10:29.601\nWe still need to evaluate those\nqueries and say, all right.\n\n214\n00:10:29.601 --> 00:10:33.505\nIs there something expensive in here\nthat I could figure a way around and\n\n215\n00:10:33.505 --> 00:10:37.370\nmake it better and make it more efficient?\n&gt;&gt; Now are there certain types of\n\n216\n00:10:37.370 --> 00:10:40.103\noperations then that are just\nknown to be expensive?\n\n217\n00:10:40.103 --> 00:10:41.049\n&gt;&gt; Yeah, yeah, absolutely.\n\n218\n00:10:41.049 --> 00:10:47.238\nI'm not using any of the obvious ones\nhere, so the obvious ones are sorts.\n\n219\n00:10:47.238 --> 00:10:51.305\nIf you see a sorts statement,\nsorts can almost always be optimized.\n\n220\n00:10:51.305 --> 00:10:54.441\nIn fact, if you're just sorting for\nthe sake of sorting,\n\n221\n00:10:54.441 --> 00:10:55.979\nthat's usually a bad idea.\n\n222\n00:10:55.979 --> 00:10:59.360\nYou could have the client sort the data,\nonce they receive the result of the query,\n\n223\n00:10:59.360 --> 00:11:00.343\nthey can sort it there.\n\n224\n00:11:00.343 --> 00:11:02.446\nAnd that takes a ton of\nload off the server.\n\n225\n00:11:02.446 --> 00:11:06.580\nOr if you need the sort to happen on\nthe server, you can create an index.\n\n226\n00:11:06.580 --> 00:11:09.745\nNot a clustered index like this,\nbut a non-clustered index,\n\n227\n00:11:09.745 --> 00:11:13.399\nbecause a non-clustered index can be\nstored in a different sort order.\n\n228\n00:11:13.399 --> 00:11:15.185\nAnd with a non-clustered index,\n\n229\n00:11:15.185 --> 00:11:17.963\nI could store it already\nsorted in the order I wanted.\n\n230\n00:11:17.963 --> 00:11:20.564\nSo now the server doesn't have\nto perform this order operation,\n\n231\n00:11:20.564 --> 00:11:21.851\nit's already done it, right?\n\n232\n00:11:21.851 --> 00:11:26.460\nAnd that can make it far more efficient,\nthat's using indexes to support our query,\n\n233\n00:11:26.460 --> 00:11:29.161\nso that's sort or\none that I always watch out for.\n\n234\n00:11:29.161 --> 00:11:33.410\nAnother one would be table scans,\nthat if there was a table scan here,\n\n235\n00:11:33.410 --> 00:11:35.510\nthat means that would be no index.\n\n236\n00:11:35.510 --> 00:11:38.093\nAnd it had to read the whole table.\n\n237\n00:11:38.093 --> 00:11:41.044\nIf the table is cached into RAM,\nthat's good, it's not a big deal, right?\n\n238\n00:11:41.044 --> 00:11:44.490\nBut if it's on disc, it had to read the\nwhole table into RAM, and that's not so\n\n239\n00:11:44.490 --> 00:11:45.179\ngood, right?\n\n240\n00:11:45.179 --> 00:11:46.715\nSo that's another one to look out for.\n\n241\n00:11:46.715 --> 00:11:49.494\nAnd a third one to look out for\nare temporary tables, right?\n\n242\n00:11:49.494 --> 00:11:53.860\nWe use temporary tables in the,\nI think it was the error handling episode,\n\n243\n00:11:53.860 --> 00:11:54.841\nor one of those.\n\n244\n00:11:54.841 --> 00:11:57.983\nWhere I was taking error information,\nor deleted records, and\n\n245\n00:11:57.983 --> 00:11:59.856\nstoring them temporarily in a table.\n\n246\n00:11:59.856 --> 00:12:02.951\nWell, your regular tables are optimized.\n\n247\n00:12:02.951 --> 00:12:05.338\nPeople, database administrators at least,\n\n248\n00:12:05.338 --> 00:12:07.796\nthey think about how to\noptimize these tables.\n\n249\n00:12:07.796 --> 00:12:10.459\nAnd so they store them on hard\ndrive arrays that are optimized for\n\n250\n00:12:10.459 --> 00:12:11.803\nthe performance that you need.\n\n251\n00:12:11.803 --> 00:12:13.971\nAnd on systems that have those resources.\n\n252\n00:12:13.971 --> 00:12:18.170\nTemporary tables, on the other hand,\nthey're just stored in a default location.\n\n253\n00:12:18.170 --> 00:12:21.740\nBy default, they're actually on the same\npartition as your operating system,\n\n254\n00:12:21.740 --> 00:12:23.059\nthey don't perform as well.\n\n255\n00:12:23.059 --> 00:12:25.077\nAnytime you use a temporary table,\n\n256\n00:12:25.077 --> 00:12:28.785\nyou're storing data in an area\nthat is typically not optimized.\n\n257\n00:12:28.785 --> 00:12:33.022\nSome DBAs are really thorough and\nthey optimize their temporary databases.\n\n258\n00:12:33.022 --> 00:12:35.667\nMost aren't, though, and\nI've seen this in production a lot,\n\n259\n00:12:35.667 --> 00:12:37.990\nwhere the temporary databases\nare just left to default.\n\n260\n00:12:37.990 --> 00:12:39.979\nBecause they're temporary,\nwhat do we care?\n\n261\n00:12:39.979 --> 00:12:43.598\nBut it means anytime you use it,\nyour performance is decreasing.\n\n262\n00:12:43.598 --> 00:12:46.261\nIf it is just a one time thing,\nyou don't care about that, but\n\n263\n00:12:46.261 --> 00:12:48.992\nif this is a recurring thing,\nit's not so temporary anymore.\n\n264\n00:12:48.992 --> 00:12:53.071\nYou probably need an actual database or an\nactual place to store that temporary data.\n\n265\n00:12:53.071 --> 00:12:55.301\nRemember, it's not just\na temporary database.\n\n266\n00:12:55.301 --> 00:12:58.946\nWhen you create temporary tables,\nthey're also a part of temp DB, and\n\n267\n00:12:58.946 --> 00:13:00.359\nthat gets thrown in there.\n\n268\n00:13:00.359 --> 00:13:03.136\nSo those kind of operations can\nbe considered expensive, as well,\n\n269\n00:13:03.136 --> 00:13:04.465\nthey're all things to look at.\n\n270\n00:13:04.465 --> 00:13:07.109\nOr if you just have a query\nthat takes a long time to run,\n\n271\n00:13:07.109 --> 00:13:10.513\nthere's something in it that's\ncausing it to take a long time to run.\n\n272\n00:13:10.513 --> 00:13:12.870\nWe look at the execution plan and\nwe start to break it down and\n\n273\n00:13:12.870 --> 00:13:14.522\nfigure out what's going on.\n&gt;&gt; Okay, so\n\n274\n00:13:14.522 --> 00:13:17.757\nthese sub-queries then are really\ngoing to allow me to optimize.\n\n275\n00:13:17.757 --> 00:13:21.948\nOr take a query that's maybe a little\ntoo expensive and reduce that cost,\n\n276\n00:13:21.948 --> 00:13:24.056\nmake it run a little more efficient.\n\n277\n00:13:24.056 --> 00:13:27.072\nAny way you could show us that kind\nof that mindset or that process?\n\n278\n00:13:27.072 --> 00:13:30.586\nCan we start with an expensive query and\nsee how we can reduce that cost?\n\n279\n00:13:30.586 --> 00:13:31.466\n&gt;&gt; Yeah, absolutely.\n\n280\n00:13:31.466 --> 00:13:34.683\nLet's, because now that you\nmentioned it that way, Mike.\n\n281\n00:13:34.683 --> 00:13:37.047\nI'm thinking, wow,\nwe're 15 minutes into this episode,\n\n282\n00:13:37.047 --> 00:13:38.305\nI haven't shown a subquery yet.\n\n283\n00:13:38.305 --> 00:13:39.617\nAnd I'm not going to start right now,\n\n284\n00:13:39.617 --> 00:13:41.388\nI'm going to show you\nan expensive query instead.\n\n285\n00:13:41.388 --> 00:13:45.308\nSo let's take this query, and\nI've got it written here,\n\n286\n00:13:45.308 --> 00:13:48.360\nit gave me the information I wanted,\nright?\n\n287\n00:13:48.360 --> 00:13:50.166\nLet's make it even more expensive,\nall right?\n\n288\n00:13:50.166 --> 00:13:53.065\nI mentioned that sorts are an expense,\nright?\n\n289\n00:13:53.065 --> 00:13:57.014\nSo I'm going to add an extra line here,\nand\n\n290\n00:13:57.014 --> 00:14:01.746\nI'm going to do an ORDER BY sp.Bonus DESC,\nokay?\n\n291\n00:14:01.746 --> 00:14:04.816\nSo now,\nI'm getting the highest bonus first,\n\n292\n00:14:04.816 --> 00:14:09.205\nall the way down to the lowest bonus,\nso I'm doing a sort operator.\n\n293\n00:14:09.205 --> 00:14:10.972\nAnd I'm going to go even further, and\n\n294\n00:14:10.972 --> 00:14:13.304\nI just want to find out who\ngets the biggest bonus.\n\n295\n00:14:13.304 --> 00:14:15.513\nWho got the biggest bonus in my company?\n\n296\n00:14:15.513 --> 00:14:17.853\nWell, if I've sorted descending,\n\n297\n00:14:17.853 --> 00:14:21.554\nthe very first person has\nthe biggest bonus in my company.\n\n298\n00:14:21.554 --> 00:14:26.251\nSo I'm just going to add a TOP 1,\nright here at the beginning, saying,\n\n299\n00:14:26.251 --> 00:14:28.800\njust give me the first row, all right?\n\n300\n00:14:28.800 --> 00:14:31.679\nIt's going to run the query, it's going\nto sort it biggest to lowest, and\n\n301\n00:14:31.679 --> 00:14:33.472\nthen it's going to give\nme the very first row.\n\n302\n00:14:33.472 --> 00:14:37.384\nThis will tell me who got\nthe biggest bonus in my company,\n\n303\n00:14:37.384 --> 00:14:39.675\nand when I run that, there it is.\n\n304\n00:14:39.675 --> 00:14:42.586\nSome of these names I can't pronounce,\nso Sve,\n\n305\n00:14:42.586 --> 00:14:47.638\nI'm going to assume that's how that's\npronounced, got a bonus of $6,700.\n\n306\n00:14:47.638 --> 00:14:52.452\nGood for him, or her, I don't know\nif that's a male or female, so,\n\n307\n00:14:52.452 --> 00:14:54.205\n[LAUGH], $6,700.\n\n308\n00:14:54.205 --> 00:14:58.150\nI got the information I wanted, but\nlet's look at the execution plan and\n\n309\n00:14:58.150 --> 00:14:59.582\nsee what that shows up as.\n\n310\n00:14:59.582 --> 00:15:07.102\nWhen I look at this execution plan, I can\nsee where my primary costs ended up, okay?\n\n311\n00:15:07.102 --> 00:15:13.759\nAnd I can see that my overall query, at\nan estimated sub tree cost here of 0.01.\n\n312\n00:15:13.759 --> 00:15:19.221\nSo, again, not a hugely significant\nnumber, and it ran really, really fast.\n\n313\n00:15:19.221 --> 00:15:22.189\nSo, it's still registered as 0\ndown on my counter down there, so\n\n314\n00:15:22.189 --> 00:15:23.466\nthat doesn't really help.\n\n315\n00:15:23.466 --> 00:15:28.061\nBut, when you start to look at\nthe operations, here's the top.\n\n316\n00:15:28.061 --> 00:15:32.383\nAnd notice that that top operation,\nthat only cost me 0%,\n\n317\n00:15:32.383 --> 00:15:34.430\nthat was practically free.\n\n318\n00:15:34.430 --> 00:15:37.755\nYou've got a table, just take\nthe first row, delete everything else,\n\n319\n00:15:37.755 --> 00:15:39.567\nthat takes no effort, at all, right?\n\n320\n00:15:39.567 --> 00:15:42.925\nSo 0, I don't have to optimize the top,\nright?\n\n321\n00:15:42.925 --> 00:15:48.444\nMy nested loops, 0, I just aggregate\nthe data, that's not a big deal.\n\n322\n00:15:48.444 --> 00:15:52.798\nBut then inside of that,\nI can see where I grabbed information from\n\n323\n00:15:52.798 --> 00:15:57.491\nsales.salesperson and\nI grabbed information from person.person.\n\n324\n00:15:57.491 --> 00:16:00.833\nPerson.person had a cost of 28%.\n\n325\n00:16:00.833 --> 00:16:04.026\nGrabbing from sales.salesperson had\na cost of 17% of my query, right?\n\n326\n00:16:04.026 --> 00:16:07.427\nSo where was the bulk of the cost?\n\n327\n00:16:07.427 --> 00:16:09.126\nRight there in the sort operation.\n\n328\n00:16:09.126 --> 00:16:11.320\n58%.\n\n329\n00:16:11.320 --> 00:16:16.000\nOver half of my query cost was\nbecause of that sort operation.\n\n330\n00:16:16.000 --> 00:16:18.160\nIf I can get rid of that sort,\n\n331\n00:16:18.160 --> 00:16:20.950\nI can make this query run twice as fast.\n&gt;&gt; Right.\n\n332\n00:16:20.950 --> 00:16:23.810\nBut is the sort that gave us\nthe ability to pick that tough road.\n\n333\n00:16:23.810 --> 00:16:26.450\nSo does that not increase\nthe cost then somewhere else?\n\n334\n00:16:26.450 --> 00:16:27.490\n&gt;&gt; It would,\n\n335\n00:16:27.490 --> 00:16:31.790\nbecause that top was free\n&gt;&gt; Not really though because,\n\n336\n00:16:31.790 --> 00:16:34.440\nwhat I wanted to do is get\nthe most expensive bonus,\n\n337\n00:16:34.440 --> 00:16:37.850\nwho got the most money, and\nthe top had to work with the sort.\n\n338\n00:16:37.850 --> 00:16:40.750\nif I take one out,\nit invalidates the other, right?\n\n339\n00:16:40.750 --> 00:16:43.720\nI could ditch the top and\nthen just see all the rows and\n\n340\n00:16:43.720 --> 00:16:47.630\nlook at the first one but the sort still\ngoing to be that If I get rid of the sort,\n\n341\n00:16:47.630 --> 00:16:51.370\nthe biggest one won't be first and so\nI'll have to do some other mathematical\n\n342\n00:16:51.370 --> 00:16:52.620\ncomparison.\n&gt;&gt; So,\n\n343\n00:16:52.620 --> 00:16:57.060\nI'm going to guess then that a subquery is\nthe way we might be able to optimize this.\n\n344\n00:16:57.060 --> 00:16:57.580\n&gt;&gt; Absolutely.\n\n345\n00:16:57.580 --> 00:17:02.450\nSo here my problem is the top and\nthe sort go hand in hand.\n\n346\n00:17:02.450 --> 00:17:03.350\nThey work together.\n\n347\n00:17:03.350 --> 00:17:06.650\nI've got to do them both to get\nthe information that I want.\n\n348\n00:17:06.650 --> 00:17:09.040\nThe server can't change that.\n\n349\n00:17:09.040 --> 00:17:12.320\nThe server says, this is what you want\nthis is how I'm going to give it to you.\n\n350\n00:17:12.320 --> 00:17:15.590\nBut if I want to break this up,\nbreak this up a different way, and\n\n351\n00:17:15.590 --> 00:17:19.380\nuse a sub-query, I can actually get\nthis time down quite a bit more.\n\n352\n00:17:19.380 --> 00:17:19.960\nOkay?\n\n353\n00:17:19.960 --> 00:17:21.480\nSo let's take a look at that.\n\n354\n00:17:21.480 --> 00:17:25.420\nI'm going to basically rewrite this,\nusing a sub-query.\n\n355\n00:17:25.420 --> 00:17:27.750\nAnd what I'm gonna do is I'm gonna say,\nall right,\n\n356\n00:17:27.750 --> 00:17:31.180\nI know that the sort is my problem,\nso I want to address that first.\n\n357\n00:17:31.180 --> 00:17:35.100\nSo I'm trying to figure out,\nwho got the biggest bonus.\n\n358\n00:17:35.100 --> 00:17:41.530\nSo what if I wrote a super simple query,\nto find the biggest bonus, all right?\n\n359\n00:17:41.530 --> 00:17:43.670\nAnd that's actually easy enough to do.\n\n360\n00:17:43.670 --> 00:17:50.870\nWe could do a select max,\nof the bonus column.\n\n361\n00:17:50.870 --> 00:17:55.760\nThe max function lets me find\nthe highest value in a column.\n\n362\n00:17:55.760 --> 00:18:01.640\nI wanna pull the max bonus\nfrom sales dot sales person.\n\n363\n00:18:01.640 --> 00:18:02.190\nAlright.\n\n364\n00:18:02.190 --> 00:18:06.270\nNow that query by itself, as soon as\nI type it right, there we go, runs.\n\n365\n00:18:06.270 --> 00:18:06.910\nAnd you see what I got?\n\n366\n00:18:06.910 --> 00:18:08.840\nSix hundred thousand dollars.\n\n367\n00:18:08.840 --> 00:18:10.080\nIt's not giving me the information I want.\n\n368\n00:18:10.080 --> 00:18:13.930\nI want to know who the person was and\nwhat their bonus was but\n\n369\n00:18:13.930 --> 00:18:16.730\nit is telling me the maximum number.\n\n370\n00:18:16.730 --> 00:18:20.930\nIt didn't do a sort,\nit didn't do a top one,\n\n371\n00:18:20.930 --> 00:18:24.400\nit just specifically said I need\nthe biggest value that's stored in there,\n\n372\n00:18:24.400 --> 00:18:28.380\nwhich is super easy for\nMicrosoft SQL server to retrieve.\n\n373\n00:18:28.380 --> 00:18:30.840\nRight, so that's a really easy thing,\nthat's a super simple query.\n\n374\n00:18:31.850 --> 00:18:37.240\nI can take that result and\nfeed that into a bigger query and\n\n375\n00:18:37.240 --> 00:18:41.700\neliminate, not just the sword, but\nI can eliminate the top, as well.\n\n376\n00:18:41.700 --> 00:18:43.870\nNow, is that going to be faster?\n\n377\n00:18:43.870 --> 00:18:46.080\nNot necessarily.\n\n378\n00:18:46.080 --> 00:18:47.650\nSometimes, they aren't faster.\n\n379\n00:18:47.650 --> 00:18:49.760\nSometimes, the query you write\nis just more convoluted and\n\n380\n00:18:49.760 --> 00:18:51.170\neasier to screw up, right?\n\n381\n00:18:51.170 --> 00:18:52.390\nSo we need to double-check that.\n\n382\n00:18:52.390 --> 00:18:54.700\nWe need to measure our performance and\nsee if it is.\n\n383\n00:18:54.700 --> 00:18:57.230\nIn this case, I can almost\nguarantee it's going to be faster,\n\n384\n00:18:57.230 --> 00:19:00.180\nbecause that sort operation,\nhow big was that table?\n\n385\n00:19:00.180 --> 00:19:02.630\nThe person that proves that, actually,\nI have no idea how big the table is.\n\n386\n00:19:02.630 --> 00:19:03.580\nLet's find out.\n\n387\n00:19:03.580 --> 00:19:09.663\nSo, we were doing the sort\noff of person.person,\n\n388\n00:19:09.663 --> 00:19:15.880\nwhich contains, whoops,\nI need to write my proper query here.\n\n389\n00:19:15.880 --> 00:19:17.510\nThere is that whole syntax thing.\n&gt;&gt; Yeah,\n\n390\n00:19:17.510 --> 00:19:22.925\nyeah that all from.\n&gt;&gt; Okay, there we go, 19,972 rows.\n\n391\n00:19:22.925 --> 00:19:24.940\nSo almost 20,000 rows.\n\n392\n00:19:24.940 --> 00:19:29.490\nIt had to sort 20,000 rows just to\nfigure out who is the biggest one.\n\n393\n00:19:30.560 --> 00:19:31.687\nMax doesn't do that.\n\n394\n00:19:31.687 --> 00:19:34.747\nIn fact, Max doesn't care about the bulk\nof the rows at all, it is just looking at\n\n395\n00:19:34.747 --> 00:19:37.180\none column and finding the biggest\nvolume and moving in and out.\n\n396\n00:19:37.180 --> 00:19:40.220\nSo I can almost guarantee this\none is going to be faster.\n\n397\n00:19:40.220 --> 00:19:43.330\nBut in real life line there are so\nscenarios where this might not work.\n\n398\n00:19:43.330 --> 00:19:46.620\nSo always be aware of that,\nalways watch your query execution time.\n\n399\n00:19:46.620 --> 00:19:51.480\nSo know that I know I can get, what I want\nfrom this max bonus, let's go back and\n\n400\n00:19:51.480 --> 00:19:56.840\ntake the original query and\nkind of change that to use this subquery.\n\n401\n00:19:56.840 --> 00:19:59.470\nNow, I want to keep this query handy\nbecause I want to be able to compare\n\n402\n00:19:59.470 --> 00:20:01.140\nthe two here in just a moment.\n\n403\n00:20:01.140 --> 00:20:03.720\nSo I'm going to take this one though.\n\n404\n00:20:03.720 --> 00:20:07.180\nAnd a lot of this is\nactually gonna be the same,\n\n405\n00:20:07.180 --> 00:20:11.870\nI don't need certain pieces of it,\nbut a lot of it is the same.\n\n406\n00:20:11.870 --> 00:20:14.360\nSo let me do a little copy and paste here.\n\n407\n00:20:14.360 --> 00:20:19.960\nOops, [INAUDIBLE] Copy tool,\nand there we go, all right.\n\n408\n00:20:19.960 --> 00:20:22.800\nFirst off I can get rid of this top one,\nI don't need that anymore.\n\n409\n00:20:22.800 --> 00:20:26.820\nI'm gonna get first name, last name, and\nbonus, all right, that's what I want.\n\n410\n00:20:26.820 --> 00:20:28.590\nIt's gonna come from person.person,\n\n411\n00:20:28.590 --> 00:20:34.120\nI'm doing it a join with sales.sales\nperson, and none of that changes, right?\n\n412\n00:20:34.120 --> 00:20:38.670\nThen I'm liking business ID,\nthe difference is I'm gonna take this\n\n413\n00:20:38.670 --> 00:20:43.350\nquery that I wrote and\nI'm gonna put it in a where clause.\n\n414\n00:20:43.350 --> 00:20:48.351\nI'm gonna say, where sp.bonus = and\n\n415\n00:20:48.351 --> 00:20:55.170\nthen I'm gonna stick that\nquery inside a parenthesis.\n\n416\n00:20:55.170 --> 00:20:58.000\nSee how it's a query inside of a query?\n\n417\n00:20:58.000 --> 00:20:59.570\nThat's what makes it a subquery, right?\n\n418\n00:20:59.570 --> 00:21:02.740\nSo this query is existing.\n\n419\n00:21:02.740 --> 00:21:06.230\nAs a piece of the bigger select query.\n\n420\n00:21:06.230 --> 00:21:08.590\nAnd you can do that anywhere in the query.\n\n421\n00:21:08.590 --> 00:21:10.930\nYou can do it as a replacement for\na column.\n\n422\n00:21:10.930 --> 00:21:12.800\nIn fact, we've kind of all ready\ndone that with functions, right?\n\n423\n00:21:12.800 --> 00:21:15.640\nWe stick functions in there for\ncolumn names in the function episodes.\n\n424\n00:21:15.640 --> 00:21:17.890\nThose are technically subqueries as well,\nright?\n\n425\n00:21:17.890 --> 00:21:20.520\nExcept functions run as a part,\nso it's a little bit different.\n\n426\n00:21:20.520 --> 00:21:22.260\nBut here,\nit's a straight-up select statement.\n\n427\n00:21:22.260 --> 00:21:24.580\nYou can clearly see that's a subquery.\n\n428\n00:21:24.580 --> 00:21:28.360\nI'm doing in in a where statement,\nI could do it in a group by,\n\n429\n00:21:28.360 --> 00:21:32.360\nI could do it in a,\nany number of modifiers or operators here.\n\n430\n00:21:32.360 --> 00:21:34.570\nThere's all sorts of places\nyou can do a sub query.\n\n431\n00:21:34.570 --> 00:21:39.620\nWhat I'm doing here is saying figure\nout what the biggest bonus is, and then\n\n432\n00:21:39.620 --> 00:21:45.290\nI want you to look at that sales person\ntable, and figure out who's bonus that is.\n\n433\n00:21:45.290 --> 00:21:46.980\nWell, I've only got 17 sales people.\n\n434\n00:21:48.070 --> 00:21:56.030\nSo it just has to look at the 17 people,\nfind the biggest bonus out of 17 rows and\n\n435\n00:21:56.030 --> 00:22:01.030\nthen figure out who it was that\nthat belonged to out of 17 rows.\n\n436\n00:22:01.030 --> 00:22:05.924\nAnd then it can do the join against\nthe almost twenty thousand rows of person\n\n437\n00:22:05.924 --> 00:22:08.650\nby person for just one person.\n\n438\n00:22:08.650 --> 00:22:09.270\nRight?\n\n439\n00:22:09.270 --> 00:22:14.070\nThat’s going to be way faster because I\nbroke it up into separate pieces like\n\n440\n00:22:14.070 --> 00:22:18.680\nthis, the server is able to\naddress it more specifically.\n\n441\n00:22:18.680 --> 00:22:19.860\nIf I run this,\n\n442\n00:22:19.860 --> 00:22:23.120\nnow remember when I ran this query\nup here I'll just run it by itself.\n\n443\n00:22:23.120 --> 00:22:24.800\nThis is the original one.\n\n444\n00:22:24.800 --> 00:22:30.190\nIt told me that was\nthe highest bonus salesperson.\n\n445\n00:22:30.190 --> 00:22:35.130\nIf I run my new query, which line for\nline is not really anymore complex\n\n446\n00:22:35.130 --> 00:22:40.190\nthan the last query, when I run that,\nI get that is the highest most person.\n\n447\n00:22:40.190 --> 00:22:41.970\nI get the same thing.\n\n448\n00:22:41.970 --> 00:22:46.500\nSo as far as results are concerned,\nthese two queries are identical.\n\n449\n00:22:46.500 --> 00:22:49.170\nSo, does it matter which one I run?\n\n450\n00:22:49.170 --> 00:22:51.080\nIt does when we compare them, right?\n\n451\n00:22:51.080 --> 00:22:52.810\nLet's compare these and see.\n\n452\n00:22:52.810 --> 00:22:55.210\nI'm gonna run them both in a batch.\n\n453\n00:22:55.210 --> 00:22:58.790\nAnd so when I run them both together,\nthere's the results side by side, right?\n\n454\n00:22:58.790 --> 00:23:01.220\nMy unoptimized query and\nmy optimized query.\n\n455\n00:23:01.220 --> 00:23:03.010\nI'm gonna make this window\na little bit bigger.\n\n456\n00:23:04.250 --> 00:23:04.870\nOkay?\n\n457\n00:23:04.870 --> 00:23:08.510\nSo I can see the result inserted there.\n\n458\n00:23:08.510 --> 00:23:10.330\nWhen I look at the execution plan,\n\n459\n00:23:10.330 --> 00:23:13.180\nhere's what I'm gonna see in\nmy big differences, okay?\n\n460\n00:23:13.180 --> 00:23:15.760\nThe first one here,\nis my older query, right?\n\n461\n00:23:15.760 --> 00:23:17.940\nThe one that I keep saying is bad.\n\n462\n00:23:17.940 --> 00:23:21.750\nWell, that's not a guarantee it is bad,\nI just keep saying that, right?\n\n463\n00:23:21.750 --> 00:23:25.080\nAnd when I look at it,\nit's only got five steps.\n\n464\n00:23:25.080 --> 00:23:27.060\nRight?\nSo that doesn't seem bad.\n\n465\n00:23:27.060 --> 00:23:28.750\nLook at my other query down here.\n\n466\n00:23:28.750 --> 00:23:32.030\nIn fact, I think my head's covering\njust a little bit of this.\n\n467\n00:23:32.030 --> 00:23:37.690\nBut it has, let's see, three,\nfour, five, six, six steps.\n\n468\n00:23:37.690 --> 00:23:40.370\nI've introduced one more step.\n&gt;&gt; Gotta be worse,\n\n469\n00:23:40.370 --> 00:23:42.253\nthen.\n&gt;&gt; You would think, right?\n\n470\n00:23:42.253 --> 00:23:44.740\nBut, remember how bad I said sorts were?\n\n471\n00:23:44.740 --> 00:23:45.660\nLook at a lot of these steps.\n\n472\n00:23:45.660 --> 00:23:48.280\nMost of these steps are not\nthat big of a deal.\n\n473\n00:23:48.280 --> 00:23:51.845\nIn fact, let me zoom in\nbecause this is kind of crazy.\n\n474\n00:23:51.845 --> 00:23:54.070\n[LAUGH] So we've got these\nnested loops that we're doing.\n\n475\n00:23:54.070 --> 00:23:57.208\nAnd we had nested loops up here,\ntoo, so that's not anything special,\n\n476\n00:23:57.208 --> 00:23:59.792\nexcept here I've got two\ndifferent nested loops, right?\n\n477\n00:23:59.792 --> 00:24:01.996\nThe nested loop up here had a 0% cost.\n\n478\n00:24:01.996 --> 00:24:02.970\nIt was practically free.\n\n479\n00:24:02.970 --> 00:24:04.011\nMy frist one does, too.\n\n480\n00:24:04.011 --> 00:24:06.493\nMy second one has a 1% cost, so.\n\n481\n00:24:06.493 --> 00:24:09.424\nAgain, it starts to seem like\nI'm making things worse, right?\n\n482\n00:24:09.424 --> 00:24:11.590\nI've got a stream aggregate where\nwe're putting data together.\n\n483\n00:24:11.590 --> 00:24:12.670\nThat was free.\n\n484\n00:24:12.670 --> 00:24:16.842\nMy clustered index scans\nof the two tables at 33%.\n\n485\n00:24:16.842 --> 00:24:21.180\nThat's different than what we saw up here,\n28% and 17%, right?\n\n486\n00:24:21.180 --> 00:24:23.694\nSo, it looks like I made it worse.\n\n487\n00:24:23.694 --> 00:24:29.532\nAnd then down here towards the bottom,\nwhich somehow I will scroll down to see.\n\n488\n00:24:29.532 --> 00:24:33.790\nWe've got this last little\nstep that's hiding from me.\n\n489\n00:24:33.790 --> 00:24:37.240\nHere, another clustered\nindex seek of Person.Person.\n\n490\n00:24:37.240 --> 00:24:40.470\nWe're actually reaching out to\nthe SalesPerson table twice, once for\n\n491\n00:24:40.470 --> 00:24:42.610\nthe sub-query and once for\nthe parent query.\n\n492\n00:24:42.610 --> 00:24:45.980\nSo I've introduced a whole third lookup.\n\n493\n00:24:45.980 --> 00:24:47.770\nThat sounds bad, right?\n\n494\n00:24:47.770 --> 00:24:50.660\nAnd as humans, we're visual people,\nwe look at things visually like this.\n\n495\n00:24:50.660 --> 00:24:52.960\nBut we have to remember\nthese are all percentages.\n\n496\n00:24:52.960 --> 00:24:58.320\nAnd percentages only mean something if you\nknow what they're a percentage of, right?\n\n497\n00:24:58.320 --> 00:25:02.004\nIf I look at the sub-tree values\nhere from my original query,\n\n498\n00:25:02.004 --> 00:25:06.900\nthe estimated sub-tree cost was 0.019,\nright?\n\n499\n00:25:06.900 --> 00:25:08.050\nSo when I talk about a percentage,\n\n500\n00:25:08.050 --> 00:25:10.196\nI'm talking about percentage\nof that number, right?\n\n501\n00:25:10.196 --> 00:25:17.500\nSo 20% of 0.019 is not that much, right,\nbut its out of this total number.\n\n502\n00:25:17.500 --> 00:25:24.236\nWhen I look at my new query,\nits sub-tree cost 0.009, right?\n\n503\n00:25:24.236 --> 00:25:26.480\nLess than half.\n\n504\n00:25:26.480 --> 00:25:30.180\nLess than half the estimated\nsub-tree cost of the other query.\n\n505\n00:25:30.180 --> 00:25:33.113\nRemember I said by eliminating that sort\nwe should be able to make a query run\n\n506\n00:25:33.113 --> 00:25:34.150\ntwice as fast?\n\n507\n00:25:34.150 --> 00:25:35.309\nWe did, all right?\n\n508\n00:25:35.309 --> 00:25:38.890\nIt's running twice as fast\nas that other operator.\n\n509\n00:25:38.890 --> 00:25:46.960\nAnd that's a big deal, that's a big chunk\nof time and CPU and memory that we save.\n\n510\n00:25:46.960 --> 00:25:48.470\nIn this case, mostly the CPU.\n\n511\n00:25:48.470 --> 00:25:53.350\nThat it was able to do it a lot faster\ncuz it's not having to sort 20,000 rows.\n\n512\n00:25:53.350 --> 00:25:56.440\nIt just finds it, generates it,\nand sticks it out right here.\n\n513\n00:25:56.440 --> 00:26:01.643\nSo, that is a great way to grab\nthat data and much more efficient.\n\n514\n00:26:01.643 --> 00:26:03.835\nNow, how would I have known that?\n\n515\n00:26:03.835 --> 00:26:04.795\nI might not have, right?\n\n516\n00:26:04.795 --> 00:26:07.335\nIf I wrote the original query and\nit worked and I was happy with it,\n\n517\n00:26:07.335 --> 00:26:09.015\nI might have just left it, right?\n\n518\n00:26:09.015 --> 00:26:10.365\nBut if I start looking at my server and\n\n519\n00:26:10.365 --> 00:26:12.295\ntrying to find ways to\nimprove performance,\n\n520\n00:26:12.295 --> 00:26:15.875\nthat's when we break down that query,\nwe find spots where we might be able\n\n521\n00:26:15.875 --> 00:26:18.690\nto break it into a subquery\nthat's far more simple.\n\n522\n00:26:18.690 --> 00:26:20.420\nAnd then we check performance and\nwe see where we get it.\n\n523\n00:26:20.420 --> 00:26:23.510\nSo here,\nthe subquery made a huge difference.\n\n524\n00:26:23.510 --> 00:26:26.210\nI can get twice the power\nout of my servers now,\n\n525\n00:26:26.210 --> 00:26:28.030\nassuming this is the only\nquery I ever run.\n\n526\n00:26:28.030 --> 00:26:30.880\nThis is a little specialized,\nso maybe not the best example.\n\n527\n00:26:30.880 --> 00:26:34.540\nBut you can get a lot more performance out\nof your servers if you optimize this way.\n\n528\n00:26:34.540 --> 00:26:37.010\nAnd that's what subqueries let you do.\n&gt;&gt; Fantastic, Don.\n\n529\n00:26:37.010 --> 00:26:40.036\nAll right, great look at subqueries, or\nat least a first look at subqueries.\n\n530\n00:26:40.036 --> 00:26:42.920\nI know we got a little more that\nyou wanna talk about with these.\n\n531\n00:26:42.920 --> 00:26:45.220\nUnfortunately, we are out of time for\nthis particular episode.\n\n532\n00:26:45.220 --> 00:26:48.436\nSo we're gonna have to come back and do\na part two, if that's okay with you, Don.\n\n533\n00:26:48.436 --> 00:26:49.760\n&gt;&gt; Absolutely, definitely come back.\n\n534\n00:26:49.760 --> 00:26:52.870\nWhat I just showed you right there\nwas the simplest form of a subquery.\n\n535\n00:26:52.870 --> 00:26:54.360\nI want to go a little more advanced and\n\n536\n00:26:54.360 --> 00:26:56.210\nshow you guys some more\ncomplex subqueries.\n\n537\n00:26:56.210 --> 00:26:59.534\nAnd I also want to show you\nhow subqueries can be misused.\n\n538\n00:26:59.534 --> 00:27:01.070\nI just made them look really good, right?\n\n539\n00:27:01.070 --> 00:27:02.501\nIt works twice as fast!\n\n540\n00:27:02.501 --> 00:27:04.820\nBut they can actually be\ntwice as bad sometimes.\n\n541\n00:27:04.820 --> 00:27:06.345\nAnd so\nI want to show you guys how to spot that,\n\n542\n00:27:06.345 --> 00:27:08.370\nand we'll do all that in part two.\n&gt;&gt; Fantastic.\n\n543\n00:27:08.370 --> 00:27:09.640\nAll right, well,\nhpe to see everybody there.\n\n544\n00:27:09.640 --> 00:27:11.170\nI hope you enjoyed watching this one.\n\n545\n00:27:11.170 --> 00:27:13.990\nSigning off for ITProTV,\nI've been your host, Mike Rodrick.\n\n546\n00:27:13.990 --> 00:27:14.580\n&gt;&gt; And I'm Don Pezet.\n\n547\n00:27:14.580 --> 00:27:19.843\n&gt;&gt; We'll see you next time.\n\n548\n00:27:19.843 --> 00:27:22.831\n[MUSIC]\n\n549\n00:27:22.831 --> 00:27:25.648\n&gt;&gt; Thank you for watching ITProTV.\n\n",
          "vimeoId": "250289089"
        },
        {
          "description": "In this episode, Don demonstrates how to use subqueries to make complex queries more efficient. He explains how query execution plans are calculated and then shows how to measure whether or not a subquery can provide a performance improvement over a complex query.",
          "length": "3352",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-1-2-subqueries_pt2-010818-PGM.00_36_09_23.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-1-2-subqueries_pt2-010818-PGM.00_36_09_23.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-1-2-subqueries_pt2-010818-PGM.00_36_09_23.Still001-sm.jpg",
          "title": "Subqueries Part 2",
          "transcript": "WEBVTT\n\n1\n00:00:00.330 --> 00:00:01.933\nWelcome to ITProTV, I'm your host.\n\n2\n00:00:01.933 --> 00:00:06.853\n[CROSSTALK]\n\n3\n00:00:06.853 --> 00:00:09.209\n[MUSIC]\n\n4\n00:00:09.209 --> 00:00:12.929\n&gt;&gt; You're watching ITProTV.\n&gt;&gt; Hello,\n\n5\n00:00:12.929 --> 00:00:17.378\nwelcome to another exciting episode here\nat ITProTV, I'm your host, Mike Rodrick.\n\n6\n00:00:17.378 --> 00:00:22.060\nIn this episode, we're gonna be taking a\nlook at query and data with transact SQL.\n\n7\n00:00:22.060 --> 00:00:25.170\nThis is actually a part two, so if you\nmissed part one, make sure you go back and\n\n8\n00:00:25.170 --> 00:00:26.370\ncheck that one out.\n\n9\n00:00:26.370 --> 00:00:28.738\nHere to continue on with\nour subqueries is Mr.\n\n10\n00:00:28.738 --> 00:00:30.895\nDon Pezet, how are you doing, Don?\n&gt;&gt; Hi,\n\n11\n00:00:30.895 --> 00:00:34.139\nI am ready to do a substandard\njob presenting subqueries.\n\n12\n00:00:34.139 --> 00:00:36.536\n[LAUGH] So in the last episode,\nif you watched part one,\n\n13\n00:00:36.536 --> 00:00:38.160\nwe got a chance to see subqueries.\n\n14\n00:00:38.160 --> 00:00:41.840\nAnd I showed how we can leverage them\nto make our queries far more efficient.\n\n15\n00:00:41.840 --> 00:00:46.047\nSo we went through an example of\nwhere we were pulling up which of our\n\n16\n00:00:46.047 --> 00:00:48.387\nsalespeople got the biggest bonus.\n\n17\n00:00:48.387 --> 00:00:51.980\nAnd I wrote it as a normal query,\na single query statement, originally.\n\n18\n00:00:51.980 --> 00:00:55.949\nAnd then we broke it into pieces as\na subquery, and saw that by doing it that\n\n19\n00:00:55.949 --> 00:01:00.318\nway, by doing it as two steps, we were\nactually able to double our performance.\n\n20\n00:01:00.318 --> 00:01:04.796\nWe were able to decrease the cost\nof that query by over 50%.\n\n21\n00:01:04.796 --> 00:01:07.722\nWhich is really an amazing gain, and\nreally helped to highlight how important\n\n22\n00:01:07.722 --> 00:01:10.580\nsubqueries are, and how we should know\nabout them as an optimization tool.\n\n23\n00:01:10.580 --> 00:01:14.240\nAnd we're gonna kinda continue\ngoing with that here in part two.\n\n24\n00:01:14.240 --> 00:01:15.832\n&gt;&gt; Fantastic, yeah it was really neat,\n\n25\n00:01:15.832 --> 00:01:18.416\nthe way we could, as you were saying,\nif running at one time,\n\n26\n00:01:18.416 --> 00:01:20.189\nit didn't seem like we gained that much.\n\n27\n00:01:20.189 --> 00:01:21.825\nBut we can use our imagination and\n\n28\n00:01:21.825 --> 00:01:25.112\nthink about a large customer running\nthose queries over and over.\n\n29\n00:01:25.112 --> 00:01:29.210\nThat part where we save,\nwe cut it in half, that's a huge gain.\n\n30\n00:01:29.210 --> 00:01:34.724\nSo is that example that you showed us\nrepresentative of most subqueries then?\n\n31\n00:01:34.724 --> 00:01:37.924\n&gt;&gt; For those of you taking the exam,\n\n32\n00:01:37.924 --> 00:01:40.331\nyes, in real life, no.\n\n33\n00:01:40.331 --> 00:01:42.680\nSo what I showed you right there\nwas pretty straightforward.\n\n34\n00:01:42.680 --> 00:01:44.660\nAnd in fact,\nlet me bring it back up on the screen.\n\n35\n00:01:44.660 --> 00:01:48.360\nSo the query I started with in the last\nepisode was this guy right here.\n\n36\n00:01:48.360 --> 00:01:53.350\nAnd it had a top operation and an order by\noperation, to help find the biggest value\n\n37\n00:01:53.350 --> 00:01:57.590\nin a articular set of data,\nwhich was pretty inefficient.\n\n38\n00:01:57.590 --> 00:02:02.535\nAnd I rewrote that by using a simple\nquery, this guy, the select max bonus from\n\n39\n00:02:02.535 --> 00:02:07.440\nsales.salesperson, to reduce\nthe amount of results that I got.\n\n40\n00:02:07.440 --> 00:02:11.020\nNow, in this example,\nthe subquery I used was super,\n\n41\n00:02:11.020 --> 00:02:15.240\nsuper simple, it's returning one value.\n\n42\n00:02:15.240 --> 00:02:20.010\nThat's called a scalar query,\nwhen I run that, I get a single result.\n\n43\n00:02:20.010 --> 00:02:22.160\nAnd it doesn't matter\nhow many times I run it,\n\n44\n00:02:22.160 --> 00:02:26.760\nor in what context I use it,\nit's always returning one result.\n\n45\n00:02:26.760 --> 00:02:30.912\nBut a subquery doesn’t have to be that\nway, a subquery could return a table, and\n\n46\n00:02:30.912 --> 00:02:32.825\nthey call it a table-valued query.\n\n47\n00:02:32.825 --> 00:02:34.970\nIf you watched the functions episode,\nthese are familiar terms.\n\n48\n00:02:34.970 --> 00:02:36.325\nCuz we had scalar functions and\n\n49\n00:02:36.325 --> 00:02:39.300\ntable-valued functions,\nsame thing with subqueries, right?\n\n50\n00:02:39.300 --> 00:02:43.790\nNow, with a table-valued subquery,\nwhat you'll find is\n\n51\n00:02:43.790 --> 00:02:47.340\nthat they don't usually have the same\nreturn on investment, right?\n\n52\n00:02:47.340 --> 00:02:50.350\nThat by taking the time\nto write this subquery,\n\n53\n00:02:50.350 --> 00:02:52.900\nI doubled my capacity to run this query.\n\n54\n00:02:52.900 --> 00:02:55.020\nThat was a pretty good\nreturn on investment,\n\n55\n00:02:55.020 --> 00:02:59.065\nright, but when you start dealing with\ntable value, it's not always as great.\n\n56\n00:02:59.065 --> 00:03:02.776\nSo I wanna show you guys an example\nof a table value subquery.\n\n57\n00:03:02.776 --> 00:03:04.869\nAnd I also wanna show you an example\nof how sometimes it doesn't make\n\n58\n00:03:04.869 --> 00:03:05.615\na difference, right?\n\n59\n00:03:05.615 --> 00:03:07.405\nSo let me come in here,\n\n60\n00:03:07.405 --> 00:03:11.600\nand I'm gonna write this query,\nwell, I'll write a new query.\n\n61\n00:03:11.600 --> 00:03:18.251\nLet's pull up a list of our customers,\nor our salespeople, right?\n\n62\n00:03:18.251 --> 00:03:20.930\nRemember, I said there\nwere 17 salespeople.\n\n63\n00:03:20.930 --> 00:03:22.833\nAnd I've got this table,\n\n64\n00:03:22.833 --> 00:03:27.920\nif I do select * from sales.salesperson,\nthat table right there.\n\n65\n00:03:27.920 --> 00:03:34.086\nI can query against it, I get 17 rows\nback, each one is a salesperson.\n\n66\n00:03:34.086 --> 00:03:37.667\nAnd it's all right here, that's great,\nbut it doesn't have their first name and\n\n67\n00:03:37.667 --> 00:03:38.445\ntheir last name.\n\n68\n00:03:38.445 --> 00:03:41.500\nSo I wanna connect to get their first\nname and last name, and bring it back.\n\n69\n00:03:41.500 --> 00:03:44.551\nFirst name and last name are in that\nperson.person table that has almost\n\n70\n00:03:44.551 --> 00:03:47.000\n20,000 rows, it's a big table, right.\n\n71\n00:03:47.000 --> 00:03:51.678\nSo when I put these together I can\nget that as a subquery if I want, or\n\n72\n00:03:51.678 --> 00:03:54.400\nthere's other creative\nways on how to do this.\n\n73\n00:03:54.400 --> 00:03:59.170\nSo here, I wanna pull the information,\nI'm gonna say that I wanna select, and\n\n74\n00:03:59.170 --> 00:04:01.710\nI need to pull from more than\none location on this one.\n\n75\n00:04:01.710 --> 00:04:07.420\nSo I wanna pull from person.person,\n\n76\n00:04:07.420 --> 00:04:09.830\nbecause I want to get the first name and\nlast name.\n\n77\n00:04:09.830 --> 00:04:13.426\nSo I'm gonna come in here and\ntell it, I want first name and\n\n78\n00:04:13.426 --> 00:04:19.150\nlast name from person.person, right?\n\n79\n00:04:19.150 --> 00:04:23.540\nBut I don't want everybody from\nperson.person, I just want my salespeople.\n\n80\n00:04:23.540 --> 00:04:27.810\nSo I'm gonna add a where BusinessEntityID,\n\n81\n00:04:27.810 --> 00:04:29.570\nthat's the identifier for\neach of my people.\n\n82\n00:04:29.570 --> 00:04:32.975\nSee here in the sales.salesperson table,\nI've got the BusinessEntityID for\n\n83\n00:04:32.975 --> 00:04:34.780\neach of these salespeople.\n\n84\n00:04:34.780 --> 00:04:39.092\nSo I'm gonna say,\nI wanna pull from person.person where\n\n85\n00:04:39.092 --> 00:04:44.640\nthe BusinessEntityID is in, and\nthen I'm gonna run a table valued query.\n\n86\n00:04:44.640 --> 00:04:53.602\nI'm going to say select BusinessEntityID\nfrom sales.salesperson,\n\n87\n00:04:53.602 --> 00:04:58.988\nwhich if I spell it\nwrong is not gonna work.\n\n88\n00:04:58.988 --> 00:05:01.379\nIntellisense to save the day there,\nand then I'll close that off.\n\n89\n00:05:01.379 --> 00:05:02.934\n&gt;&gt; So now we've got our inner query,\n\n90\n00:05:02.934 --> 00:05:06.419\ninstead of returning a single value,\nit's actually gonna return a table for\n\n91\n00:05:06.419 --> 00:05:08.063\nall of those salespeople.\n&gt;&gt; Right,\n\n92\n00:05:08.063 --> 00:05:10.840\nyeah, and you can even highlight and\njust run that piece.\n\n93\n00:05:10.840 --> 00:05:14.655\nIf I just run that piece there it is,\nI get a list,\n\n94\n00:05:14.655 --> 00:05:18.205\nthese BusinessEntityIDs are salespeople.\n\n95\n00:05:18.205 --> 00:05:22.931\nAnd it's gonna pull first name and\nlast name from person.person only\n\n96\n00:05:22.931 --> 00:05:27.680\nif their BusinessEntityID is in\nthis resultant set right here.\n\n97\n00:05:27.680 --> 00:05:31.250\nThis is useful because if I add new\nbusiness entity IDs in the future,\n\n98\n00:05:31.250 --> 00:05:34.710\nthen this query will automatically pick\nthem up, the data stays current, and\n\n99\n00:05:34.710 --> 00:05:36.170\nwe get that information.\n\n100\n00:05:36.170 --> 00:05:39.690\nSo it's gonna reach out, and\nit's gonna grab that data, and\n\n101\n00:05:39.690 --> 00:05:43.780\nwhen I run that,\nhere I get my first name and my last name.\n\n102\n00:05:43.780 --> 00:05:47.616\nI guess I probably should have\nadded business entity ID to it, but\n\n103\n00:05:47.616 --> 00:05:50.428\nwhatever, and\nI can see that I got 17 people.\n\n104\n00:05:50.428 --> 00:05:54.219\nI got a first name and a last name,\nwhich are not stored in sales.salesperson,\n\n105\n00:05:54.219 --> 00:05:56.500\nthose are stored in person.person.\n\n106\n00:05:56.500 --> 00:06:01.640\nAnd I was able to leverage a resultant set\nof data from a completely separate table\n\n107\n00:06:01.640 --> 00:06:03.510\nthat gave me that information.\n\n108\n00:06:03.510 --> 00:06:08.820\nSo there's a table valued subquery that's\ndifferent than a scalar sub query.\n\n109\n00:06:08.820 --> 00:06:12.722\nIt's not just one piece of information,\nit's a whole collection of data, and\n\n110\n00:06:12.722 --> 00:06:15.732\nI can then go and use that.\n&gt;&gt; It kinda looks like something we've\n\n111\n00:06:15.732 --> 00:06:19.022\ndone before, Don, where we used\na join to get those similar results.\n\n112\n00:06:19.022 --> 00:06:19.796\n&gt;&gt; Yeah, and\n\n113\n00:06:19.796 --> 00:06:22.811\nwe certainly could have used a join here.\n\n114\n00:06:22.811 --> 00:06:26.575\nJoins can be a little bit more complex,\nbecause you've got inner joins and outer\n\n115\n00:06:26.575 --> 00:06:30.350\njoins, and left, right, and full outer\njoins, and which one matches up here?\n\n116\n00:06:30.350 --> 00:06:34.798\nIf I do a join between person.person and\nsales.salesperson, well,\n\n117\n00:06:34.798 --> 00:06:38.144\nthere's only 17 entries\nin sales.salesperson.\n\n118\n00:06:38.144 --> 00:06:44.452\nSo what happened to the other 19,982 or\nwhatever, 83 records?\n\n119\n00:06:44.452 --> 00:06:47.167\nWell, depending on which type of join\nI do, it might leave them out, or\n\n120\n00:06:47.167 --> 00:06:48.410\nit might include them.\n\n121\n00:06:48.410 --> 00:06:50.390\nSo it might be a little more\ncomplex to do a join, but\n\n122\n00:06:50.390 --> 00:06:52.470\nit can achieve the same exact thing.\n\n123\n00:06:52.470 --> 00:06:56.370\nIn fact, here, let me rewrite\nthis as a join, and you'll see.\n\n124\n00:06:56.370 --> 00:07:02.820\nI could have said select, and here I'm\ngoing to have to pull a first name and\n\n125\n00:07:02.820 --> 00:07:08.200\nlast name, which are going to\ncome from the person.person.\n\n126\n00:07:08.200 --> 00:07:11.290\nSince I'm dealing with two tables,\nI've gotta do an alias, so\n\n127\n00:07:11.290 --> 00:07:13.085\nI can keep all this straight.\n\n128\n00:07:13.085 --> 00:07:17.640\nIt's gonna come from person.person,\nI didn't have to do aliases in the first\n\n129\n00:07:17.640 --> 00:07:21.030\nquery because it's two separate queries,\nright?\n\n130\n00:07:21.030 --> 00:07:23.910\nSo it knows in the first select statement,\nI'm getting first name and\n\n131\n00:07:23.910 --> 00:07:26.120\nlast name from person.person.\n\n132\n00:07:26.120 --> 00:07:28.732\nAnd the subquery knows I'm\ngetting BusinessEntityID from\n\n133\n00:07:28.732 --> 00:07:29.940\nthe sales.salesperson.\n\n134\n00:07:31.040 --> 00:07:35.636\nBut in a join, it doesn't know which of\nthe two tables I'm getting first name and\n\n135\n00:07:35.636 --> 00:07:36.595\nlast name from.\n\n136\n00:07:36.595 --> 00:07:39.870\nSo I have to tell it, that's why\nI'm doing the alias for p there,\n\n137\n00:07:39.870 --> 00:07:41.730\nso it knows which table to pull from.\n\n138\n00:07:41.730 --> 00:07:45.100\nA little more complex, but\nthe end result will be the same.\n\n139\n00:07:45.100 --> 00:07:49.992\nI'm gonna do a join on sales.salesperson,\nand\n\n140\n00:07:49.992 --> 00:07:53.342\nI'll give that one an alias of s.\n\n141\n00:07:53.342 --> 00:08:02.016\nAnd I'll link these together based\non p.businessentityid equaling s.\n\n142\n00:08:02.016 --> 00:08:03.970\nBusiness entity ID.\n\n143\n00:08:03.970 --> 00:08:05.636\nLike that, okay?\n\n144\n00:08:05.636 --> 00:08:08.210\nNow, I'm doing an inner join.\n\n145\n00:08:08.210 --> 00:08:12.640\nAnd that means that if it doesn't find a\nmatch, if it's like a null on one side or\n\n146\n00:08:12.640 --> 00:08:14.440\nthe other, it's just gonna leave it out.\n\n147\n00:08:14.440 --> 00:08:15.460\nAnd so it's gonna get excluded.\n\n148\n00:08:15.460 --> 00:08:19.010\nAnd that's what I want, as opposed\nto doing an outer join on this one.\n\n149\n00:08:19.010 --> 00:08:21.670\nAnd if you watched our join episodes,\nyou remember that.\n\n150\n00:08:21.670 --> 00:08:24.942\nNow, when I run it,\nI get the information back.\n\n151\n00:08:24.942 --> 00:08:28.682\nAnd as I look, I've got 17 entries.\n\n152\n00:08:28.682 --> 00:08:29.980\nI've got the same data, right?\n\n153\n00:08:29.980 --> 00:08:34.840\nThis is effectively the same result in\nset whether I do it as a subquery or\n\n154\n00:08:34.840 --> 00:08:37.790\nwhether I do it as a parent query here.\n\n155\n00:08:37.790 --> 00:08:42.950\nIn this scenario they both run,\nthey both get me the same information.\n\n156\n00:08:42.950 --> 00:08:48.380\nSo you might ask yourself-\n&gt;&gt; Which one is better performance or?\n\n157\n00:08:48.380 --> 00:08:49.330\n&gt;&gt; Yeah, exactly.\n\n158\n00:08:49.330 --> 00:08:51.610\nWhich one do I wanna do?\n\n159\n00:08:51.610 --> 00:08:56.630\nIn the last episode, in part one, I showed\nyou an overwhelming example of where you\n\n160\n00:08:56.630 --> 00:08:58.990\nabsolutely want to do it as a subquery.\n\n161\n00:08:58.990 --> 00:09:01.430\nWell, I picked this one on purpose.\n\n162\n00:09:01.430 --> 00:09:05.070\nBecause this one is kind of interesting,\nright?\n\n163\n00:09:05.070 --> 00:09:08.060\nI'm running a select\nstatement against one table.\n\n164\n00:09:08.060 --> 00:09:11.850\nBut my results are coming\nout of a second table.\n\n165\n00:09:11.850 --> 00:09:14.550\nWhen I do the join, it's the same.\n\n166\n00:09:14.550 --> 00:09:16.920\nMy results are coming out of one table.\n\n167\n00:09:16.920 --> 00:09:20.051\nAnd the join is tying in a second one just\nto figure where there's a null value and\n\n168\n00:09:20.051 --> 00:09:21.240\nwhere there isn't, right?\n\n169\n00:09:22.410 --> 00:09:27.380\nWhen the server goes to execute this,\neven though my top query is broken into\n\n170\n00:09:27.380 --> 00:09:30.360\ntwo pieces, there's really only\none way it can get that data.\n\n171\n00:09:30.360 --> 00:09:34.520\nAnd it's the same way it's gonna get\nthe data with the join down here.\n\n172\n00:09:34.520 --> 00:09:36.640\nIf I run them both in batch, right, so\n\n173\n00:09:36.640 --> 00:09:39.830\nthey're both gonna run,\nI'm gonna get the same result in set.\n\n174\n00:09:39.830 --> 00:09:42.650\nWell, it's not exactly the same, right?\n\n175\n00:09:42.650 --> 00:09:46.260\nIn the first query,\nnotice how Stephen Jang is first?\n\n176\n00:09:46.260 --> 00:09:48.280\nAnd then Michael Blythe the second?\n\n177\n00:09:48.280 --> 00:09:52.410\nIn the second query, Syed Abbas is\nfirst and David Campbell is second.\n\n178\n00:09:52.410 --> 00:09:54.180\nThey're in a different order, right?\n\n179\n00:09:54.180 --> 00:09:57.640\nIt did actually retrieve the information\na little bit differently.\n\n180\n00:09:57.640 --> 00:10:00.880\nBut the end result is that\nthey both got 17 rows.\n\n181\n00:10:00.880 --> 00:10:05.890\nAnd while in the first query,\nmight be number six.\n\n182\n00:10:05.890 --> 00:10:09.420\nIn the second query is still in there.\n\n183\n00:10:09.420 --> 00:10:11.520\nIf I can get my mouse right on it.\n\n184\n00:10:11.520 --> 00:10:12.646\nFine little line.\n\n185\n00:10:12.646 --> 00:10:14.370\nThere he is, he's number four, right?\n\n186\n00:10:14.370 --> 00:10:15.865\nSo instead of number six,\nhe's number four.\n\n187\n00:10:15.865 --> 00:10:16.800\nThat doesn't matter to me.\n\n188\n00:10:16.800 --> 00:10:18.520\nI didn't do a sort operation or anything.\n\n189\n00:10:18.520 --> 00:10:20.090\nI just needed those people back.\n\n190\n00:10:20.090 --> 00:10:21.500\nI didn't care what order.\n\n191\n00:10:21.500 --> 00:10:26.200\nAnd even if I did a sort operation,\nthey would both have to do the sort and\n\n192\n00:10:26.200 --> 00:10:26.800\nprovide it to me.\n\n193\n00:10:26.800 --> 00:10:28.810\nSo that's not going to make an impact.\n\n194\n00:10:28.810 --> 00:10:32.630\nIf I look at the execution plans, though,\nthis is where it gets really interesting.\n\n195\n00:10:32.630 --> 00:10:34.440\nLook at these two execution plans.\n\n196\n00:10:34.440 --> 00:10:38.880\nI might need to hide my, well,\nI guess I can sort of get in here.\n\n197\n00:10:40.240 --> 00:10:45.220\nIf you take a look at the execution plans,\nyou might notice something interesting.\n\n198\n00:10:45.220 --> 00:10:46.730\n&gt;&gt; My eyes aren't that good, Don, but\n\n199\n00:10:46.730 --> 00:10:49.740\nthey look identical.\n&gt;&gt; They look identical because they\n\n200\n00:10:49.740 --> 00:10:50.710\nare identical.\n\n201\n00:10:50.710 --> 00:10:56.440\nIn this case, the sub-query in the JOIN,\nit follows the same execution plan.\n\n202\n00:10:56.440 --> 00:10:58.990\nSo, which one is the better option here?\n\n203\n00:11:00.050 --> 00:11:01.960\nThere isn't a better option,\nthey're the same.\n\n204\n00:11:01.960 --> 00:11:05.841\nIf I look at the sub-tree cost on the\nfirst one, which is not showing up for me.\n\n205\n00:11:05.841 --> 00:11:07.965\nThere we go.\nIt's 0.011.\n\n206\n00:11:07.965 --> 00:11:11.507\nIf I look at the sub-tree cost\nin the second one, 0.011.\n\n207\n00:11:11.507 --> 00:11:14.400\nAnd if I went out to full\ndecimals it's identical, right?\n\n208\n00:11:14.400 --> 00:11:16.540\nThese are the same query, right?\n\n209\n00:11:16.540 --> 00:11:19.820\nThe results are the same,\nalthough maybe a slightly different order,\n\n210\n00:11:19.820 --> 00:11:21.910\nthe results are the same,\nthe execution plan is the same.\n\n211\n00:11:21.910 --> 00:11:25.650\nThe only thing that's different is how I\nwrote it, and that's because when you send\n\n212\n00:11:25.650 --> 00:11:30.690\na query to the SQL server,\nit has it's own query optimization engine.\n\n213\n00:11:30.690 --> 00:11:35.830\nIT compiles and optimizes the query\nto run it as fast as possible.\n\n214\n00:11:35.830 --> 00:11:39.870\nAnd usually, breaking into a subquery\ngives it a little more flexibility.\n\n215\n00:11:39.870 --> 00:11:41.620\nIn this case, it didn't make a difference.\n\n216\n00:11:41.620 --> 00:11:43.970\nNow, it doesn't mean it\nwill always be like that.\n\n217\n00:11:43.970 --> 00:11:47.480\nI might go and create some kind of\nindex later on that facilitates it,\n\n218\n00:11:47.480 --> 00:11:49.350\nand all of a sudden,\nthe subquery is better, right?\n\n219\n00:11:49.350 --> 00:11:52.790\nBut this is why it's important to check,\nbecause sometimes\n\n220\n00:11:52.790 --> 00:11:56.310\nwhether you write it one way or another\ndoesn't necessarily make a difference.\n\n221\n00:11:56.310 --> 00:11:58.410\nAnd when I'm faced with\nthat kind of a decision,\n\n222\n00:11:58.410 --> 00:12:01.260\nI usually pick whichever one is easier,\nright?\n\n223\n00:12:01.260 --> 00:12:03.420\nBecause the easier it is to write a query,\n\n224\n00:12:03.420 --> 00:12:05.780\nthe less likely you are to make a mistake,\nright?\n\n225\n00:12:05.780 --> 00:12:09.230\nSo faced with an example like this where\nthey are both equal, I would look at it\n\n226\n00:12:09.230 --> 00:12:13.910\nand say, well, if I counted letter for\nletter, they're probably the same.\n\n227\n00:12:13.910 --> 00:12:17.497\nThe JOIN is a little more straightforward,\nI think.\n\n228\n00:12:17.497 --> 00:12:20.602\nBecause you're selecting right here,\nyou've got your JOIN statement,\n\n229\n00:12:20.602 --> 00:12:21.647\nit's super cut and dry.\n\n230\n00:12:21.647 --> 00:12:24.927\nThis one up here, you've got a subquery,\nit's got an N statement, so\n\n231\n00:12:24.927 --> 00:12:26.200\nan extra operator.\n\n232\n00:12:26.200 --> 00:12:28.990\nI would probably go with a JOIN\nin this case over the subquery.\n\n233\n00:12:28.990 --> 00:12:32.840\nBut I couldn't get fired for making one\nchoice one way or another on this one.\n\n234\n00:12:32.840 --> 00:12:33.390\n&gt;&gt; It's interesting,\n\n235\n00:12:33.390 --> 00:12:36.580\nbecause I was just sitting here\nthinking I like the subquery\n\n236\n00:12:36.580 --> 00:12:39.080\nbecause it's a little more readable\nto me when I'm looking at it.\n\n237\n00:12:39.080 --> 00:12:41.430\n&gt;&gt; Yeah, there's no aliases.\n\n238\n00:12:41.430 --> 00:12:42.740\nIt would be purely up to you.\n\n239\n00:12:42.740 --> 00:12:46.340\nSo this query is a lot different than\nthe example from the last episode in that,\n\n240\n00:12:46.340 --> 00:12:47.228\none, it's not scalar.\n\n241\n00:12:47.228 --> 00:12:49.730\nThe subquery's returning a table,\ntable value.\n\n242\n00:12:49.730 --> 00:12:52.260\nAnd two, it didn't help us, right?\n\n243\n00:12:52.260 --> 00:12:54.790\nIt's the same as writing a regular query.\n\n244\n00:12:54.790 --> 00:12:56.590\nSo something we always need\nto be on the look out for\n\n245\n00:12:56.590 --> 00:12:58.781\nwhen we're working with these.\n&gt;&gt; All right, Don, so\n\n246\n00:12:58.781 --> 00:13:00.690\nwe have seen where a subquery can benefit.\n\n247\n00:13:00.690 --> 00:13:04.985\nWe've cut that first one execution\ncost in half, which is fantastic.\n\n248\n00:13:04.985 --> 00:13:08.605\nWe've seen where a sub-query\nreally didn't help us at all,\n\n249\n00:13:08.605 --> 00:13:10.843\nit was almost the same as doing a JOIN.\n\n250\n00:13:10.843 --> 00:13:13.930\nIt came down to which\nsyntax do we like better.\n\n251\n00:13:13.930 --> 00:13:16.660\nAre there any times when\na subquery's actually worse\n\n252\n00:13:16.660 --> 00:13:19.950\nthan writing a normal query, or\na join, or doing something like that?\n\n253\n00:13:19.950 --> 00:13:20.990\n&gt;&gt; Yeah, yeah, there can be.\n\n254\n00:13:20.990 --> 00:13:24.100\nI would like to say that there aren't,\nbut there are cases.\n\n255\n00:13:24.100 --> 00:13:26.570\nAnd again, it's why we need to\nevaluate this, and why it was so\n\n256\n00:13:26.570 --> 00:13:27.830\nimportant to me that we did a part two.\n\n257\n00:13:27.830 --> 00:13:29.690\nBecause if you just watched part one,\n\n258\n00:13:29.690 --> 00:13:32.770\nit was Don told me that\nsubqueries are the bee's knees,\n\n259\n00:13:32.770 --> 00:13:34.660\nI'm going to do it everywhere, right?\n&gt;&gt; I can cut everything in half.\n\n260\n00:13:34.660 --> 00:13:38.144\nYeah, why wouldn't I?\n&gt;&gt; If you're not doing subqueries,\n\n261\n00:13:38.144 --> 00:13:39.352\nyour service stinks.\n\n262\n00:13:39.352 --> 00:13:41.370\nAnd that might be true.\n\n263\n00:13:41.370 --> 00:13:43.410\nBut it isn't always, so\nwe need to be on the watch.\n\n264\n00:13:43.410 --> 00:13:45.450\nAnd I want to show you\nguys another example.\n\n265\n00:13:45.450 --> 00:13:47.390\nWe saw table value.\n\n266\n00:13:47.390 --> 00:13:49.260\nWe also saw scalar.\n\n267\n00:13:49.260 --> 00:13:53.259\nThere's a third type of subquery that\nyou'll hear people mention every now and\n\n268\n00:13:53.259 --> 00:13:55.953\nthen that's called a correlated subquery,\nright?\n\n269\n00:13:55.953 --> 00:13:58.687\nIn every example I've shown so far,\n\n270\n00:13:58.687 --> 00:14:04.175\nthe result of the subquery was\nprovided to the parent query, right?\n\n271\n00:14:04.175 --> 00:14:06.085\nSometimes they call them inner and\nouter queries.\n\n272\n00:14:06.085 --> 00:14:08.555\nI don't like that terminology cuz\nit gets confusing with inner and\n\n273\n00:14:08.555 --> 00:14:09.815\nouter JOINs, right?\n\n274\n00:14:09.815 --> 00:14:14.945\nBut technically, inner and\nouter JOINs are subqueries in a sense.\n\n275\n00:14:14.945 --> 00:14:16.922\nBut your inner query would\nbe the subquery, and\n\n276\n00:14:16.922 --> 00:14:18.515\nyour outer query would be the parent.\n\n277\n00:14:19.660 --> 00:14:23.370\nNormally, the inner query, or\nthe subquery, is handing it's results to\n\n278\n00:14:23.370 --> 00:14:26.990\nthe outer query, or the parent, and\nthe parent takes action based on it.\n\n279\n00:14:26.990 --> 00:14:28.780\nWith a correlated subquery,\n\n280\n00:14:28.780 --> 00:14:34.060\nthough, the parent query might actually\nbe feeding data to the subquery.\n\n281\n00:14:34.060 --> 00:14:36.030\nAnd the subquery might be\nfeeding data back, right?\n\n282\n00:14:36.030 --> 00:14:38.280\nThey're correlated to work together.\n\n283\n00:14:38.280 --> 00:14:42.880\nIn every example I've shown so far,\nI could highlight the subquery and\n\n284\n00:14:42.880 --> 00:14:45.820\nrun it by itself, and\nit would run independently.\n\n285\n00:14:45.820 --> 00:14:49.350\nIn a correlated subquery,\nit can't run independently.\n\n286\n00:14:49.350 --> 00:14:53.490\nThere's something in that subquery\nthat comes from the parent.\n\n287\n00:14:53.490 --> 00:14:56.317\nAnd if you run the subquery by itself,\nit's missing that piece and\n\n288\n00:14:56.317 --> 00:14:57.336\nit's broken, right?\n\n289\n00:14:57.336 --> 00:15:00.760\nSo the two are fully dependent,\nversus the queries I've been writing.\n\n290\n00:15:00.760 --> 00:15:05.240\nNow, because they're dependent,\nwhat can the server do?\n\n291\n00:15:05.240 --> 00:15:09.940\nI said that subqueries really benefit\nbecause the server has more pieces\n\n292\n00:15:09.940 --> 00:15:14.040\nthat it can break apart and\noptimize differently if it wants to.\n\n293\n00:15:14.040 --> 00:15:16.830\nIf I write a single query, it just has\nto work with that as a single block,\n\n294\n00:15:16.830 --> 00:15:19.370\nit has less options available to it,\nright?\n\n295\n00:15:19.370 --> 00:15:23.640\nIf I do a correlated subquery, I'm taking\naway some of those options, right?\n\n296\n00:15:23.640 --> 00:15:25.470\nThey do have to work together.\n\n297\n00:15:25.470 --> 00:15:28.930\nNow, there are a few,\nI've seen some textbook\n\n298\n00:15:28.930 --> 00:15:33.560\ncase examples of how you can use this for\ngreat good, right?\n\n299\n00:15:33.560 --> 00:15:36.340\nFor the forces of good and fighting evil.\n\n300\n00:15:36.340 --> 00:15:39.350\nBut I was telling Mike before the show,\nand I'll be honest with you,\n\n301\n00:15:39.350 --> 00:15:40.045\nif you're out there.\n\n302\n00:15:40.045 --> 00:15:43.990\nI've worked with hundreds,\nmaybe thousands, of queries at this point\n\n303\n00:15:43.990 --> 00:15:48.323\nin production environments, and I have\nnever once seen a correlated query that\n\n304\n00:15:48.323 --> 00:15:52.421\nresulted in better performance than\njust writing a single query, right?\n\n305\n00:15:52.421 --> 00:15:57.601\nSo it is a type of subquery that is\neither commonly misunderstood or\n\n306\n00:15:57.601 --> 00:16:00.107\nmisused or just not a great one.\n\n307\n00:16:00.107 --> 00:16:02.996\nSo I wanna show you guys an example\nof that so you can spot it and\n\n308\n00:16:02.996 --> 00:16:04.970\nrecognize what's going on.\n\n309\n00:16:04.970 --> 00:16:09.060\nSo I've got a query here, and\n\n310\n00:16:09.060 --> 00:16:11.530\nthe way I would normally write\nthis is a little more complex.\n\n311\n00:16:11.530 --> 00:16:16.020\nI tried to format it so we can kind\nof make sense of what was going on.\n\n312\n00:16:16.020 --> 00:16:19.370\nIf we look at it,\nI've got a big select statement here.\n\n313\n00:16:19.370 --> 00:16:23.530\nI'm pulling the customerID\nas my first column, and\n\n314\n00:16:23.530 --> 00:16:27.560\nthen I'm pulling some calculated\nvalue as my second column.\n\n315\n00:16:27.560 --> 00:16:30.866\nAnd I'm pulling that from\nthe sales.salescustomer database, and\n\n316\n00:16:30.866 --> 00:16:34.172\ngiving it an a list of c, and\nI'm ordering it by total sales, right?\n\n317\n00:16:34.172 --> 00:16:39.070\nThat subquery is a join, right, so\nit's actually a little more complex,\n\n318\n00:16:39.070 --> 00:16:43.680\nI'm pulling a calculated value,\nthe UnitPrice times the OrderQty.\n\n319\n00:16:43.680 --> 00:16:46.760\nWhat I'm trying to do here is,\n\n320\n00:16:46.760 --> 00:16:52.540\nI'm trying to figure out which customer\nspent the most money with me, right?\n\n321\n00:16:52.540 --> 00:16:56.130\nSo I need the CustomerID, so\nI can tell who the customer is, and\n\n322\n00:16:56.130 --> 00:16:58.380\nthen I need to find out\nhow much money they spent.\n\n323\n00:16:58.380 --> 00:17:01.670\nBut the problem is,\nwe don't store that anywhere.\n\n324\n00:17:01.670 --> 00:17:06.110\nI have my order history, or\nmy SalesOrderDetail table.\n\n325\n00:17:06.110 --> 00:17:08.488\nAnd that has how much each order costs,\nbut\n\n326\n00:17:08.488 --> 00:17:11.078\nit doesn't have a CustomerID\nattached to it.\n\n327\n00:17:11.078 --> 00:17:16.434\nIf I were to look at that table,\nit has the, well, here, I can show you.\n\n328\n00:17:16.434 --> 00:17:20.410\nIf I do a SELECT * FROM SalesOrderDetail,\nso\n\n329\n00:17:20.410 --> 00:17:24.504\nI'm just gonna pull that\nlittle block there.\n\n330\n00:17:24.504 --> 00:17:27.341\nAll right,\nwhen I look at SalesOrderDetail,\n\n331\n00:17:27.341 --> 00:17:32.145\nI have a SalesOrderID number and a\nSalesOrderDetailID and tracking number and\n\n332\n00:17:32.145 --> 00:17:36.604\nso on, all the way over to this UnitPrice,\nand there's OrderQty here.\n\n333\n00:17:36.604 --> 00:17:39.186\nSo if the unit price was $2024,\n\n334\n00:17:39.186 --> 00:17:44.280\nthat has to be multiplied by 3 here\ncuz there's an order quantity of 3.\n\n335\n00:17:44.280 --> 00:17:47.750\nSo that's why I'm multiplying\nUnitPrice times OrderQty,\n\n336\n00:17:47.750 --> 00:17:49.280\nto find out how much they actually spent.\n\n337\n00:17:49.280 --> 00:17:52.648\nI'm not even storing a total value, when\nI say I, this is a sample database from\n\n338\n00:17:52.648 --> 00:17:55.935\nMicrosoft, they chose not to store\nthat total value, for whatever reason.\n\n339\n00:17:55.935 --> 00:18:01.276\nSo I have to calculate it, right,\nwell, then that's just one order.\n\n340\n00:18:01.276 --> 00:18:05.634\nA customer might have spent money on 10,\n20, 100 different orders.\n\n341\n00:18:05.634 --> 00:18:07.539\n&gt;&gt; Hopefully [LAUGH].\n\n342\n00:18:07.539 --> 00:18:08.179\n&gt;&gt; Hopefully, so\n\n343\n00:18:08.179 --> 00:18:10.900\nI'm gonna correlate all these\nwith who the customer was.\n\n344\n00:18:10.900 --> 00:18:12.770\nAnd that's why I'm doing a join here, and\n\n345\n00:18:12.770 --> 00:18:16.810\nI'm doing the join on\nSales.SalesOrderHeader.\n\n346\n00:18:16.810 --> 00:18:21.878\nBecause that table, if I were to\npull from it, if I do a SELECT\n\n347\n00:18:21.878 --> 00:18:27.362\n* FROM Sales.SalesOrderHeader,\n\n348\n00:18:27.362 --> 00:18:30.620\nlike that, and we come and pull it up.\n\n349\n00:18:30.620 --> 00:18:34.295\nIt's got the SalesOrderID that\nwe just saw, got the OrderDate,\n\n350\n00:18:34.295 --> 00:18:35.960\nthe DueDate, ShipDate.\n\n351\n00:18:35.960 --> 00:18:40.299\nAnd somewhere buried in here,\nthere it is, we have the CustomerID,\n\n352\n00:18:40.299 --> 00:18:42.500\nand I can see which customer it was.\n\n353\n00:18:42.500 --> 00:18:46.118\nAnd I may find duplicates in here, cuz\na customer may place more than one order.\n\n354\n00:18:46.118 --> 00:18:49.770\nSo I've gotta do a join to\naggregate that information,\n\n355\n00:18:49.770 --> 00:18:51.870\nto put it all together, right.\n\n356\n00:18:51.870 --> 00:18:55.370\nAnd so that's what's going on\nright here with this join.\n\n357\n00:18:55.370 --> 00:18:59.410\nWe're doing a join on\nSales.SalesOrderHeader so\n\n358\n00:18:59.410 --> 00:19:01.160\nI can figure out who the customer was.\n\n359\n00:19:01.160 --> 00:19:04.310\nAnd combine those order quantities\ntogether to figure exactly\n\n360\n00:19:04.310 --> 00:19:05.620\nhow much they spent.\n\n361\n00:19:05.620 --> 00:19:10.880\nAnd so then I'll have the CustomerID\ncoming from the main query, and\n\n362\n00:19:10.880 --> 00:19:15.300\nI do the join to find that\namount of money they spent.\n\n363\n00:19:15.300 --> 00:19:21.020\nNow, if I ran the subquery just like this,\n\n364\n00:19:21.020 --> 00:19:24.790\nit would actually work,\nit would pull the UnitPrice and OrderQty.\n\n365\n00:19:24.790 --> 00:19:28.530\nIt would run against that order header,\nand it would give me my data.\n\n366\n00:19:28.530 --> 00:19:32.069\nThe problem is, it would actually\ngroup everybody together,\n\n367\n00:19:32.069 --> 00:19:34.282\nit wouldn't break it out by customer.\n\n368\n00:19:34.282 --> 00:19:36.894\nAnd so that's where this\nwhere clause is coming in.\n\n369\n00:19:36.894 --> 00:19:39.789\nWe're breaking it up\nbased on that CustomerID,\n\n370\n00:19:39.789 --> 00:19:43.331\ncuz the join is actually being\nperformed on SalesOrderID.\n\n371\n00:19:43.331 --> 00:19:46.157\nAnd we don't wanna break up on that,\nwe wanna break up on the CustomerID.\n\n372\n00:19:46.157 --> 00:19:48.943\nSo we're using a where clause to fix that,\nand when we do that,\n\n373\n00:19:48.943 --> 00:19:52.220\nnow it breaks it down per customer and\nit gives me the information we want.\n\n374\n00:19:52.220 --> 00:19:56.014\nAnd then we're calling that\na fake column called TotalSales.\n\n375\n00:19:56.014 --> 00:20:00.294\nAnd just the finisher of that\nquery is that it comes through and\n\n376\n00:20:00.294 --> 00:20:02.280\ngenerates the total sales.\n\n377\n00:20:02.280 --> 00:20:09.160\nNow, inside of my subquery,\nI'm referencing c.CustomerID, right?\n\n378\n00:20:09.160 --> 00:20:13.600\nAnd down here, I can see that\nthat is the sales.customer table.\n\n379\n00:20:13.600 --> 00:20:20.240\nBut in the query here, in the subquery,\nI don't actually use c.CustomerID, right?\n\n380\n00:20:20.240 --> 00:20:24.275\nSo if I run the query by itself,\nit's broken, it doesn't work,\n\n381\n00:20:24.275 --> 00:20:26.680\nc.CustomerID doesn't map to anything.\n\n382\n00:20:26.680 --> 00:20:30.440\nThe where clause doesn't work, and\neverything gets lumped together.\n\n383\n00:20:30.440 --> 00:20:32.920\nIf I try to run that,\nI get an error, right?\n\n384\n00:20:32.920 --> 00:20:36.130\nEven if I leave that where\nclause off from the end and\n\n385\n00:20:36.130 --> 00:20:38.490\nI run it that way, it lumps it together.\n\n386\n00:20:38.490 --> 00:20:41.906\nAnd now I know people spent\n$11 million in my company.\n\n387\n00:20:41.906 --> 00:20:42.848\nWell, that's nice to know,\n\n388\n00:20:42.848 --> 00:20:45.270\nright, there's my total sales,\nI didn't have to do crazy joins for that.\n\n389\n00:20:45.270 --> 00:20:47.760\nI could have just totaled up the orders\nand been done with it, right?\n\n390\n00:20:47.760 --> 00:20:51.830\nI need it broken up, and so that's\nwhere this where statement is coming.\n\n391\n00:20:51.830 --> 00:20:54.290\nBut this is what's making\nit a correlated query.\n\n392\n00:20:54.290 --> 00:20:59.620\nI'm requiring information that's\ncoming from the parent query, right?\n\n393\n00:20:59.620 --> 00:21:01.940\nThis can't be broken up and\nrun by itself anymore.\n\n394\n00:21:01.940 --> 00:21:05.676\nIt's gonna be run in the context of\nthe parent query, and when I run it,\n\n395\n00:21:05.676 --> 00:21:06.684\nit works, right?\n\n396\n00:21:06.684 --> 00:21:09.351\nHere's my CustomerIDs, and\nhere's how much they spent with me.\n\n397\n00:21:09.351 --> 00:21:13.644\nThis very first customer spent\n$882,000 with my company,\n\n398\n00:21:13.644 --> 00:21:16.365\nthat's a special customer to me, right?\n\n399\n00:21:16.365 --> 00:21:19.910\nI'm gonna take care of them, in fact,\nall of these 800,000 people.\n\n400\n00:21:19.910 --> 00:21:22.550\nIf we scroll all the way down to the\nbottom, we find the little people we don't\n\n401\n00:21:22.550 --> 00:21:24.554\ncare about,\npeople that didn't spend anything with us.\n\n402\n00:21:24.554 --> 00:21:27.213\nThese are customers that we know about,\nbut they didn't spend money.\n\n403\n00:21:27.213 --> 00:21:32.047\nWe wouldn't want to ignore them, right,\nmaybe they would spend $800,000 if we sent\n\n404\n00:21:32.047 --> 00:21:33.868\nthem a nice letter.\n&gt;&gt; [LAUGH]\n\n405\n00:21:33.868 --> 00:21:35.711\n&gt;&gt; Anyhow, it's all getting kind of broken\n\n406\n00:21:35.711 --> 00:21:38.810\nup and spread out in here, and\nI see that information, right?\n\n407\n00:21:38.810 --> 00:21:42.319\nThere's almost 20,000 rows here, so\nI'm not gonna sift through all of it, but\n\n408\n00:21:42.319 --> 00:21:44.012\nhere's all these different customers.\n\n409\n00:21:44.012 --> 00:21:49.554\nSo that gives me information that I want,\nthe thing about this query, though,\n\n410\n00:21:49.554 --> 00:21:54.920\nbecause it's correlated,\nin this scenario, it's really complex.\n\n411\n00:21:54.920 --> 00:21:58.330\nIt's just a complex query,\nbut it does work, and\n\n412\n00:21:58.330 --> 00:22:00.590\nit gives me the information that I want.\n\n413\n00:22:00.590 --> 00:22:05.000\nIt's table valued in a way, in that\nit's gathering this data together, and\n\n414\n00:22:05.000 --> 00:22:09.390\nthen it's allowing me to break that apart\nby customer, put it here in the table, and\n\n415\n00:22:09.390 --> 00:22:10.090\nI get what I want.\n\n416\n00:22:10.090 --> 00:22:13.025\nSo as far as subqueries are concerned,\nit works, and\n\n417\n00:22:13.025 --> 00:22:14.291\nit does what I want.\n&gt;&gt; But\n\n418\n00:22:14.291 --> 00:22:17.504\nyou did have to bring in that third table\nthen, which makes your query a little\n\n419\n00:22:17.504 --> 00:22:18.694\nmore complex.\n&gt;&gt; And\n\n420\n00:22:18.694 --> 00:22:19.833\nthat's the real challenge here, right?\n\n421\n00:22:19.833 --> 00:22:23.129\nThat third table,\nthis sales.customer coming into the mix,\n\n422\n00:22:23.129 --> 00:22:25.564\nwe're grabbing data from\nall over the place.\n\n423\n00:22:25.564 --> 00:22:28.392\nWhen in reality,\nI just care about UnitPrice and OrderQty,\n\n424\n00:22:28.392 --> 00:22:30.880\nthey're all coming from the same table.\n\n425\n00:22:30.880 --> 00:22:34.169\nThis is bigger than it should be,\nand as I add more tables,\n\n426\n00:22:34.169 --> 00:22:38.481\nit's just gonna get worse and worse if\nI try and add even more things in here.\n\n427\n00:22:38.481 --> 00:22:43.318\nSo my problem here, one, it's a complex\nquery, right, it is a hard query to write.\n\n428\n00:22:43.318 --> 00:22:47.126\nTwo, it's dealing with too many tables,\nit's bringing a whole\n\n429\n00:22:47.126 --> 00:22:51.122\nextra table in just for the purpose\nof breaking it up by CustomerID.\n\n430\n00:22:51.122 --> 00:22:54.610\nAnd CustomerID is already\nstored in SalesOrderHeader,\n\n431\n00:22:54.610 --> 00:22:56.050\na table I'm already working with.\n\n432\n00:22:56.050 --> 00:22:59.400\nBut because of the inner join, I'm using\na where clause to tie them together.\n\n433\n00:22:59.400 --> 00:23:03.154\nAnd that's just not\nthe best way to do this, so\n\n434\n00:23:03.154 --> 00:23:06.343\nthis query is not written the best way.\n\n435\n00:23:06.343 --> 00:23:11.230\nIf I were tasked with writing this, I\nwouldn't have even considered a subquery.\n\n436\n00:23:11.230 --> 00:23:13.820\nIt wouldn't even have popped into\nmy mind to do a subquery on this.\n\n437\n00:23:13.820 --> 00:23:19.711\nI would have said, well, we can just\ndo a join and then do a group by.\n\n438\n00:23:19.711 --> 00:23:23.159\nI can use group by CustomerID and\ngroup it, and then our problem is solved,\n\n439\n00:23:23.159 --> 00:23:25.260\nI can still get the data that I want.\n\n440\n00:23:25.260 --> 00:23:27.950\nSo let's write that query a different way,\nall right.\n\n441\n00:23:27.950 --> 00:23:32.910\nSo I'm gonna come in here and I'll do, and\nactually, I'm gonna cheat a little bit,\n\n442\n00:23:32.910 --> 00:23:38.240\ncuz I just don't wanna type all this,\nand I'm gonna recycle some of this code.\n\n443\n00:23:38.240 --> 00:23:40.000\nI'm gonna keep the other\nquery laying around, though,\n\n444\n00:23:40.000 --> 00:23:42.620\ncuz I wanna be able to\ncompare the results on it.\n\n445\n00:23:42.620 --> 00:23:47.730\nAnd I'm gonna tweak this a little bit,\nI still wanna get the CustomerID.\n\n446\n00:23:47.730 --> 00:23:53.076\nExcept I don't wanna get the CustomerID\nfrom the sales.Customer table, right?\n\n447\n00:23:53.076 --> 00:23:56.113\nI wanna minimize the amount\nof tables I touch, and\n\n448\n00:23:56.113 --> 00:24:01.116\nI know that CustomerID is already in the\nsales order History table or sales order.\n\n449\n00:24:01.116 --> 00:24:01.954\nLet's see.\n\n450\n00:24:01.954 --> 00:24:02.692\nHeader.\n\n451\n00:24:02.692 --> 00:24:04.140\nThere we go.\nSales order, header.\n\n452\n00:24:04.140 --> 00:24:06.600\nSo, I can pull customer ID from that,\nright?\n\n453\n00:24:06.600 --> 00:24:08.500\nSo that's where I'm gonna grab it.\n\n454\n00:24:08.500 --> 00:24:13.049\nAnd then, I want to get the sum of\nunit price times order quantity.\n\n455\n00:24:13.049 --> 00:24:16.460\nWhich I don't need as a subquery.\n\n456\n00:24:16.460 --> 00:24:22.110\nI'm gonna break that out here and just\nuse the sum function to grab it, right?\n\n457\n00:24:22.110 --> 00:24:24.750\nAnd when I was grabbing that a moment\nago I called it total sales.\n\n458\n00:24:24.750 --> 00:24:27.420\nI'll still call it as total sales, right?\n\n459\n00:24:27.420 --> 00:24:30.510\nSo that's all kind of staying the same,\nright?\n\n460\n00:24:30.510 --> 00:24:34.370\nI'm going to pull this from\nsales.salesOrderDetail,\n\n461\n00:24:34.370 --> 00:24:37.070\nand we'll call that SOD, that's fine.\n\n462\n00:24:37.070 --> 00:24:39.840\nWe'll do a inner join\non sales order headers.\n\n463\n00:24:39.840 --> 00:24:41.740\nSo I'm leaving that be.\n\n464\n00:24:41.740 --> 00:24:44.793\nAnd then,\nI'm linking it on sales order ID.\n\n465\n00:24:44.793 --> 00:24:46.900\nIt's the only common element\nbetween those two tables.\n\n466\n00:24:46.900 --> 00:24:49.600\nI don't really have a choice,\nthat's what I have to bind on.\n\n467\n00:24:49.600 --> 00:24:53.800\nNow, because I'm pulling customer\nID from a table I've already got,\n\n468\n00:24:53.800 --> 00:24:55.200\nI can get rid of this wear clause.\n\n469\n00:24:55.200 --> 00:24:56.610\nI don't need it.\n\n470\n00:24:56.610 --> 00:24:59.950\nAnd because I've got rid of the subquery,\nI can get rid of this close and\n\n471\n00:24:59.950 --> 00:25:00.660\nas statement.\n\n472\n00:25:00.660 --> 00:25:03.462\nJust kinda remove those, right,\nget those outta there, right?\n\n473\n00:25:03.462 --> 00:25:07.180\nAnd then, I pull it from, let's see,\n\n474\n00:25:07.180 --> 00:25:10.770\nwell, actually, we've already got a from\nclause, I can get rid of that too.\n\n475\n00:25:10.770 --> 00:25:13.441\nI'll keep the order by so\nthat things look the same.\n\n476\n00:25:13.441 --> 00:25:17.100\nBut I'm gonna replace\nthat from clause there.\n\n477\n00:25:17.100 --> 00:25:21.200\nBecause I had a from for the subquery,\nand then I had a from for\n\n478\n00:25:21.200 --> 00:25:22.400\nthe big query, right?\n\n479\n00:25:22.400 --> 00:25:25.220\nWell, here, this is actually my\nfrom from the big query, right?\n\n480\n00:25:25.220 --> 00:25:26.830\nSo I shouldn't even indent that anymore.\n\n481\n00:25:26.830 --> 00:25:28.370\nLet me just move that back over.\n\n482\n00:25:28.370 --> 00:25:29.700\nThere we go.\n\n483\n00:25:29.700 --> 00:25:31.860\nCuz it's not a subquery anymore, right?\n\n484\n00:25:31.860 --> 00:25:36.000\nThese are my columns that I'm pulling,\nand then I'm pulling from this table,\n\n485\n00:25:36.000 --> 00:25:39.370\nI'm joining with this other table,\nso now it's just a simple join.\n\n486\n00:25:39.370 --> 00:25:42.412\nAnd I'm gonna do a Group By, and\n\n487\n00:25:42.412 --> 00:25:47.946\nI can group by the sales order\nheader customer ID, right?\n\n488\n00:25:47.946 --> 00:25:49.860\nWhich is what I really wanted.\n\n489\n00:25:49.860 --> 00:25:51.990\nAnd with the subquery I had to\ndo it through a crazy join.\n\n490\n00:25:51.990 --> 00:25:55.860\nBut here,\nI can just do it based on the customer ID.\n\n491\n00:25:55.860 --> 00:25:59.670\nIn fact, I might have even been able\nto do a group in that subquery.\n\n492\n00:25:59.670 --> 00:26:03.255\nBut at that point, why even bother with\nthe subquery when I can do it right here\n\n493\n00:26:03.255 --> 00:26:05.810\nin this one query and\nsupposedly get the same results?\n\n494\n00:26:05.810 --> 00:26:09.780\nNow let's run that and see if it\neven works first before we compare.\n\n495\n00:26:09.780 --> 00:26:15.380\nThere we go, and I can see I got\na customer who spent $882,000 with me.\n\n496\n00:26:15.380 --> 00:26:18.991\nAnd lets see if it's right, I'm gonna\nrun this both of these as a batch so\n\n497\n00:26:18.991 --> 00:26:20.865\nthat I can compare the two together.\n\n498\n00:26:20.865 --> 00:26:27.010\nAnd there's a keyboard shortcut to\nhide the query analyzer window,\n\n499\n00:26:27.010 --> 00:26:30.728\nbut I can never remember it cuz\nwhen would you ever do that?\n\n500\n00:26:30.728 --> 00:26:33.972\nI was gonna try and\nhide it really quick, but- [CROSSTALK]\n\n501\n00:26:33.972 --> 00:26:34.650\n&gt;&gt; [LAUGH].\n\n502\n00:26:34.650 --> 00:26:37.193\n&gt;&gt; All right, well, you know what,\n\n503\n00:26:37.193 --> 00:26:40.190\nI'll just address the size of this one.\n\n504\n00:26:40.190 --> 00:26:44.920\nAnd as I look at the results,\ncustomer 1 is 29818, 29818.\n\n505\n00:26:44.920 --> 00:26:46.712\nCustomer 2 is 29722, 29722,\nit's the same results, right?\n\n506\n00:26:46.712 --> 00:26:49.698\nIt got the same information, right?\n\n507\n00:26:49.698 --> 00:26:52.488\nSo if these two queries,\nas far as the results are concerned,\n\n508\n00:26:52.488 --> 00:26:54.760\nare the same.\n&gt;&gt; What about the cost?\n\n509\n00:26:54.760 --> 00:26:55.630\n&gt;&gt; Let's look at the cost.\n\n510\n00:26:55.630 --> 00:26:58.720\nSo let me turn on my execution plan and\nrerun that.\n\n511\n00:26:58.720 --> 00:27:01.450\nAnd now we'll take a look\nat the execution plans.\n\n512\n00:27:01.450 --> 00:27:06.125\nNow when I look at the execution plans,\nat first glance they look to be the same.\n\n513\n00:27:06.125 --> 00:27:08.170\nI'm not seeing a giant difference.\n\n514\n00:27:08.170 --> 00:27:12.480\nBut as I scroll down, now I can see\nthe difference on this branch down here.\n\n515\n00:27:12.480 --> 00:27:14.560\nSee how we've got this hash match?\n\n516\n00:27:14.560 --> 00:27:15.640\nAnd then a merge join,\n\n517\n00:27:15.640 --> 00:27:21.010\nand I've a clustered index seek, and\na compute scalar value here, right?\n\n518\n00:27:21.010 --> 00:27:28.450\nBut down here, instead of having\nthe hash match and the merge join,\n\n519\n00:27:28.450 --> 00:27:32.620\ndown here I just have compute scalar and\na clustered index hit, right?\n\n520\n00:27:32.620 --> 00:27:34.120\nIt's far less steps.\n\n521\n00:27:34.120 --> 00:27:35.800\nUp here, I had a bunch.\n\n522\n00:27:35.800 --> 00:27:40.080\nNow, if I look I've got 19% of my cost,\n8% of my cost, 12% of my cost.\n\n523\n00:27:41.140 --> 00:27:43.921\nIf I add that up, that's like 39%, right?\n\n524\n00:27:43.921 --> 00:27:47.470\nIf I look down here,\nthis whole bottom tree is 26%.\n\n525\n00:27:47.470 --> 00:27:49.950\nIt's a smaller percentage\nof the overall query.\n\n526\n00:27:49.950 --> 00:27:50.730\nBut remember,\n\n527\n00:27:50.730 --> 00:27:54.240\ndon't act just on percentages cuz we\nneed to know the total number, right?\n\n528\n00:27:54.240 --> 00:27:56.330\nSo let's look at that total number.\n\n529\n00:27:56.330 --> 00:28:01.220\nThe sub-tree cost for the query with\na sub-query, I've got 4.49, right?\n\n530\n00:28:01.220 --> 00:28:02.782\nPretty big number, but\n\n531\n00:28:02.782 --> 00:28:07.510\nis was a pretty complex query that\nreached a multiple tables 4.49.\n\n532\n00:28:07.510 --> 00:28:11.683\nIf I look at the other one,\nit's cost 4.07, okay?\n\n533\n00:28:11.683 --> 00:28:18.932\nNow, that's not the huge improvement\nover subqueries that we saw in part one.\n\n534\n00:28:18.932 --> 00:28:23.050\nHere, it's a slight improvement,\nright, of what would be,\n\n535\n00:28:23.050 --> 00:28:26.870\nI don't know, like a 12%,\n12.5% improvement?\n\n536\n00:28:26.870 --> 00:28:28.832\nSo not 50%, which was glorious, right?\n\n537\n00:28:28.832 --> 00:28:34.285\nBut ti was something much, much,\nactually, it's not even 12.5%, is it?\n\n538\n00:28:34.285 --> 00:28:38.890\nIt's more like 8%,\nit's a small percentage gain.\n\n539\n00:28:38.890 --> 00:28:41.620\nBut it is a gain.\nAnd the more often you run this\n\n540\n00:28:41.620 --> 00:28:45.960\nparticular query, the more often\nyou'll benefit from that gain.\n\n541\n00:28:45.960 --> 00:28:50.500\nAnd the part that I wanted to highlight\nhere was that the gain was not from using\n\n542\n00:28:50.500 --> 00:28:54.300\na sub query, the gain was from\nnot using a subquery, right?\n\n543\n00:28:54.300 --> 00:28:57.560\nSometimes, subqueries are not a good idea.\n\n544\n00:28:57.560 --> 00:29:02.455\nAnd so for this show, when I was trying to\nthink of how can I write a bad subquery?\n\n545\n00:29:02.455 --> 00:29:05.690\n[LAUGH] It's actually kind of hard\nsometimes to think of an example of\n\n546\n00:29:05.690 --> 00:29:06.600\nsomething bad.\n\n547\n00:29:06.600 --> 00:29:07.190\nAnd I said,\n\n548\n00:29:07.190 --> 00:29:11.660\nI know, I'll just show a normal query\nthat I know is almost always bad.\n\n549\n00:29:11.660 --> 00:29:13.800\nAnd that's a correlated query.\n\n550\n00:29:13.800 --> 00:29:17.090\nThis example from the correlated\nquery that I've got is actually from\n\n551\n00:29:17.090 --> 00:29:20.180\nthe Microsoft Transact-SQL documentation.\n\n552\n00:29:20.180 --> 00:29:23.190\nThis is their example of how\nto do a correlated query.\n\n553\n00:29:23.190 --> 00:29:26.650\nAnd it is a correlated query,\nit's just not a good one, right?\n\n554\n00:29:26.650 --> 00:29:31.610\nAnd it highlights how you can find\na better way to do a lot of things.\n\n555\n00:29:31.610 --> 00:29:36.080\nSo with subqueries, first off, try and\nstay away from correlated queries.\n\n556\n00:29:36.080 --> 00:29:40.940\nThe more independent these clauses are,\nif you're able to run your subquery by\n\n557\n00:29:40.940 --> 00:29:45.840\nitself, that means it's more powerful,\nthat the server has more options.\n\n558\n00:29:45.840 --> 00:29:49.410\nIf you can't run the query by itself,\nthat's an indicator that the server has\n\n559\n00:29:49.410 --> 00:29:53.630\nless options and you're probably not\nwriting an optimized query, right?\n\n560\n00:29:53.630 --> 00:29:57.694\nI'm gonna say probably because I've seen\nsome textbook examples where it actually\n\n561\n00:29:57.694 --> 00:30:00.513\nwas better, I just haven't\nseen it in real life, right?\n\n562\n00:30:00.513 --> 00:30:01.481\nSo somebody out there\nsomewhere thinks it's\n\n563\n00:30:01.481 --> 00:30:02.122\nawesome, it works great.\n&gt;&gt; [LAUGH]\n\n564\n00:30:02.122 --> 00:30:04.014\n&gt;&gt; It's just not me.\n\n565\n00:30:04.014 --> 00:30:08.209\nBut then, as far as the other queries go,\nyou do see that improvement, and\n\n566\n00:30:08.209 --> 00:30:10.730\nyou actually see it pretty often.\n\n567\n00:30:10.730 --> 00:30:12.690\nOr it's a wash,\nwhere there's no difference.\n\n568\n00:30:12.690 --> 00:30:14.180\nSo we just need to evaluate it.\n\n569\n00:30:14.180 --> 00:30:15.690\nThe first time you write a query,\n\n570\n00:30:15.690 --> 00:30:17.830\nyour focus is probably just\non getting the right data.\n\n571\n00:30:17.830 --> 00:30:20.430\nHow do I get the data\nthat I'm looking for?\n\n572\n00:30:20.430 --> 00:30:22.140\nBut later on, take some time.\n\n573\n00:30:22.140 --> 00:30:25.860\nLook at it and say wasn't there\nanother way I could've done this?\n\n574\n00:30:25.860 --> 00:30:27.110\nCould I have broken it into subqueries?\n\n575\n00:30:27.110 --> 00:30:27.870\nWould it have been better?\n\n576\n00:30:27.870 --> 00:30:29.640\nLet me try, right?\n\n577\n00:30:29.640 --> 00:30:30.960\nWhen you're working your deadline, sure.\n\n578\n00:30:30.960 --> 00:30:33.430\nYou just just have to get\nsomething done as well as you can.\n\n579\n00:30:33.430 --> 00:30:38.360\nBut once you're past that point,\nI'm saying something silly here which is,\n\n580\n00:30:38.360 --> 00:30:39.270\nwhen you're bored,\n&gt;&gt; [LAUGH]\n\n581\n00:30:39.270 --> 00:30:39.950\n&gt;&gt; You're sitting at your\n\n582\n00:30:39.950 --> 00:30:41.280\ndesk with nothing to do, right?\n\n583\n00:30:41.280 --> 00:30:43.941\nCuz that happens to us.\n&gt;&gt; That happens all the time, yeah.\n\n584\n00:30:43.941 --> 00:30:46.160\n[LAUGH]\n&gt;&gt; So if that happens, though, or\n\n585\n00:30:46.160 --> 00:30:49.061\nset aside some time and say,\nall right, once a month,\n\n586\n00:30:49.061 --> 00:30:52.450\nI'm going to look at the ten\nmost expensive quarries.\n\n587\n00:30:52.450 --> 00:30:53.840\nWhoever is the database administrator for\n\n588\n00:30:53.840 --> 00:30:56.800\nyour server, they can actually\npull an expensive query report.\n\n589\n00:30:56.800 --> 00:30:58.630\nThat's actually what it's called.\n\n590\n00:30:58.630 --> 00:31:02.195\nAnd they can show you which queries\nconsume the most resources on the server,\n\n591\n00:31:02.195 --> 00:31:02.890\nright?\n\n592\n00:31:02.890 --> 00:31:04.970\nOr which ones run the most frequently.\n\n593\n00:31:04.970 --> 00:31:06.380\nThey can show that to you.\n\n594\n00:31:06.380 --> 00:31:07.870\nAnd you can take it and\nlook at those tens.\n\n595\n00:31:07.870 --> 00:31:11.480\nLook at the top ten and\nsay can I make any of those better?\n\n596\n00:31:11.480 --> 00:31:12.630\nAnd experiment around with it.\n\n597\n00:31:12.630 --> 00:31:14.000\nTry them three, four, different ways.\n\n598\n00:31:14.000 --> 00:31:16.590\nCuz you'll find there's many\ndifferent ways to get the same data.\n\n599\n00:31:16.590 --> 00:31:18.990\nMaybe breaking them into\nsubqueries solves the problem.\n\n600\n00:31:18.990 --> 00:31:21.250\nMaybe taking away a subquery\nsolves the problem.\n\n601\n00:31:21.250 --> 00:31:24.812\nMaybe doing a group by versus\na join with a statement.\n\n602\n00:31:24.812 --> 00:31:26.420\nThere's different ways to achieve it.\n\n603\n00:31:26.420 --> 00:31:27.790\nSome might be better than others.\n\n604\n00:31:27.790 --> 00:31:31.470\nAnd unfortunately, I can't tell you,\nyeah, this one way is better,\n\n605\n00:31:31.470 --> 00:31:32.720\ndo it this way, right?\n\n606\n00:31:32.720 --> 00:31:35.270\nBecause it also varies\nbased on your data set.\n\n607\n00:31:35.270 --> 00:31:41.220\nIf you have 20 rows, one query might\nwork really well versus another.\n\n608\n00:31:41.220 --> 00:31:43.870\nBut if you have 10,000 rows,\nor 10 million rows,\n\n609\n00:31:43.870 --> 00:31:46.540\nthe bad query from before might actually\nbe the better query now, right?\n\n610\n00:31:46.540 --> 00:31:49.900\nThe more data you have, or\nlet's say it's the same set of data.\n\n611\n00:31:49.900 --> 00:31:55.444\nIf you have normalized data\nthat has a lot of duplicates,\n\n612\n00:31:55.444 --> 00:31:58.571\nthen that query might run fast.\n\n613\n00:31:58.571 --> 00:32:03.567\nBut if somebody has denormalized data,\nthat's a mess, well,\n\n614\n00:32:03.567 --> 00:32:05.790\nit might not run so well.\n\n615\n00:32:05.790 --> 00:32:09.310\nSo, you've gotta try it against\nyour own data and see, and\n\n616\n00:32:09.310 --> 00:32:10.980\ndetermine which one works best.\n\n617\n00:32:10.980 --> 00:32:12.350\nAnd it may even change over time.\n\n618\n00:32:12.350 --> 00:32:16.110\nThe way you've written a query\ntoday might be the best way.\n\n619\n00:32:16.110 --> 00:32:19.500\nBut, three years from now when your\ndata base has grown and fragmented and\n\n620\n00:32:19.500 --> 00:32:21.950\nchanged, it may not be\nthe best way anymore.\n\n621\n00:32:21.950 --> 00:32:25.320\nAnd so, that's all the challenge\nthat a database administrator has.\n\n622\n00:32:25.320 --> 00:32:28.598\nAnd as somebody writing transact SQLs,\nthe challenge hat you have,\n\n623\n00:32:28.598 --> 00:32:30.816\nrecognize there's more\nthan one way to do it.\n\n624\n00:32:30.816 --> 00:32:33.829\nAnd what I usually do is if I\nfigure out the more than one way,\n\n625\n00:32:33.829 --> 00:32:36.560\nI document them with why I\nchose one way over another.\n\n626\n00:32:36.560 --> 00:32:40.510\nSo that my second challenge of making sure\nI'm running things the best, when I go and\n\n627\n00:32:40.510 --> 00:32:42.270\nevaluate it in the future,\n\n628\n00:32:42.270 --> 00:32:44.900\nI've already documented the three\nother ways I could have done it.\n\n629\n00:32:44.900 --> 00:32:47.430\nSo let me just run those three ways and\ncompare the execution list.\n\n630\n00:32:47.430 --> 00:32:49.820\nIt's easy enough and\nnow you kind of spot it and go forward.\n\n631\n00:32:49.820 --> 00:32:54.145\nSo that's how we leverage\nsubqueries to achieve world peace.\n\n632\n00:32:54.145 --> 00:32:55.710\n&gt;&gt; [LAUGH] Fantastic, Don.\n\n633\n00:32:55.710 --> 00:32:57.280\nHopefully we can get\nworld peace out of that.\n\n634\n00:32:57.280 --> 00:33:00.430\nBut if not, hey,\nwe got a great look at subqueries.\n\n635\n00:33:00.430 --> 00:33:05.790\nWe looked at scalar subqueries,\ntabular subqueries, correlated subqueries,\n\n636\n00:33:05.790 --> 00:33:09.300\nand really good examples of when\nsometimes they really do benefit us.\n\n637\n00:33:09.300 --> 00:33:12.370\nSometimes it's kind of a wash and\nwe're looking more at maybe which\n\n638\n00:33:12.370 --> 00:33:13.810\none we like better.\n&gt;&gt; [LAUGH]\n\n639\n00:33:13.810 --> 00:33:15.720\n&gt;&gt; Sometimes, they don't help us.\n\n640\n00:33:15.720 --> 00:33:17.660\nThey might even slow things down.\n\n641\n00:33:17.660 --> 00:33:20.260\nBut as Don pointed out, it's one of\nthose things where's no absolute.\n\n642\n00:33:20.260 --> 00:33:23.630\nIt's something that you're gonna have\nto look at using your data sets and\n\n643\n00:33:23.630 --> 00:33:26.380\nyour results, and\nsee which one works best for you.\n\n644\n00:33:26.380 --> 00:33:27.770\nBut hey, now you've got the options.\n\n645\n00:33:27.770 --> 00:33:31.770\nSo I hope everybody out there enjoyed\nwatching this episode and the part one.\n\n646\n00:33:31.770 --> 00:33:32.900\nMake sure you go back and check that out.\n\n647\n00:33:32.900 --> 00:33:36.520\nFor now, signing off for ITPRO.TV I've\nbeen your host, Mike Roderick.\n\n648\n00:33:36.520 --> 00:33:37.320\n&gt;&gt; And I'm Don Pezet.\n\n649\n00:33:37.320 --> 00:33:38.130\n&gt;&gt; And we'll see you next time.\n\n650\n00:33:38.130 --> 00:33:44.800\n[MUSIC]\n\n651\n00:33:44.800 --> 00:33:47.867\n&gt;&gt; Thank you for watching ITProTV.\n\n",
          "vimeoId": "250289455"
        },
        {
          "description": "In this episode, Don expands on methods by which we can group query results in Transact-SQL. He begins by demonstrating the limitations of the GROUP BY command. He then shows to we can use GROUPING SETS, CUBE and ROLLUP to provide more advanced aggregation of our results.",
          "length": "1642",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-2-1-grouping_sets_and_cubes-011118-PGM.00_27_09_27.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-2-1-grouping_sets_and_cubes-011118-PGM.00_27_09_27.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-2-1-grouping_sets_and_cubes-011118-PGM.00_27_09_27.Still001-sm.jpg",
          "title": "Grouping Sets and Cubes",
          "transcript": "",
          "vimeoId": "250854580"
        },
        {
          "description": "In this episode, Don expands on methods by which we can group query results in Transact-SQL. He begins by demonstrating the limitations of the GROUP BY command. He then shows to we can use GROUPING SETS, CUBE and ROLLUP to provide more advanced aggregation of our results.",
          "length": "1479",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-2-2-grouping_sets_and_cubes_pt2-011218-PGM.00_30_30_13.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-2-2-grouping_sets_and_cubes_pt2-011218-PGM.00_30_30_13.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-2-2-grouping_sets_and_cubes_pt2-011218-PGM.00_30_30_13.Still001-sm.jpg",
          "title": "Grouping Sets and Cubes Part 2",
          "transcript": "",
          "vimeoId": "251172879"
        },
        {
          "description": "In this episode, Don introduces the viewers to four methods to rank results in Transact-SQL. He explains the different scenarios where ranking data is useful and then demonstrates using RANK, DENSE_RANK, NTILE and ROW_NUMBER to provide ranking data in our desired form.",
          "length": "1554",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-3-1-ranking_data_with_windows_functions-011618-PGM.00_25_40_22.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-3-1-ranking_data_with_windows_functions-011618-PGM.00_25_40_22.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-3-1-ranking_data_with_windows_functions-011618-PGM.00_25_40_22.Still001-sm.jpg",
          "title": "Ranking Data with Window Functions",
          "transcript": "",
          "vimeoId": "251542493"
        },
        {
          "description": "In this episode, Don introduces the viewers to four methods to rank results in Transact-SQL. He explains the different scenarios where ranking data is useful and then demonstrates using RANK, DENSE_RANK, NTILE and ROW_NUMBER to provide ranking data in our desired form.",
          "length": "1392",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-3-2-ranking_data_with_window_functions_pt2-011618-PGM.00_22_59_13.Still002.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-3-2-ranking_data_with_window_functions_pt2-011618-PGM.00_22_59_13.Still002-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-3-2-ranking_data_with_window_functions_pt2-011618-PGM.00_22_59_13.Still002-sm.jpg",
          "title": "Ranking Data with Window Functions Part 2",
          "transcript": "",
          "vimeoId": "251541684"
        },
        {
          "description": "In this episode, Don highlights a common problem with SQL tables where data is arranged in a form that is not useful for our needs. He then demonstrates how we can alter the arrangement of table data in RAM using the PIVOT and UNPIVOT commands to achieve our desired results.",
          "length": "1957",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-4-1-pivot_and_unpivot_data-011618-still.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-4-1-pivot_and_unpivot_data-011618-still-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-4-1-pivot_and_unpivot_data-011618-still-sm.jpg",
          "title": "Pivot and Unpivot Data",
          "transcript": "",
          "vimeoId": "251543554"
        },
        {
          "description": "In this episode, Don explains how we can use functions to create on-demand views of existing table data. He then highlights a common error when using functions that return a table in our queries. Finally, he demonstrates how to use APPLY to overcome that error so that we can properly leverage our custom functions.",
          "length": "1859",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-5-1-table_expressions_and_apply-011818-PGM.00_32_28_16.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-5-1-table_expressions_and_apply-011818-PGM.00_32_28_16.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-6-5-1-table_expressions_and_apply-011818-PGM.00_32_28_16.Still001-sm.jpg",
          "title": "Table Expressions and Apply",
          "transcript": "WEBVTT\n\n1\n00:00:00.059 --> 00:00:01.348\nWelcome to ITPro.TV.\n\n2\n00:00:01.348 --> 00:00:02.931\nI'm your host, Don Pezet.\n\n3\n00:00:02.931 --> 00:00:07.090\n[CROSSTALK]\n\n4\n00:00:07.090 --> 00:00:08.393\n[MUSIC]\n\n5\n00:00:08.393 --> 00:00:13.248\n&gt;&gt; You're watching ITPro.TV.\n&gt;&gt; Hello, and thank you for\n\n6\n00:00:13.248 --> 00:00:16.740\nchoosing ITPro.TV,\nhelping you learn wherever you go.\n\n7\n00:00:16.740 --> 00:00:17.630\nI'm your host, Zach Memos,\n\n8\n00:00:17.630 --> 00:00:22.890\nas we continue on with we're reading data\nwith Transact SQL, Table Expressions and\n\n9\n00:00:22.890 --> 00:00:27.220\nApplies is the title of this episode and\nDon Pezet is here to show us the way.\n\n10\n00:00:27.220 --> 00:00:29.660\nDon, great to have you.\n&gt;&gt; And great to be back and\n\n11\n00:00:29.660 --> 00:00:32.360\ncontinuing our journey in the work\nof Microsoft's Transact SQL.\n\n12\n00:00:32.360 --> 00:00:33.260\nAnd in this episode,\n\n13\n00:00:33.260 --> 00:00:36.410\nwe're going to take a look at really\nwe're going to look at apply.\n\n14\n00:00:36.410 --> 00:00:38.410\nApply is the star of this episode.\n\n15\n00:00:38.410 --> 00:00:41.380\nBut I can't really talk about apply\nwithout talking about common table\n\n16\n00:00:41.380 --> 00:00:43.660\nexpressions, or CTEs, at the same time.\n\n17\n00:00:43.660 --> 00:00:44.970\nSo we're gonna group them all together and\n\n18\n00:00:44.970 --> 00:00:47.880\nget a chance to see that common\ntable expressions, if you're not\n\n19\n00:00:47.880 --> 00:00:51.380\nfamiliar with that, these are just\nfunctions that we use to represent tables.\n\n20\n00:00:51.380 --> 00:00:53.800\nWe actually talked about them\nback in the function episode.\n\n21\n00:00:53.800 --> 00:00:57.820\nAnd apply, if you've never heard of it,\nis very similar to a join.\n\n22\n00:00:57.820 --> 00:01:00.880\nIt's a way that I can take data\nfrom two different tables and\n\n23\n00:01:00.880 --> 00:01:04.720\nkind of combine it together to\nrepresent a single set of information.\n\n24\n00:01:04.720 --> 00:01:08.440\nSo we're gonna get a chance to see\nwhat apply does, how it works,\n\n25\n00:01:08.440 --> 00:01:09.400\nwhy we would use it.\n\n26\n00:01:09.400 --> 00:01:13.180\nAll of that right here in this episode.\n&gt;&gt; Don, if apply is similar to join then\n\n27\n00:01:13.180 --> 00:01:16.670\nwhy not just use join?\n&gt;&gt; Valid question, right.\n\n28\n00:01:16.670 --> 00:01:20.750\nThere's a lot of technologies that we talk\nabout in the series that seems similar\n\n29\n00:01:20.750 --> 00:01:23.330\nlike in the ranking episode.\n\n30\n00:01:23.330 --> 00:01:27.140\nYou got order buy or sorts which\nRanking is really very similar.\n\n31\n00:01:27.140 --> 00:01:28.410\nSo which one do you pick?\n\n32\n00:01:28.410 --> 00:01:29.450\nSame thing happens here.\n\n33\n00:01:29.450 --> 00:01:34.480\nApply and join are actually very\nsimilar and nine times outta ten,\n\n34\n00:01:34.480 --> 00:01:38.180\nmaybe 99 times out of 100,\nI don't know, you're gonna use join.\n\n35\n00:01:38.180 --> 00:01:39.380\nJoin is the way to go.\n\n36\n00:01:39.380 --> 00:01:44.330\nSo in the transact-SQL basics at the\nbeginning of this series we covered joins.\n\n37\n00:01:44.330 --> 00:01:46.000\nWe didn't even mention applies.\n\n38\n00:01:46.000 --> 00:01:49.030\nSame applies here for advanced, right.\n\n39\n00:01:49.030 --> 00:01:51.720\nAnd the reason is applies\nare really designed for\n\n40\n00:01:51.720 --> 00:01:54.630\none particular scenario that\nyou may never encounter.\n\n41\n00:01:54.630 --> 00:01:57.190\nBut if you do, you will need applies.\n\n42\n00:01:57.190 --> 00:02:00.700\nSo when you do a join,\na join is made up of two parts, right.\n\n43\n00:02:00.700 --> 00:02:03.110\nYou've got a left table and a right table,\n\n44\n00:02:03.110 --> 00:02:06.180\nand when you're doing inner joins you\ndon't really worry about that so much.\n\n45\n00:02:06.180 --> 00:02:09.100\nBut when you're doing outer joins,\nyou've got left outer joins and\n\n46\n00:02:09.100 --> 00:02:10.990\nright outer joins and full outer joins and\n\n47\n00:02:10.990 --> 00:02:14.030\nnow you're really thinking about\nthis whole left and right idea.\n\n48\n00:02:14.030 --> 00:02:18.440\nWell, those two tables that you're pulling\ndata from are technically independent.\n\n49\n00:02:18.440 --> 00:02:21.470\nWell, I guess you could be doing\na self join against the same table but\n\n50\n00:02:21.470 --> 00:02:24.980\nSQL treats them as two different tables,\ntwo independent tables.\n\n51\n00:02:24.980 --> 00:02:26.410\nAnd then it works out the data.\n\n52\n00:02:26.410 --> 00:02:28.440\nIt grabs data from one,\nit grabs data from the other.\n\n53\n00:02:28.440 --> 00:02:32.320\nIt does the comparison, merges them\ntogether and you end up with your join.\n\n54\n00:02:33.930 --> 00:02:39.630\nBut, when we start to leverage something\nlike a common table expression,\n\n55\n00:02:39.630 --> 00:02:41.430\nthings get a little bit weird.\n\n56\n00:02:42.430 --> 00:02:43.540\nWith a common table expression,\n\n57\n00:02:43.540 --> 00:02:46.820\ninstead of joining to a table\nwe're joining to a function.\n\n58\n00:02:46.820 --> 00:02:50.350\nAnd that function is\ngenerating a table for us, and\n\n59\n00:02:50.350 --> 00:02:52.710\nthat's being done kind of in real-time.\n\n60\n00:02:52.710 --> 00:02:58.140\nAnd when we do that, there are certain\nscenarios where it breaks the join.\n\n61\n00:02:58.140 --> 00:03:01.030\nAll of a sudden,\nthe join doesn't work, right.\n\n62\n00:03:01.030 --> 00:03:02.710\nSo that causes a bit of a problem.\n\n63\n00:03:02.710 --> 00:03:04.780\nNow, when we look at a normal join,\nactually,\n\n64\n00:03:04.780 --> 00:03:06.520\nI've got an example here of a normal join.\n\n65\n00:03:06.520 --> 00:03:09.260\nAnd this is from a previous episode.\n\n66\n00:03:09.260 --> 00:03:13.300\nThis is actually a triple-join,\nI'm joining three different tables.\n\n67\n00:03:13.300 --> 00:03:17.480\nSo what I wanted, here, I'll run it,\nand then I'll show you what I wanted.\n\n68\n00:03:17.480 --> 00:03:20.360\nWhat I wanted in whatever\nepisode this was,\n\n69\n00:03:20.360 --> 00:03:23.010\nI wanted to get a lot of\nall of my salespeople.\n\n70\n00:03:23.010 --> 00:03:26.460\nAnd I wanted to know the salesperson's\nfirst name and last name.\n\n71\n00:03:26.460 --> 00:03:29.750\nAnd I wanted to know\nthe region they were in.\n\n72\n00:03:29.750 --> 00:03:33.090\nWell, I've got a table called\nSales.SalesPerson, and\n\n73\n00:03:33.090 --> 00:03:36.290\nit's got all of my salespeople in it,\nsort of.\n\n74\n00:03:36.290 --> 00:03:38.160\nIt's got their business entity ID.\n\n75\n00:03:38.160 --> 00:03:39.530\nIt doesn't have their first name and\n\n76\n00:03:39.530 --> 00:03:43.260\nlast name,\nthat's found in the Person.Person table.\n\n77\n00:03:43.260 --> 00:03:44.926\nThat's where I have to go to\nget first name and last name.\n\n78\n00:03:44.926 --> 00:03:49.670\nAnd while Sales.SalesPerson has\nthe territory ID, it doesn't have\n\n79\n00:03:49.670 --> 00:03:54.250\nthe name of the territory ID, I've got\nto get that from Sales.SalesTerritory.\n\n80\n00:03:54.250 --> 00:03:58.870\nSo my data is spread across tables and\nI'm doing it join here to create that.\n\n81\n00:03:58.870 --> 00:04:01.720\nNow the join is actually\nmade up of two parts.\n\n82\n00:04:01.720 --> 00:04:06.400\nWell, each join is made up of two but then\nmy query is made up of two separate joins.\n\n83\n00:04:06.400 --> 00:04:09.447\nOne, I'm combining Sale.SalesPerson and\n\n84\n00:04:09.447 --> 00:04:14.430\nPerson.Person and two,\nI'm combining Sales.Salesperson\n\n85\n00:04:14.430 --> 00:04:17.390\nwith Sales.SalesTerritory.\n&gt;&gt; Hm.\n\n86\n00:04:17.390 --> 00:04:18.890\n&gt;&gt; To be able to link those\n\n87\n00:04:18.890 --> 00:04:20.600\ntogether, as well.\n\n88\n00:04:20.600 --> 00:04:22.650\nSo kind of two different steps here.\n\n89\n00:04:22.650 --> 00:04:28.000\nBut in each of these,\nI am joining to actual tables, right.\n\n90\n00:04:28.000 --> 00:04:29.090\nAnd so I can run this.\n\n91\n00:04:29.090 --> 00:04:30.380\nI can do ware statements on it.\n\n92\n00:04:30.380 --> 00:04:32.920\nI can do all sorts of craziness to it,\nand it's going to run.\n\n93\n00:04:32.920 --> 00:04:33.810\nIt's going to work just fine.\n\n94\n00:04:33.810 --> 00:04:35.920\nThis is exactly what\nwe've seen in previous\n\n95\n00:04:35.920 --> 00:04:37.150\nshows.\n&gt;&gt; Right.\n\n96\n00:04:37.150 --> 00:04:40.430\n&gt;&gt; But if I were to decide that I wanted\n\n97\n00:04:40.430 --> 00:04:42.110\nto simplify this.\n\n98\n00:04:42.110 --> 00:04:47.280\nRight, if you've watched most of these\nepisodes, you've seen me join sales\n\n99\n00:04:47.280 --> 00:04:51.220\ndot salesperson and person dot person.\n&gt;&gt; We have done that more than\n\n100\n00:04:51.220 --> 00:04:52.280\na few times, haven't we?\n\n101\n00:04:52.280 --> 00:04:53.610\nI mean, my goodness.\n&gt;&gt; Yeah,\n\n102\n00:04:53.610 --> 00:04:55.990\nyeah, probably in half our episodes.\n\n103\n00:04:55.990 --> 00:04:58.240\nI'm always joining these,\nthese are easy tables to join,\n\n104\n00:04:58.240 --> 00:04:59.510\nit's a great example, right?\n\n105\n00:04:59.510 --> 00:05:02.080\nSo maybe I finally break, I snap,\nand I'm like, that's it, I am so\n\n106\n00:05:02.080 --> 00:05:04.590\nsick and tired of joining this thing.\n&gt;&gt; [LAUGH]\n\n107\n00:05:04.590 --> 00:05:05.300\n&gt;&gt; Let's go ahead and\n\n108\n00:05:05.300 --> 00:05:06.620\nwrite a function for it.\n\n109\n00:05:06.620 --> 00:05:10.510\nAnd for now on I can just call\nthe function, and save myself some time.\n\n110\n00:05:10.510 --> 00:05:13.650\nWell, if I do that, if I start to\nconvert part of this to a function,\n\n111\n00:05:13.650 --> 00:05:18.190\nlike this first join, I could then go and\nsay okay, now that's a function.\n\n112\n00:05:18.190 --> 00:05:22.050\nSo instead of having to join\nthree tables I could just join\n\n113\n00:05:22.050 --> 00:05:26.750\nthe sales.sales.territory\ntable with my function and\n\n114\n00:05:26.750 --> 00:05:28.130\ncombine it and get the information.\n\n115\n00:05:28.130 --> 00:05:32.460\nBut now that I'm doing that, that function\nbecomes a common table expression.\n\n116\n00:05:32.460 --> 00:05:35.630\nIt is a kind of version\n\n117\n00:05:35.630 --> 00:05:39.900\nof the data that I've got being expressed\nin a different way through this function.\n\n118\n00:05:39.900 --> 00:05:45.020\nAnd now I'm exposed to the little\npossible scenario where\n\n119\n00:05:45.020 --> 00:05:48.170\nmy join might break if I\nstart to use a function.\n\n120\n00:05:48.170 --> 00:05:52.620\nSo that's kind of what we need to be aware\nof as we go through what we planned and\n\n121\n00:05:52.620 --> 00:05:54.080\nwe designed.\n&gt;&gt; Well then,\n\n122\n00:05:54.080 --> 00:05:58.090\nshould we not use a function?\n&gt;&gt; We certainly don't have to, right?\n\n123\n00:05:58.090 --> 00:05:59.400\nI could say, I'll suffer.\n\n124\n00:05:59.400 --> 00:06:00.010\nI'll just keep doing it.\n\n125\n00:06:00.010 --> 00:06:01.460\nIt's copy and paste work.\n\n126\n00:06:01.460 --> 00:06:03.110\nIt's not the end of the world, right?\n\n127\n00:06:03.110 --> 00:06:06.695\nBut you hate to give up on\nsomething just because there's this\n\n128\n00:06:06.695 --> 00:06:09.310\npossibility of a problem.\n\n129\n00:06:09.310 --> 00:06:12.840\nIn fact, most of the time\nthe functions that you write aren't\n\n130\n00:06:12.840 --> 00:06:15.630\ngoing to cause a problem at all,\nright, and it's going to work.\n\n131\n00:06:15.630 --> 00:06:17.040\nSo let me show you that.\n\n132\n00:06:17.040 --> 00:06:19.660\nWe'll show you one that works, before we\n\n133\n00:06:19.660 --> 00:06:21.170\nstart talking about how to fix it.\n&gt;&gt; Okay.\n\n134\n00:06:21.170 --> 00:06:22.500\n&gt;&gt; So let's say that\n\n135\n00:06:22.500 --> 00:06:23.300\nI decide I want to do that.\n\n136\n00:06:23.300 --> 00:06:26.370\nI want to take the sales.salesperson and\nperson.person join, and\n\n137\n00:06:26.370 --> 00:06:28.670\nI want to make a function that does that.\n\n138\n00:06:28.670 --> 00:06:32.500\nSo in order to do that,\nfirst off I need to create the function.\n\n139\n00:06:32.500 --> 00:06:36.790\nSo let me fire up a new query window\nhere so I can move back and forth.\n\n140\n00:06:36.790 --> 00:06:39.420\nAnd I'm going to build a query\nto build a function over here.\n\n141\n00:06:39.420 --> 00:06:43.990\nSo I'm just going to come in and\nI'll do a create function, and\n\n142\n00:06:43.990 --> 00:06:52.210\nI'm going to call this\nsales.getregionalsalespeople.\n\n143\n00:06:52.210 --> 00:06:55.620\nAnd I'll stick a little\nparentheses on the end here.\n\n144\n00:06:55.620 --> 00:07:00.550\nAnd if I just wanna get all of my sales\npeople, I could do a simple query.\n\n145\n00:07:00.550 --> 00:07:02.860\nBut if I wanna do it by\na particular region,\n\n146\n00:07:02.860 --> 00:07:05.510\nit would be nice if I had some\noptions available, right?\n\n147\n00:07:05.510 --> 00:07:08.770\nSo what I'm gonna do is I'm gonna make\nit where I can pass in a variable,\n\n148\n00:07:08.770 --> 00:07:10.210\nsome input parameters.\n\n149\n00:07:10.210 --> 00:07:15.220\nSo I'm gonna pass in @TerritoryID,\nand that's a name I'm making up,\n\n150\n00:07:15.220 --> 00:07:16.820\nyou can call it whatever you want.\n\n151\n00:07:16.820 --> 00:07:18.810\nI like to name it based on the day\nthat I'm putting in there.\n\n152\n00:07:18.810 --> 00:07:24.130\nSo I'm gonna provide the territory\nID as an integer and so this time,\n\n153\n00:07:24.130 --> 00:07:30.790\nnot only am I gonna be doing a join on\nsales.salesperson and person.person.\n\n154\n00:07:30.790 --> 00:07:32.950\nI'm gonna be able to\nfilter this by region.\n\n155\n00:07:32.950 --> 00:07:35.990\nJust give me the salesperson for\nregion one or region five or\n\n156\n00:07:35.990 --> 00:07:37.820\nregion ten and\nit will give that back to me.\n\n157\n00:07:37.820 --> 00:07:39.780\nSo with the function,\nwe get a little more power.\n\n158\n00:07:39.780 --> 00:07:42.590\nThat's why we don't wanna say,\nI'm not gonna use functions.\n\n159\n00:07:42.590 --> 00:07:45.990\nBecause they can save you so much time,\nand it can be reused like this.\n\n160\n00:07:45.990 --> 00:07:48.480\nIt's great for a number of reasons.\n\n161\n00:07:48.480 --> 00:07:51.360\nBut I'm gonna set this\nup to return a table.\n\n162\n00:07:51.360 --> 00:07:53.496\nI'll just say returns table.\n\n163\n00:07:53.496 --> 00:07:59.034\nAnd then as, and then I'll tell it\nthe Query that I will want to run.\n\n164\n00:07:59.034 --> 00:08:00.266\nAnd so from here,\n\n165\n00:08:00.266 --> 00:08:06.170\nthis is where I'm gonna do my join that\nis gonna save me some time from this guy.\n\n166\n00:08:06.170 --> 00:08:08.970\nAnd to save me a little time there,\nI'm gonna do a little bit of copy and\n\n167\n00:08:08.970 --> 00:08:15.110\npaste work to be able\nto simplify this a bit.\n\n168\n00:08:15.110 --> 00:08:16.480\nSo I'm gonna copy that query.\n\n169\n00:08:18.160 --> 00:08:20.840\nAnd jump back over here to my function and\npaste that in.\n\n170\n00:08:20.840 --> 00:08:25.720\nAnd I'll have to change it just\na little bit because here I was getting\n\n171\n00:08:25.720 --> 00:08:30.220\nterritory ID from the sales.salesterritory\ntable, which I aliased as t.\n\n172\n00:08:30.220 --> 00:08:34.700\nI'm gonna pull that from\nthe sales.salesperson table now.\n\n173\n00:08:34.700 --> 00:08:38.580\nAnd then name isn't in here, so\nI gotta take that one out, there.\n\n174\n00:08:38.580 --> 00:08:42.540\nBut I can get the TerritoryID,\nthe BusinessEntityID, the FirstName and\n\n175\n00:08:42.540 --> 00:08:43.140\nthe LastName.\n\n176\n00:08:43.140 --> 00:08:46.267\nI can get all that from\nsales.salesperson and Person.Person.\n\n177\n00:08:46.267 --> 00:08:52.320\nAnd there's my join, and then I just\nneed to close out that function.\n\n178\n00:08:52.320 --> 00:08:56.240\nAll right, so that part of the join is\ngoing to be inside of this function.\n\n179\n00:08:56.240 --> 00:08:59.950\nAnd when I run that, it's gonna\ncreate the function I've got one, and\n\n180\n00:08:59.950 --> 00:09:01.250\nnow I can start to call them.\n\n181\n00:09:01.250 --> 00:09:06.019\nAnd I can test that out real quick,\nif I want, by doing a SELECT * from\n\n182\n00:09:06.019 --> 00:09:12.980\nsales.getregionalsalespeople, and\nI can provide it a region number.\n\n183\n00:09:12.980 --> 00:09:16.530\nSo if I want everybody from region one,\njust throw a one in there.\n\n184\n00:09:16.530 --> 00:09:21.270\nAnd when I run that query,\nthere it goes and oops.\n\n185\n00:09:21.270 --> 00:09:23.410\nShoot, I forgot something important here.\n&gt;&gt; Uh-oh.\n\n186\n00:09:23.410 --> 00:09:24.520\n&gt;&gt; This is why we test our\n\n187\n00:09:24.520 --> 00:09:25.670\nfunctions, right?\n\n188\n00:09:25.670 --> 00:09:28.200\nI got everybody all the territories.\n\n189\n00:09:28.200 --> 00:09:29.230\nSo it didn't work right.\n\n190\n00:09:29.230 --> 00:09:30.690\nAnd that's because in my join here,\n\n191\n00:09:30.690 --> 00:09:34.000\nI kinda forgot to tell it\nto filter by that variable.\n\n192\n00:09:34.000 --> 00:09:35.350\nSo I need to fix this.\n\n193\n00:09:35.350 --> 00:09:38.310\nSo I'm gonna have to drop that\nfunction and recreate it.\n\n194\n00:09:38.310 --> 00:09:43.020\nYou can do an alter function, but In my\nopinion it's usually just faster to drop\n\n195\n00:09:43.020 --> 00:09:48.220\nthe function and\nthen rebuild it like that.\n\n196\n00:09:48.220 --> 00:09:53.160\nSo I'm gonna say\nsales.getregionalsalespeople.\n\n197\n00:09:53.160 --> 00:09:54.240\nSo that's the function that I've got.\n\n198\n00:09:54.240 --> 00:09:56.060\nI'm just gonna drop that, and\n\n199\n00:09:56.060 --> 00:09:59.160\nwhen I recreate it,\nI need to add a little bit more.\n\n200\n00:09:59.160 --> 00:10:06.270\nI need to say, where territory ID.\n\n201\n00:10:09.780 --> 00:10:13.970\nSo where the territory ID equals\nat territory ID, that variable.\n\n202\n00:10:13.970 --> 00:10:15.799\nThe whole reason of taking\ninput is that I need to\n\n203\n00:10:15.799 --> 00:10:16.579\nuse it right.\n&gt;&gt; Mm-hm.\n\n204\n00:10:16.579 --> 00:10:18.789\n&gt;&gt; So i'm gonna apply that,\n\n205\n00:10:18.789 --> 00:10:23.370\nto the the query here to make\nthat is returns what I want.\n\n206\n00:10:23.370 --> 00:10:27.791\nAnd so I'll rerun that and\nnow my test should work perfectly.\n\n207\n00:10:29.482 --> 00:10:32.450\nThere we go, now i just get\nthe sales people on region one.\n\n208\n00:10:32.450 --> 00:10:35.430\nAnd so I'm seeing them, I see their\nfirst name, I see their last name,\n\n209\n00:10:35.430 --> 00:10:37.330\ntheir business end ID, their territory ID.\n\n210\n00:10:37.330 --> 00:10:40.540\nThis is not information that's\nfound in one table, right?\n\n211\n00:10:40.540 --> 00:10:44.370\nThe joined is already done for\nme and I just call that function.\n\n212\n00:10:44.370 --> 00:10:48.780\nAnd so now, I've got a function that's\navailable for me to use in support.\n\n213\n00:10:48.780 --> 00:10:54.840\nSo you guys see how functions can save us\na lot of time, by kind of obfuscating or\n\n214\n00:10:54.840 --> 00:10:59.100\nremoving, hiding the complexity of our\ncode, and getting it where we just call\n\n215\n00:10:59.100 --> 00:11:03.860\na simple function like this.\n&gt;&gt; So if we use that function in a join,\n\n216\n00:11:03.860 --> 00:11:05.460\nit will break?\n\n217\n00:11:05.460 --> 00:11:06.570\n&gt;&gt; Sometimes.\n&gt;&gt; Yeah.\n\n218\n00:11:06.570 --> 00:11:07.770\n&gt;&gt; Let me clarify\n\n219\n00:11:07.770 --> 00:11:08.470\nthat.\n&gt;&gt; Okay.\n\n220\n00:11:08.470 --> 00:11:09.170\n&gt;&gt; This function,\n\n221\n00:11:09.170 --> 00:11:11.490\nthe way that I'm using it right\nhereactually won't break.\n\n222\n00:11:11.490 --> 00:11:15.470\nIt should work fine unless something\ncrazy happens that I don't anticipate.\n\n223\n00:11:15.470 --> 00:11:19.090\nSo if I go back here to my original query,\nright,\n\n224\n00:11:19.090 --> 00:11:21.510\na lot of this join I don't need anymore,\nokay?\n\n225\n00:11:21.510 --> 00:11:25.940\nSo I can update this to take advantage\nof my function that I just wrote.\n\n226\n00:11:25.940 --> 00:11:30.370\nAnd as long as everything\nfalls into place right,\n\n227\n00:11:30.370 --> 00:11:33.100\nthis will work and\nI won't have any issues, right?\n\n228\n00:11:33.100 --> 00:11:37.410\nSo let's update this to\nuse my new function.\n\n229\n00:11:37.410 --> 00:11:39.710\nSo I'm pulling these column titles and\n\n230\n00:11:39.710 --> 00:11:43.160\nyou'll see where I'm pulling\nfrom the aliases, right?\n\n231\n00:11:43.160 --> 00:11:44.970\nSo I've got the sales territory table.\n\n232\n00:11:44.970 --> 00:11:49.720\nI need that and then I've got this S here\nwhich represents sales.salesperson and\n\n233\n00:11:49.720 --> 00:11:52.950\nthis P which represents person.person.\n\n234\n00:11:52.950 --> 00:11:56.230\nWhy I'm not gonna have those two tables\nanymore so I'm just gonna be pointing\n\n235\n00:11:56.230 --> 00:12:01.160\nfrom my function which alias is S,\nso I'm gonna change each of these Ps\n\n236\n00:12:01.160 --> 00:12:04.820\nto an S because that's where all of\nthese is going to be coming from.\n\n237\n00:12:04.820 --> 00:12:09.920\nSo I'm gonna get that set and\nactually turn my caps lock there, right?\n\n238\n00:12:09.920 --> 00:12:12.130\nAnd then I'm saying that\nI'm pulling this from.\n\n239\n00:12:12.130 --> 00:12:15.500\nAnd you'll see where I've this got,\nsales.salesperson and person.person.\n\n240\n00:12:15.500 --> 00:12:19.310\nI'm not gonna call those directly anymore,\nI'm gonna call that function instead.\n\n241\n00:12:19.310 --> 00:12:21.520\nSo when I write this query,\n\n242\n00:12:21.520 --> 00:12:26.210\nI'm actually gonna be pulling from\nthe sales.salesterritory table.\n\n243\n00:12:27.300 --> 00:12:30.780\nSo I will pull from that\nsales.salesterritory, and\n\n244\n00:12:30.780 --> 00:12:32.980\nI will leave it to alias as S.\n\n245\n00:12:32.980 --> 00:12:37.530\nAnd then I'm gonna do a join,\nand I'm gonna join\n\n246\n00:12:38.850 --> 00:12:42.740\nbased on a function.\n\n247\n00:12:42.740 --> 00:12:47.464\nSo instead of joining to a table,\nI'll join to sales.get\n\n248\n00:12:47.464 --> 00:12:52.750\nregional sales people,\n\n249\n00:12:52.750 --> 00:12:55.760\nand Intellisense, apparently it\ncached it in the other window but\n\n250\n00:12:55.760 --> 00:12:56.820\nnot in this window for some reason.\n\n251\n00:12:56.820 --> 00:13:01.140\nBut I'm calling that function, and\nI'll provide it some kind of input.\n\n252\n00:13:01.140 --> 00:13:05.700\nSo maybe I want it to be where I'm\npulling the sales people from region one.\n\n253\n00:13:06.770 --> 00:13:09.160\nAnd I'll give that an alias as S.\n\n254\n00:13:09.160 --> 00:13:11.830\nSo it kind of takes\nthe place of the old table.\n\n255\n00:13:11.830 --> 00:13:14.806\nI still have to do my join,\nand I'm joining layer,\n\n256\n00:13:14.806 --> 00:13:21.400\nT.territory ID equals S.territory ID,\nis what I'm joining on.\n\n257\n00:13:21.400 --> 00:13:26.860\nAnd I don't need this or by, because I'm\njust pulling people in territory, okay.\n\n258\n00:13:26.860 --> 00:13:29.150\nNow, I've got red underlines\non some of my data here.\n\n259\n00:13:29.150 --> 00:13:31.170\nAnything that starts with an S because for\n\n260\n00:13:31.170 --> 00:13:36.330\nsome reason it isn't seeing the get\nregional sales people function just yet.\n\n261\n00:13:36.330 --> 00:13:39.410\nBut, this should just be\na IntelliSense passion thing.\n\n262\n00:13:39.410 --> 00:13:43.280\nYou create a new function In the other\nwindow, I actually made the function, so\n\n263\n00:13:43.280 --> 00:13:44.150\nit knew about it.\n\n264\n00:13:44.150 --> 00:13:46.900\nIn this window I didn't so\nit hasn't refreshed the objects.\n\n265\n00:13:46.900 --> 00:13:48.060\nThat'll happen over time.\n\n266\n00:13:48.060 --> 00:13:50.240\nBut if I run it and get an error,\nthen I've got a real problem,\n\n267\n00:13:50.240 --> 00:13:54.990\nbut if I run it and it's successful, then\nI know IntelliSense just hadn't cached.\n\n268\n00:13:54.990 --> 00:13:57.660\nSo it runs, and now I get.\n\n269\n00:13:57.660 --> 00:14:01.210\nWe saw over here that when\nI just called the function.\n\n270\n00:14:02.460 --> 00:14:08.100\nI got the people's name,\nbusiness entity ID, and the territory ID.\n\n271\n00:14:08.100 --> 00:14:12.540\nBut now when I do the join, and I run it,\nI can see here I get the person's name,\n\n272\n00:14:12.540 --> 00:14:16.140\nbusiness entity ID, territory ID,\nand and the territory name.\n\n273\n00:14:16.140 --> 00:14:18.660\nAnd that's coming from that other table.\n\n274\n00:14:18.660 --> 00:14:21.700\nSo I just successfully did\na join against the function,\n\n275\n00:14:21.700 --> 00:14:25.160\nagainst a common table expression of CTE.\n\n276\n00:14:25.160 --> 00:14:29.860\nTable expression here representing\nthis other join, and it worked fine.\n\n277\n00:14:29.860 --> 00:14:32.270\nSo it doesn't always break.\n\n278\n00:14:32.270 --> 00:14:33.990\nIn fact, it usually doesn't break,\n\n279\n00:14:33.990 --> 00:14:37.240\nit's usually perfectly fine\nto go in just like this.\n\n280\n00:14:37.240 --> 00:14:41.520\nAnd to be able to do that because\na common table expression\n\n281\n00:14:41.520 --> 00:14:45.270\nit's expecting me to provide\nit a static value like this.\n\n282\n00:14:45.270 --> 00:14:48.848\nI'm sending it this one, here's a one,\nI want you to figure this out for\n\n283\n00:14:48.848 --> 00:14:49.500\nregion one.\n\n284\n00:14:49.500 --> 00:14:52.970\nOr to give us some input parameters\nthat are fairly standard values.\n\n285\n00:14:52.970 --> 00:14:55.230\nAnd as long as you're doing that,\n\n286\n00:14:55.230 --> 00:15:00.060\nyou're not going to have a problem.\n&gt;&gt; Can you give us an example\n\n287\n00:15:00.060 --> 00:15:01.590\nwhere it might fail?\n\n288\n00:15:01.590 --> 00:15:03.310\nOr could fail?\n&gt;&gt; Sure so\n\n289\n00:15:03.310 --> 00:15:06.460\nwhere it fails is when you start\nto get a little more advanced\n\n290\n00:15:06.460 --> 00:15:08.910\nwith how you're feeding input\ninto the system, right?\n\n291\n00:15:08.910 --> 00:15:12.860\nSo as long as I'm doing this, as long\nas I'm providing a particular number,\n\n292\n00:15:12.860 --> 00:15:16.210\nthat's not a big deal, it's just\ngonna run the function and that's it.\n\n293\n00:15:16.210 --> 00:15:22.810\nBut what if I give a whole set of numbers\nthat I wanted to iterate through, right?\n\n294\n00:15:22.810 --> 00:15:25.770\nNow, I know that I can generate\na list of everybody and\n\n295\n00:15:25.770 --> 00:15:27.970\nthe region just by doing a normal joint.\n\n296\n00:15:27.970 --> 00:15:32.580\nBut if I wanted to do it here using the\nfunction, I would want it to give me all\n\n297\n00:15:32.580 --> 00:15:34.335\nten regions.\n&gt;&gt; Mm-hm.\n\n298\n00:15:34.335 --> 00:15:35.999\n&gt;&gt; Well, how do I tell it to give me\n\n299\n00:15:35.999 --> 00:15:37.820\nall ten regions?\n\n300\n00:15:37.820 --> 00:15:42.710\nIf the input parameter is just an integer,\nI can give it one, and two, and three.\n\n301\n00:15:42.710 --> 00:15:45.610\nSo I could run the function over and\nover and over again.\n\n302\n00:15:45.610 --> 00:15:47.240\nBut that would take a while, right?\n\n303\n00:15:47.240 --> 00:15:49.400\nOr it'd be ten queries,\nif I have ten regions.\n\n304\n00:15:49.400 --> 00:15:51.320\nIf I have 100 regions,\nit could be 100 queries,\n\n305\n00:15:51.320 --> 00:15:52.946\nthat's not really realistic.\n&gt;&gt; Mm-hm.\n\n306\n00:15:52.946 --> 00:15:54.072\n&gt;&gt; So what I could do is say,\n\n307\n00:15:54.072 --> 00:15:55.300\nyou know what?\n\n308\n00:15:55.300 --> 00:16:00.108\nInstead of just giving it a single number\n&gt;&gt; I'm gonna give it some\n\n309\n00:16:00.108 --> 00:16:03.170\ncomputated value like a table result.\n\n310\n00:16:03.170 --> 00:16:07.215\nA table of all of my region numbers and\nI'll feed that in.\n\n311\n00:16:07.215 --> 00:16:10.638\nAnd when a function receives a table,\nhis input, it will actually do,\n\n312\n00:16:10.638 --> 00:16:11.902\nit;s called iterating.\n\n313\n00:16:11.902 --> 00:16:15.240\nIt will iterate through\neach row of that table.\n\n314\n00:16:15.240 --> 00:16:18.690\nSo if I give it a table which\njust contains one column and\n\n315\n00:16:18.690 --> 00:16:22.065\nthat one column has a list\nof all of my region numbers,\n\n316\n00:16:22.065 --> 00:16:25.600\na function would normally\niterate right through that.\n\n317\n00:16:25.600 --> 00:16:29.771\nBut what's gonna happen in mine\nis that's not going to work and\n\n318\n00:16:29.771 --> 00:16:32.220\nlet me show you what that looks like.\n\n319\n00:16:32.220 --> 00:16:36.510\nSo instead of giving it a one\nas my input or a single region.\n\n320\n00:16:36.510 --> 00:16:38.037\nAnd really,\nI could have picked any region.\n\n321\n00:16:38.037 --> 00:16:40.053\nSo like if I pick region ten.\n\n322\n00:16:40.053 --> 00:16:42.207\nThat is I think England or the UK.\n\n323\n00:16:42.207 --> 00:16:43.387\nYeah, United Kingdom.\n\n324\n00:16:43.387 --> 00:16:45.060\nSo I get that information back.\n\n325\n00:16:45.060 --> 00:16:48.350\nWhatever region it is, it works and\nit gives me that information.\n\n326\n00:16:48.350 --> 00:16:50.680\nBut if I wanna go crazy and\n\n327\n00:16:50.680 --> 00:16:54.740\nreally get a little more complex with\nthis, I could say, you know what?\n\n328\n00:16:54.740 --> 00:16:57.210\nI’m gonna give it a column.\n\n329\n00:16:57.210 --> 00:17:01.383\nNow I’ve got T as an alias for\nmy sales.salesterritory table.\n\n330\n00:17:01.383 --> 00:17:08.068\nI'm gonna feed t.TerritoryID\nin their input.\n\n331\n00:17:08.068 --> 00:17:10.746\nNow, what is t.TerritoryID?\n\n332\n00:17:10.746 --> 00:17:16.128\nWell, that's the territory ID column\nfrom the sales.salesterritory table and\n\n333\n00:17:16.128 --> 00:17:19.016\nthat is just a list of\nmy territory numbers.\n\n334\n00:17:19.016 --> 00:17:20.118\nOne through ten.\n\n335\n00:17:20.118 --> 00:17:23.240\nSo I'm effectively feeding at\na list of one through ten.\n\n336\n00:17:23.240 --> 00:17:25.988\nAnd when I do that, what's gonna happen?\n\n337\n00:17:25.988 --> 00:17:27.765\nWell, let me tell you.\n\n338\n00:17:27.765 --> 00:17:30.345\nIntelliSense here is causing\na little bit of a problem for me.\n\n339\n00:17:30.345 --> 00:17:32.520\nSo I'm gonna copy this and\npaste it in another window.\n\n340\n00:17:32.520 --> 00:17:37.238\nI wanna show you the system is\nactually smart enough to know what's\n\n341\n00:17:37.238 --> 00:17:38.508\nabout to happen.\n\n342\n00:17:38.508 --> 00:17:42.280\nSo it will known and let me know that\nthere's a problem with this query.\n\n343\n00:17:42.280 --> 00:17:44.030\nSo when I type it, there we go.\n\n344\n00:17:44.030 --> 00:17:48.150\nIn this window where I created\nthe function, IntelliSense knows about it.\n\n345\n00:17:48.150 --> 00:17:52.100\nAnd see how it underlined\nt.TerritoryID and in red.\n\n346\n00:17:53.200 --> 00:17:54.310\nWhat it's doing is it's saying,\n\n347\n00:17:54.310 --> 00:17:56.330\nwait a minute, you're about to do\nsomething that's not going to work.\n\n348\n00:17:57.610 --> 00:18:01.640\nAnd if I run it, I run that query.\n\n349\n00:18:01.640 --> 00:18:03.564\nI'm gonna get an error back and\n\n350\n00:18:03.564 --> 00:18:08.752\nthis is different than your regular levels\n16 you type something wrong message.\n\n351\n00:18:08.752 --> 00:18:10.832\nThis is a very specific message.\n\n352\n00:18:10.832 --> 00:18:16.634\nIt's telling me a multi part identifier,\nt.TerritoryID could not be bound.\n\n353\n00:18:16.634 --> 00:18:18.270\nMulti-part identifier.\n\n354\n00:18:18.270 --> 00:18:23.284\nThat means this is one entity that\nactually represents multiple entities.\n\n355\n00:18:23.284 --> 00:18:24.870\nI gave it a column of a table.\n\n356\n00:18:24.870 --> 00:18:26.852\nIt's got one through ten,\neach on its own row.\n\n357\n00:18:26.852 --> 00:18:27.965\nIt's ten rows.\n\n358\n00:18:27.965 --> 00:18:31.738\nSo when I gave it to it,\nit said, I need to take that and\n\n359\n00:18:31.738 --> 00:18:34.373\nI need to bind that to a temporary table.\n\n360\n00:18:34.373 --> 00:18:36.580\nSo I can iterate through it.\n\n361\n00:18:36.580 --> 00:18:38.550\nBut when it went to bind it,\nnothing was there.\n\n362\n00:18:40.170 --> 00:18:40.670\nWhy is that?\n\n363\n00:18:41.770 --> 00:18:46.530\nWell, variables and\ncomputed values like these in a join.\n\n364\n00:18:47.550 --> 00:18:49.584\nRemember the part at the beginning\nwhere I said, joins have two parts.\n\n365\n00:18:49.584 --> 00:18:51.720\nThey have a left side and a right side.\n\n366\n00:18:51.720 --> 00:18:55.130\nThose values are not shared between\nthe left side and the right side.\n\n367\n00:18:55.130 --> 00:18:57.160\nIt's the join that uses those.\n\n368\n00:18:57.160 --> 00:18:59.646\nSo now, I'm calling the function and\n\n369\n00:18:59.646 --> 00:19:03.691\nI'm expecting the function to\nknow what t.TerritoryID is.\n\n370\n00:19:03.691 --> 00:19:06.826\nBut the function never\ntouches the territory,\n\n371\n00:19:06.826 --> 00:19:09.630\nthe sales.sales.territory table.\n\n372\n00:19:09.630 --> 00:19:13.917\nThe function we wrote, which actually\nI've got up here on the screen is,\n\n373\n00:19:13.917 --> 00:19:15.519\nlet me scroll back up to it.\n\n374\n00:19:15.519 --> 00:19:20.710\nIt is touching sales.salesperson and\nit's touching person.person.\n\n375\n00:19:20.710 --> 00:19:24.527\nNow if I was referencing\nsales.salesterritory inside of this\n\n376\n00:19:24.527 --> 00:19:26.835\nfunction, it would know what it was.\n\n377\n00:19:26.835 --> 00:19:32.037\nBut since I'm not, when I give it that\nsales.salesterritory.territoryID,\n\n378\n00:19:32.037 --> 00:19:34.790\nit doesn't know what to do with it.\n\n379\n00:19:34.790 --> 00:19:37.742\nIt can't make sense out of it and\nI get this error.\n\n380\n00:19:37.742 --> 00:19:40.500\nThis is the example where it fails,\nwhere it breaks.\n\n381\n00:19:41.830 --> 00:19:47.083\nAnd so this situation right here\nin the olden days would mean,\n\n382\n00:19:47.083 --> 00:19:49.521\nI just wanna use a function.\n\n383\n00:19:49.521 --> 00:19:54.280\nI'll go ahead and\nI will just do manual joints.\n\n384\n00:19:55.380 --> 00:19:58.890\nBut in transact SQL,\nwe can do an apply and\n\n385\n00:19:58.890 --> 00:20:02.990\nan APPLY can solve that problem\nin this particular scenario.\n\n386\n00:20:02.990 --> 00:20:05.145\nSo you don't always have to use APPLY.\n\n387\n00:20:05.145 --> 00:20:09.083\nBut if you run into this situation right\nhere where you're trying to pass a more\n\n388\n00:20:09.083 --> 00:20:13.319\ncomplex dataset in and you get a multipart\nidentifier error like this where it can't\n\n389\n00:20:13.319 --> 00:20:17.079\nbe bound, you're trying to hand\ninformation from one side of the join over\n\n390\n00:20:17.079 --> 00:20:20.240\nto the other side when\nthe other side is a function.\n\n391\n00:20:20.240 --> 00:20:22.826\nThat's where APPLY comes in and\nsolves the problem.\n\n392\n00:20:22.826 --> 00:20:26.430\nSo this is not a routine command\nthat everybody needs to know.\n\n393\n00:20:26.430 --> 00:20:28.652\nThat's why it wasn't in\nthe basic part of this show, but\n\n394\n00:20:28.652 --> 00:20:30.889\nit is something that an advanced\nuser would need to know.\n\n395\n00:20:30.889 --> 00:20:34.160\nBecause this doesn't mean\nlet's abandon the functions.\n\n396\n00:20:34.160 --> 00:20:37.160\nIt means yeah, in this scenario,\nI need to use and APPLY and\n\n397\n00:20:37.160 --> 00:20:39.743\nthat will help me fix this.\n&gt;&gt; So functions are useful, but\n\n398\n00:20:39.743 --> 00:20:40.753\nthey can break joints.\n\n399\n00:20:40.753 --> 00:20:45.107\nSo how do we make it work?\n&gt;&gt; So if we wanna make it work,\n\n400\n00:20:45.107 --> 00:20:46.613\nwe're gonna use APPLY.\n\n401\n00:20:46.613 --> 00:20:49.692\nAnd APPLY is actually\nkind of a neat thing,\n\n402\n00:20:49.692 --> 00:20:54.920\nbecause what it does is it allows us\nto make our queries even more simple.\n\n403\n00:20:54.920 --> 00:20:56.729\nBecause applies are easier than joints.\n\n404\n00:20:56.729 --> 00:21:00.898\nSo if I wanna take this one, I've got,\nwell, first off, I've got two choices,\n\n405\n00:21:00.898 --> 00:21:04.090\ncuz there's actually two types of applies.\n\n406\n00:21:04.090 --> 00:21:08.120\nThe normal apply that most of us are gonna\ndo is what's called a CROSS APPLY.\n\n407\n00:21:08.120 --> 00:21:10.612\nSo cross, C-R-O-S-S.\n\n408\n00:21:10.612 --> 00:21:12.037\nApply, A-P-P-L-Y.\n\n409\n00:21:12.037 --> 00:21:16.268\nAnd when we do a CROSS APPLY,\nit's like a standard INNER JOIN.\n\n410\n00:21:16.268 --> 00:21:19.846\nI'm going to be combining two sets of\ndata yhe same way an inter join would.\n\n411\n00:21:19.846 --> 00:21:22.710\nIt's just I need to be able to exchange\ninformation between the two, so\n\n412\n00:21:22.710 --> 00:21:24.540\nthey recognize each other's information.\n\n413\n00:21:25.960 --> 00:21:30.190\nAn outer apply is like an OUTER JOIN.\n\n414\n00:21:30.190 --> 00:21:34.210\nA CROSS APPLY doesn't include null values,\nif something doesn't match,\n\n415\n00:21:34.210 --> 00:21:35.580\nit doesn't get returned.\n\n416\n00:21:35.580 --> 00:21:38.170\nA CROSS APPLY returns\nthings that don't match.\n\n417\n00:21:38.170 --> 00:21:40.625\nSame thing with a join, an INNER JOIN.\n\n418\n00:21:40.625 --> 00:21:43.250\nIt doesn't return no values,\nthings that don't match.\n\n419\n00:21:43.250 --> 00:21:48.200\nAnd outer joints does and then you\npick left, right or full outer joint.\n\n420\n00:21:48.200 --> 00:21:50.972\nWith applies, you don't have left,\nright and outer.\n\n421\n00:21:50.972 --> 00:21:55.102\nWith applies, you have the CROSS APPLY\nwhich is like an inner joint and\n\n422\n00:21:55.102 --> 00:21:58.500\nyou have the OUTER APPLY which\nis like a full OUTER JOINs.\n\n423\n00:21:58.500 --> 00:22:00.494\nSo those are the two that we've got.\n\n424\n00:22:00.494 --> 00:22:03.682\nSo I would need to take this query and\nrewrite it a bit, but\n\n425\n00:22:03.682 --> 00:22:06.500\nI do need to make that\nchoice which do I wanna do.\n\n426\n00:22:06.500 --> 00:22:08.266\nWell, I was doing INNER JOINs.\n\n427\n00:22:08.266 --> 00:22:12.350\nSo I'm gonna use a CROSS JOIN to\nbe able to solve this problem.\n\n428\n00:22:12.350 --> 00:22:15.602\nA CROSS APPLY to solve the problem and\nthen we'll be able to get this query\n\n429\n00:22:15.602 --> 00:22:16.568\nworking.\n&gt;&gt; So Don,\n\n430\n00:22:16.568 --> 00:22:20.374\nis the syntax the same as a join?\n&gt;&gt; It's similar, but\n\n431\n00:22:20.374 --> 00:22:22.487\nactually it is a little bit easier.\n\n432\n00:22:22.487 --> 00:22:26.806\nWhen we do a join,\nwe have to specify that the two tables and\n\n433\n00:22:26.806 --> 00:22:31.970\nwe have to specify what the relationship\nis between those tables.\n\n434\n00:22:31.970 --> 00:22:33.677\nSo that it understands\nwhat we're working with.\n\n435\n00:22:33.677 --> 00:22:39.630\nWell, when we do an APPLY, we actually\ndon't have to specify the relationship.\n\n436\n00:22:39.630 --> 00:22:44.266\nYou can leave that out, because the APPLY\nwill take care of finding the relationship\n\n437\n00:22:44.266 --> 00:22:45.909\nand mapping that data for me.\n\n438\n00:22:45.909 --> 00:22:48.930\nSo I'm gonna leave my select the same.\n\n439\n00:22:48.930 --> 00:22:51.615\nI'm pulling from\nsales.sales territory as T.\n\n440\n00:22:51.615 --> 00:22:53.340\nI'll leave that the same.\n\n441\n00:22:53.340 --> 00:22:58.671\nBut then instead of joining on that\nfunction, I'm gonna come in and\n\n442\n00:22:58.671 --> 00:23:03.643\nI'm gonna say that I'm going to\nCROSS APPLY on that function.\n\n443\n00:23:03.643 --> 00:23:05.927\nAnd now, I specify the function.\n\n444\n00:23:05.927 --> 00:23:09.060\nI'm providing t to a territory ID,\nI would give it an alias of s.\n\n445\n00:23:10.130 --> 00:23:14.350\nNow when I do that, what it's\nreally doing is not a normal join.\n\n446\n00:23:14.350 --> 00:23:18.209\nIt's gonna take that function and\nit's gonna run it once or\n\n447\n00:23:18.209 --> 00:23:22.993\neach row as it goes through in a process\nis this sales.sales territory and\n\n448\n00:23:22.993 --> 00:23:27.468\nthat's why the function will know\nwhere the territory ID column is,\n\n449\n00:23:27.468 --> 00:23:31.380\ncuz it's going row by row\nwhere the process is through.\n\n450\n00:23:31.380 --> 00:23:34.823\nSo when you're doing iterative query,\nthis kind of solves it.\n\n451\n00:23:34.823 --> 00:23:38.527\nAnd I didn't mention it earlier,\nbut correlated queries.\n\n452\n00:23:38.527 --> 00:23:41.320\nIf you went back and\nwatched our subqueries episode and\n\n453\n00:23:41.320 --> 00:23:45.511\nI talked about correlated queries and\nhow they aren't usually very efficient and\n\n454\n00:23:45.511 --> 00:23:49.517\nthey cause problems, well, this is one\nof the problems I was talking about and\n\n455\n00:23:49.517 --> 00:23:52.460\na CROSS APPLY would actually\nfix that correlated query.\n\n456\n00:23:52.460 --> 00:23:55.219\nThere are times where you need\nto iterate through each row.\n\n457\n00:23:55.219 --> 00:23:57.256\nAnd so that's what I'm telling it to do.\n\n458\n00:23:57.256 --> 00:24:01.900\nNow when I do this I'm\nfeeding it every territory.\n\n459\n00:24:01.900 --> 00:24:05.617\nAnd so it's gonna run in\nthe most optimal form possible.\n\n460\n00:24:05.617 --> 00:24:09.900\nI do need to add, I don' thave to but\nI want to add in order by.\n\n461\n00:24:09.900 --> 00:24:12.433\nSo the records will be near each other.\n\n462\n00:24:12.433 --> 00:24:15.110\nIt's gonna go in row\norder from top to bottom.\n\n463\n00:24:15.110 --> 00:24:19.815\nSo I won't necessarily know the order\nI'm gonna get this information back in.\n\n464\n00:24:19.815 --> 00:24:23.348\nBy applying an order by it'll just\nmake it look a little neater, okay.\n\n465\n00:24:23.348 --> 00:24:26.326\nNow, once I've got that in here,\nI've got that I'm pulling from\n\n466\n00:24:26.326 --> 00:24:29.380\nSales.SalesTerritory, that's\ngot an alias of T.\n\n467\n00:24:29.380 --> 00:24:36.373\nI'm doing a cross-apply on this function,\nthe Sales.GetRegionalSalesPeople.\n\n468\n00:24:36.373 --> 00:24:38.880\nAnd then I'm providing you\nthat territorial ID and\n\n469\n00:24:38.880 --> 00:24:40.170\ngiving it the order bias.\n\n470\n00:24:40.170 --> 00:24:44.365\nSo our query is a little bit smaller\nnow then it was with the joined and\n\n471\n00:24:44.365 --> 00:24:46.801\nit should be a little bit easier for us.\n\n472\n00:24:46.801 --> 00:24:50.711\nNow I do have some red underlines\non here which this window knew\n\n473\n00:24:50.711 --> 00:24:55.010\nabout the function and now it's\nlike it forgot about the function.\n\n474\n00:24:55.010 --> 00:24:57.717\nSo everything that's referencing that\nfunction it got me a red underline; I'm\n\n475\n00:24:57.717 --> 00:24:58.961\ngonna run it and see if I get an error.\n\n476\n00:24:58.961 --> 00:25:01.500\nI might have missed a period or\nsomething somewhere.\n\n477\n00:25:01.500 --> 00:25:06.397\nSo let me run that and no, all right\nIntelliSense isn't refreshing for me.\n\n478\n00:25:06.397 --> 00:25:10.880\nBut when it runs I didn't get\na multi-part identifier error, did I?\n\n479\n00:25:10.880 --> 00:25:16.316\nThis time it worked and I didn't just\nget territory one I got every territory.\n\n480\n00:25:16.316 --> 00:25:20.541\nHere's territory one followed by each of\nthe remaining territories after that two,\n\n481\n00:25:20.541 --> 00:25:23.898\nthree, four, five, all the way\ndown to ten, the United Kingdom.\n\n482\n00:25:23.898 --> 00:25:28.384\nAnd I can see J Pack right there\nall in place and it worked.\n\n483\n00:25:28.384 --> 00:25:32.609\nSo I didn't have to say I'm not gonna do\na function I just had to say all right,\n\n484\n00:25:32.609 --> 00:25:36.119\nI'm gonna use this function and\nyeah, I'm gonna get an error so\n\n485\n00:25:36.119 --> 00:25:39.130\nlet me do a cross supply\ninstead of doing a join.\n\n486\n00:25:39.130 --> 00:25:42.189\nAnd it solves the problem,\nget the information I want and\n\n487\n00:25:42.189 --> 00:25:46.351\nnow I'm ready to rock.\n&gt;&gt; Can you give us an example of\n\n488\n00:25:46.351 --> 00:25:48.868\nan outer apply?\n&gt;&gt; Yes I can.\n\n489\n00:25:48.868 --> 00:25:49.368\n[LAUGH]\n&gt;&gt; [LAUGH]\n\n490\n00:25:49.368 --> 00:25:50.979\n&gt;&gt; So with an outer apply I had to\n\n491\n00:25:50.979 --> 00:25:54.147\nthink about it for\na second because with an outer apply.\n\n492\n00:25:54.147 --> 00:25:56.450\nIf there's something that doesn't match it\n\n493\n00:25:56.450 --> 00:25:59.480\ngets left out, okay.\nWell right now everything has a match.\n\n494\n00:25:59.480 --> 00:26:04.370\nI have ten regions, and every region\nhas at least one salesperson in it.\n\n495\n00:26:04.370 --> 00:26:06.265\nSo they're all coming back, all right.\n\n496\n00:26:06.265 --> 00:26:10.988\nSo if I wanna show you guys an example\nof an outer apply I could say well,\n\n497\n00:26:10.988 --> 00:26:14.484\nyou just change from cross to outer and\nyou're done.\n\n498\n00:26:14.484 --> 00:26:18.359\nThen I can run that, there's all\nthat information show's over, right.\n\n499\n00:26:18.359 --> 00:26:21.441\nBut the problem is since\nall of my regions have\n\n500\n00:26:21.441 --> 00:26:24.490\nsales people that data is no different.\n\n501\n00:26:24.490 --> 00:26:26.316\nSo how do we know that it actually works?\n\n502\n00:26:26.316 --> 00:26:27.760\nSo let me give you an example.\n\n503\n00:26:27.760 --> 00:26:31.798\nLet's say that Jae Pak here\nhe's working in the UK and\n\n504\n00:26:31.798 --> 00:26:35.584\nhe's just doing a great job but\nhe's one person.\n\n505\n00:26:35.584 --> 00:26:39.549\nHe's by himself and I say you know\nwhat I thinkIi'm gonna move Jay\n\n506\n00:26:39.549 --> 00:26:42.446\nto the France office\nright across the channel.\n\n507\n00:26:42.446 --> 00:26:44.049\nSo I'm gonna move him over there and\n\n508\n00:26:44.049 --> 00:26:47.213\nthat way I can close down the building\nUK to save a little money or what.\n\n509\n00:26:47.213 --> 00:26:48.363\nSo I'm gonna move him out.\n\n510\n00:26:48.363 --> 00:26:54.140\nNow when I move Jay out the United Kingdom\nwill no longer have any sales people.\n\n511\n00:26:54.140 --> 00:26:58.052\nSo when we're iterating through\nSales.GetRegionalSalesPeople,\n\n512\n00:26:58.052 --> 00:27:00.370\nit's not gonna find anybody from the UK,\n\n513\n00:27:00.370 --> 00:27:02.160\nthat's a null value.\n&gt;&gt; Hmm.\n\n514\n00:27:02.160 --> 00:27:05.396\n&gt;&gt; And I cross-apply would leave it out.\n\n515\n00:27:05.396 --> 00:27:08.340\nSo I'm gonna put that\nback to a cross-apply.\n\n516\n00:27:08.340 --> 00:27:12.979\nAnd it would leave it out and outer apply\nwould include it, so let me transfer Jay.\n\n517\n00:27:12.979 --> 00:27:17.765\nSo we're gonna give him\na lateral promotion here.\n\n518\n00:27:17.765 --> 00:27:22.322\nSo let me do a update\nSales.SalesPerson and\n\n519\n00:27:22.322 --> 00:27:26.631\nI will set the territory id to let's see,\n\n520\n00:27:26.631 --> 00:27:31.820\nFrance is 7, so\nwe're gonna move him over to 7.\n\n521\n00:27:31.820 --> 00:27:39.177\nWhere is this entity id is equal to and\njpeg is 289.\n\n522\n00:27:39.177 --> 00:27:42.737\nAll right, so\nit's gonna get moved, all right.\n\n523\n00:27:42.737 --> 00:27:44.751\nSo now he's moved over to France,\n\n524\n00:27:44.751 --> 00:27:46.273\nfastest move ever.\n&gt;&gt; [LAUGH]\n\n525\n00:27:46.273 --> 00:27:47.266\n&gt;&gt; And now when I go back and\n\n526\n00:27:47.266 --> 00:27:50.080\nI run this query,\nI'm still doing a cross apply, right.\n\n527\n00:27:50.080 --> 00:27:54.832\nSo when I do the cross apply I\nshould see that he's now in France.\n\n528\n00:27:54.832 --> 00:27:58.342\nAnd so when I come down here and\nfind seven, we've got,\n\n529\n00:27:58.342 --> 00:28:00.378\ndid I get the wrong person?\n\n530\n00:28:00.378 --> 00:28:03.259\nThey there are, Jae Pak,\n289, he's in France now.\n\n531\n00:28:03.259 --> 00:28:03.954\n&gt;&gt; Mm-hm.\n\n532\n00:28:03.954 --> 00:28:06.517\n&gt;&gt; And if I scroll down to the UK I can't\n\n533\n00:28:06.517 --> 00:28:09.050\ncuz it's not there, right.\n\n534\n00:28:09.050 --> 00:28:13.535\nWhen the cross supply runs,\nif there's not a match it leaves it off.\n\n535\n00:28:13.535 --> 00:28:17.016\nAnd so there is no 10 on this,\nthere is no UK.\n\n536\n00:28:17.016 --> 00:28:21.474\nI can't scroll down any further,\nthe aquarinalizer won't let me.\n\n537\n00:28:21.474 --> 00:28:24.640\nIf I stretch this window\nout to show whole data set.\n\n538\n00:28:26.320 --> 00:28:29.880\nSo hard to get your mouse right on\nthe line to be able to stretch that,\n\n539\n00:28:29.880 --> 00:28:30.573\nthere we go.\n\n540\n00:28:30.573 --> 00:28:33.281\nI can see them all and\nthere's no more room for\n\n541\n00:28:33.281 --> 00:28:36.240\nme to scroll down,\nI'm seeing the whole thing.\n\n542\n00:28:36.240 --> 00:28:41.886\nSo if I change my query to be a outer\n\n543\n00:28:41.886 --> 00:28:46.944\napply, now it's gonna run.\n\n544\n00:28:46.944 --> 00:28:52.160\nIt's gonna see that there's nobody in\nthe UK and it's still going to display it.\n\n545\n00:28:52.160 --> 00:28:54.818\nSo if I scroll down, there's the UK.\n\n546\n00:28:54.818 --> 00:28:58.940\nI see United Kingdom and\nI can see nulls for each of those records.\n\n547\n00:28:58.940 --> 00:29:02.666\nSo if that's what I want,\nI just change pros apply to outer reply.\n\n548\n00:29:02.666 --> 00:29:07.042\nThe rest of the syntax is entirely\nthe same and unlike a join I don't have to\n\n549\n00:29:07.042 --> 00:29:11.995\nthink about left or right, or full outer\njoined here it's just a full outer joint.\n\n550\n00:29:11.995 --> 00:29:15.682\nBecause it's going each row as it\nruns through to pull up that data.\n\n551\n00:29:15.682 --> 00:29:20.522\nSo there it is, it's still on\nthe screen and we have saved the day,\n\n552\n00:29:20.522 --> 00:29:23.168\nthanks to apply.\n&gt;&gt; Awesome, okay,\n\n553\n00:29:23.168 --> 00:29:24.455\nwell expressions and apply.\n\n554\n00:29:24.455 --> 00:29:27.329\nWonderful episode Don,\nyou did a great episode once again.\n\n555\n00:29:27.329 --> 00:29:29.857\nBefore we move on any last words?\n&gt;&gt; All right,\n\n556\n00:29:29.857 --> 00:29:33.034\nwell this was another example of\nwhere that might be a situation as\n\n557\n00:29:33.034 --> 00:29:35.592\nyou're writing a query that\nyou run into a problem.\n\n558\n00:29:35.592 --> 00:29:39.053\nAnd if you just know the tools that are\navailable, you know a way to solve it and\n\n559\n00:29:39.053 --> 00:29:41.760\nmake use of that technology and\nget things running.\n\n560\n00:29:41.760 --> 00:29:44.912\nSo apply is not going to be\nsomething you use every day, okay.\n\n561\n00:29:44.912 --> 00:29:46.671\n&gt;&gt; Mm-hm.\n\n562\n00:29:46.671 --> 00:29:48.113\n&gt;&gt; In my mind I always think okay,\n\n563\n00:29:48.113 --> 00:29:49.727\ndo I need to iterate through data?\n\n564\n00:29:49.727 --> 00:29:51.790\nI'll probably need to do an apply,\nall right.\n\n565\n00:29:51.790 --> 00:29:53.450\nOr if I'm just writing a join and\n\n566\n00:29:53.450 --> 00:29:57.141\nI ran into one of these situations\nwhere I get that multi part identifier\n\n567\n00:29:57.141 --> 00:30:00.665\ncan't be bound error I say that's\nwhere I'll need and apply.\n\n568\n00:30:00.665 --> 00:30:03.765\nIf I'm not neither of those two scenarios\nI don't need to think about applying it\n\n569\n00:30:03.765 --> 00:30:06.400\nI'll just automatically right join it,\nthat's what I do.\n\n570\n00:30:06.400 --> 00:30:11.616\nOr I create views that act as that data\ncuz you can do a lot of this with a view.\n\n571\n00:30:11.616 --> 00:30:13.180\nSo those are all options.\n\n572\n00:30:13.180 --> 00:30:15.158\nBut when we're working with functions,\n\n573\n00:30:15.158 --> 00:30:18.381\nwhen we're in these scenarios apply\nis like that special tool found\n\n574\n00:30:18.381 --> 00:30:21.732\nin the bottom of the toolbox that\nreally saves the day when you have it.\n\n575\n00:30:21.732 --> 00:30:23.520\nAnd your really miss it\nwhen you don't have it.\n\n576\n00:30:23.520 --> 00:30:25.104\n&gt;&gt; Well done, Don, excellent.\n\n577\n00:30:25.104 --> 00:30:28.040\nAnd Querying Data with Transact-SQL\nis a wonderful series.\n\n578\n00:30:28.040 --> 00:30:30.870\nMake sure you watch every single episode,\nyou'll be glad you did.\n\n579\n00:30:30.870 --> 00:30:34.766\nInside that course library is\nthousands of other videos.\n\n580\n00:30:34.766 --> 00:30:37.372\nThey are there to help you go further,\ncheck them out.\n\n581\n00:30:37.372 --> 00:30:41.252\nAnd tell everybody you know about ITProTV,\nITProTV is bingeworthy.\n\n582\n00:30:41.252 --> 00:30:43.579\nThanks for watching, I'm Zach Memos.\n&gt;&gt; And I'm Don Pezet.\n\n583\n00:30:43.579 --> 00:30:45.361\n&gt;&gt; And we will see you very soon.\n\n584\n00:30:45.361 --> 00:30:52.190\n[MUSIC]\n\n585\n00:30:52.190 --> 00:30:55.245\n&gt;&gt; Thank you for watching ITProTV.\n\n",
          "vimeoId": "251827474"
        }
      ],
      "title": "Advanced Transact-SQL"
    },
    {
      "episodes": [
        {
          "description": "n this episode, Don explains how we can work with XML data inside of Transact-SQL. He demonstrates how to configure the output of a query to be formatted as XML. He then demonstrates how to use XML data as the input for a query.",
          "length": "1928",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-7-1-1-working_with_xml-011218-PGM.00_34_35_18.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-7-1-1-working_with_xml-011218-PGM.00_34_35_18.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-7-1-1-working_with_xml-011218-PGM.00_34_35_18.Still001-sm.jpg",
          "title": "Working with XML",
          "transcript": "",
          "vimeoId": "251172104"
        },
        {
          "description": "In this episode, Don explains how we can work with JSON data inside of Transact-SQL. He demonstrates how to configure the output of a query to be formatted as JSON. He then demonstrates how to use JSON data as the input for a query.",
          "length": "1750",
          "thumbnail": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-7-2-1-working_with_json-011719-PGM.00_32_35_09.Still001.png",
          "thumbnailMed": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-7-2-1-working_with_json-011719-PGM.00_32_35_09.Still001-med.jpg",
          "thumbnailSm": "https://itprotv-image-bucket.s3.amazonaws.com/microsoft-sql70761/microsoft-sql70761-7-2-1-working_with_json-011719-PGM.00_32_35_09.Still001-sm.jpg",
          "title": "Working with JSON",
          "transcript": "WEBVTT\n\n1\n00:00:00.090 --> 00:00:02.355\nWelcome to ITPro.TV,\nI'm your host Don Pezet.\n\n2\n00:00:02.355 --> 00:00:06.493\n[CROSSTALK]\n\n3\n00:00:06.493 --> 00:00:08.323\n[MUSIC]\n\n4\n00:00:08.323 --> 00:00:11.823\n&gt;&gt; You're watching ITProTV.\n\n5\n00:00:11.823 --> 00:00:13.999\n&gt;&gt; Hello, thank you for choosing ITProTV,\n\n6\n00:00:13.999 --> 00:00:16.683\nempowering the world\nthrough engaging learning.\n\n7\n00:00:16.683 --> 00:00:17.604\nI'm your host, Zach Memos.\n\n8\n00:00:17.604 --> 00:00:21.105\nAs we continue on with querying\ndata with Transact SQL,\n\n9\n00:00:21.105 --> 00:00:23.346\nthis episode is working with JSON.\n\n10\n00:00:23.346 --> 00:00:24.756\nYes, finally, we're there.\n\n11\n00:00:24.756 --> 00:00:26.605\n[LAUGH] Don Pezet is here to help us out.\n\n12\n00:00:26.605 --> 00:00:27.485\nDon, great to have you.\n\n13\n00:00:27.485 --> 00:00:28.517\nThanks so much.\n\n14\n00:00:28.517 --> 00:00:31.516\n&gt;&gt; I'd thought you were in\nto call me JSON [INAUDIBLE].\n\n15\n00:00:31.516 --> 00:00:33.831\n&gt;&gt; [LAUGH] Call him JSON.\n\n16\n00:00:33.831 --> 00:00:36.201\n&gt;&gt; So this episode,\nwe are working with JSON,\n\n17\n00:00:36.201 --> 00:00:40.970\nwhich is not a third person on this show,\nbut the JavaScript object notation.\n\n18\n00:00:40.970 --> 00:00:44.948\nIt's a way of outputting data that is\nkind of like the hot buzz word right now-\n\n19\n00:00:44.948 --> 00:00:45.551\n&gt;&gt; Yep.\n\n20\n00:00:45.551 --> 00:00:47.538\n&gt;&gt; That has dethroned XML.\n\n21\n00:00:47.538 --> 00:00:50.820\nSo we're gonna be looking at how we\ncan work with our SQL server and\n\n22\n00:00:50.820 --> 00:00:54.118\nuse Transact-SQL that handle\nqueries that deal with JSON data.\n\n23\n00:00:54.118 --> 00:00:57.973\nData stored as JSON or\ncreating data to be represented as JSON,\n\n24\n00:00:57.973 --> 00:01:01.190\nwhich we can see all that\nright here in this episode.\n\n25\n00:01:01.190 --> 00:01:04.205\n&gt;&gt; So Don, for\nthe unititiated, what is JSON?\n\n26\n00:01:04.205 --> 00:01:06.828\nAnd well, why should we care about it?\n\n27\n00:01:06.828 --> 00:01:12.889\n&gt;&gt; All right, so well the acronym, my\nartist was the JavaScript Object Notation.\n\n28\n00:01:12.889 --> 00:01:13.496\n&gt;&gt; Right.\n&gt;&gt; And\n\n29\n00:01:13.496 --> 00:01:16.201\nwhat that should tell you is a few things,\nright?\n\n30\n00:01:16.201 --> 00:01:19.110\nSo JavaScript,\nthat's where this came from.\n\n31\n00:01:19.110 --> 00:01:21.062\nAnd the world, the World Wide Web,\n\n32\n00:01:21.062 --> 00:01:24.851\nespecially the Internet is kind of\npowered by JavaScript right now.\n\n33\n00:01:24.851 --> 00:01:29.111\nIt is a rare, rare website that you can go\nto that isn't using JavaScript to render\n\n34\n00:01:29.111 --> 00:01:31.422\nall of its elements in\nthe right positions.\n\n35\n00:01:31.422 --> 00:01:33.660\n&gt;&gt; True story.\n&gt;&gt; And do all sorts of fun stuff.\n\n36\n00:01:33.660 --> 00:01:37.635\nIf you ever wonder, turn off JavaScript\nin your web browser and see what happens.\n\n37\n00:01:37.635 --> 00:01:38.633\n&gt;&gt; It's fun.\n\n38\n00:01:38.633 --> 00:01:39.744\n[LAUGH]\n&gt;&gt; Yeah, very,\n\n39\n00:01:39.744 --> 00:01:43.810\nvery few pages function at all,\nso really, really relevant.\n\n40\n00:01:43.810 --> 00:01:48.272\nAnd in JavaScript, you got these web\napps than neither data from someone.\n\n41\n00:01:48.272 --> 00:01:51.719\nAnd so they created this object notation,\n\n42\n00:01:51.719 --> 00:01:55.366\na way to present what's\ntabular data in SQL.\n\n43\n00:01:55.366 --> 00:02:00.139\nBut basically these attributes and their\nvalues, the information that we can pull\n\n44\n00:02:00.139 --> 00:02:05.400\nfrom a database, built to represent it in\na simple way the JavaScript can handle.\n\n45\n00:02:05.400 --> 00:02:08.790\nAnd so they created this\ntext-based format called JSON.\n\n46\n00:02:08.790 --> 00:02:10.341\nVery, very similar to XML, right?\n\n47\n00:02:10.341 --> 00:02:11.780\nThe Extensible Markup Language.\n\n48\n00:02:11.780 --> 00:02:17.696\nWe saw XML in a previous episode,\nit was the big buzzword in the year 2000.\n\n49\n00:02:17.696 --> 00:02:20.886\nAnd really the first\ndecade of the century, but\n\n50\n00:02:20.886 --> 00:02:25.930\nnow not many people write new things for\nXML, instead JSON is the way to go.\n\n51\n00:02:25.930 --> 00:02:29.666\nAnd not just with JavaScript,\nwith all sorts of language now,\n\n52\n00:02:29.666 --> 00:02:33.980\nmost programming languages have\nlibraries to support the JSON format.\n\n53\n00:02:33.980 --> 00:02:35.714\nSo this is become pretty ubiquitous.\n\n54\n00:02:35.714 --> 00:02:38.393\nSo Microsoft,\nrecognizing this is important,\n\n55\n00:02:38.393 --> 00:02:42.721\nhave introduced features inside of\nTransact-SQL, so we can work with this.\n\n56\n00:02:42.721 --> 00:02:45.850\nNow JSON is an industry standard.\n\n57\n00:02:45.850 --> 00:02:50.777\nIt's not an ANSI standard yet,\nbut it is RFC 8259 with the IEEE.\n\n58\n00:02:50.777 --> 00:02:54.914\nSo that means that if you're receiving\nJSON-formatted data from a third party\n\n59\n00:02:54.914 --> 00:02:58.460\ncompany, the odds are you'll\nbe able to handle it in SQL.\n\n60\n00:02:58.460 --> 00:03:00.174\nAnd in SQL if we generate JSON data,\n\n61\n00:03:00.174 --> 00:03:04.078\nthe odds are we can hand that to somebody\nelse and they'll be able to handle that.\n\n62\n00:03:04.078 --> 00:03:06.151\nSo it makes for a great language for\n\n63\n00:03:06.151 --> 00:03:09.663\nhanding off information\nbetween the different systems.\n\n64\n00:03:09.663 --> 00:03:14.360\nIf you look at a JSON file or\nthe JSON data, it's really pretty simple.\n\n65\n00:03:14.360 --> 00:03:16.671\nYou've got attributes and values, right?\n\n66\n00:03:16.671 --> 00:03:20.814\nSo I might have first name,\nDon, last name, Pezet, right?\n\n67\n00:03:20.814 --> 00:03:24.439\n[INAUDIBLE] And they're represented in a\ncertain format that the computer expects,\n\n68\n00:03:24.439 --> 00:03:25.620\nand it can look and define.\n\n69\n00:03:25.620 --> 00:03:30.469\nAnd it even does basic data typing,\nalthough the data typing it doesn't say\n\n70\n00:03:30.469 --> 00:03:33.588\nlike, as int or as and\nvariable character 50.\n\n71\n00:03:33.588 --> 00:03:36.390\nIt just says, hey, if it's in\ndouble quotes then it's a texture,\n\n72\n00:03:36.390 --> 00:03:39.630\nif it's not then it's a number,\nand if it's a slash, it's escape.\n\n73\n00:03:39.630 --> 00:03:43.232\nSo it's some basic data typing that's\nfound inside of it to make sure that\n\n74\n00:03:43.232 --> 00:03:45.394\nthe information is represented properly.\n\n75\n00:03:45.394 --> 00:03:50.647\nSo that's basically what JSON is and\nit is used by Node.js,\n\n76\n00:03:50.647 --> 00:03:54.870\nby Docker,\njust tons of different systems now,\n\n77\n00:03:54.870 --> 00:03:58.683\nthat are supertech buzzwords in 2018.\n\n78\n00:03:58.683 --> 00:04:02.848\nSo that is something we definitely wanna\nlearn about cuz you'll likely use it out\n\n79\n00:04:02.848 --> 00:04:03.899\nthere in the field.\n\n80\n00:04:03.899 --> 00:04:07.287\n&gt;&gt; So Don,\nhow do we use JSON with Transact-SQL?\n\n81\n00:04:07.287 --> 00:04:11.649\n&gt;&gt; Well, Microsoft has some tools built\nright in to Transact-SQL that we can take\n\n82\n00:04:11.649 --> 00:04:15.049\nadvantage of that will basically\nrepresent our data as JSON.\n\n83\n00:04:15.049 --> 00:04:17.873\nSo let me show you a standard query,\nso here I've got a query.\n\n84\n00:04:17.873 --> 00:04:22.375\nAnd this is one we did in the previous\nepisode where I was trying to generate\n\n85\n00:04:22.375 --> 00:04:26.675\na list of my sales people and\nhow big a bonus they got last year, right?\n\n86\n00:04:26.675 --> 00:04:30.110\nSo this query, it's just a simple join,\nnothing too fancy.\n\n87\n00:04:30.110 --> 00:04:35.551\nI'm ordering it by the bonus, until I can\nsee where Tsvi Reiter got a $6700 bonus.\n\n88\n00:04:35.551 --> 00:04:39.032\nAnd it ticks all the way down to the\nbottom of the list where there were a few\n\n89\n00:04:39.032 --> 00:04:41.731\nemployees who had nothing,\nmaybe they were new or bad.\n\n90\n00:04:41.731 --> 00:04:44.082\n&gt;&gt; [LAUGH]\n&gt;&gt; So one way or the other, so\n\n91\n00:04:44.082 --> 00:04:46.418\nthat's just a standard query.\n\n92\n00:04:46.418 --> 00:04:49.984\nWhen it's returned to me,\nit's returned as a SQL data table and\n\n93\n00:04:49.984 --> 00:04:52.040\nthe query analyzer can handle that.\n\n94\n00:04:52.040 --> 00:04:57.140\nAnd if I have an application that's using\nthe SQL native client, it can handle that.\n\n95\n00:04:57.140 --> 00:04:59.130\nBut if I've got a third\nparty application or\n\n96\n00:04:59.130 --> 00:05:03.460\nan in-house built application that's\nexpecting JSON, this doesn't help it.\n\n97\n00:05:03.460 --> 00:05:06.070\nAnd I might not wanna go and\nincorporate the SQL native library,\n\n98\n00:05:06.070 --> 00:05:07.400\ncuz that's a lot of work.\n\n99\n00:05:07.400 --> 00:05:11.556\nSo I could just tell the SQL Server,\nhey, can you give me this data and\n\n100\n00:05:11.556 --> 00:05:13.718\nrepresent it as JSON data, right?\n\n101\n00:05:13.718 --> 00:05:18.089\nNow to do that, the easiest example,\nwe can just add one line,\n\n102\n00:05:18.089 --> 00:05:20.081\nat the very end of the query.\n\n103\n00:05:20.081 --> 00:05:22.480\nSo you write your query just like normal.\n\n104\n00:05:22.480 --> 00:05:28.138\nYou could then say FOR JSON AUTO, right?\n\n105\n00:05:28.138 --> 00:05:32.201\nWhich means look at the query and\nuse the tables that\n\n106\n00:05:32.201 --> 00:05:38.200\nare referencing to automatically\nformat this data as JSON data.\n\n107\n00:05:38.200 --> 00:05:42.177\nAnd normally when I run a query like this,\nI would get a table back,\n\n108\n00:05:42.177 --> 00:05:46.599\nbut when I run this query I get a simple\nblock of information here, right?\n\n109\n00:05:46.599 --> 00:05:50.745\nAnd if you watch the XML show, what I\ndid next is I would click on this and\n\n110\n00:05:50.745 --> 00:05:55.270\nthe query analyzer would give you a nice\nbig rendering of what that data was.\n\n111\n00:05:55.270 --> 00:05:59.723\nUnfortunately query analyzer doesn't\nunderstand JSON, no, it's not yet,\n\n112\n00:05:59.723 --> 00:06:02.587\nmay be that will come in SQL 2019 or\nsomething.\n\n113\n00:06:02.587 --> 00:06:04.174\n&gt;&gt; [LAUGH]\n&gt;&gt; But as since it doesn't,\n\n114\n00:06:04.174 --> 00:06:07.770\nso if I click on it, it's not gonna\ngive me a nice neat representation like\n\n115\n00:06:07.770 --> 00:06:12.150\nit did with XML, with like a little\ncollapsible trees and all that stuff.\n\n116\n00:06:12.150 --> 00:06:16.050\nSo what I normally end up doing is kind\nof having to mess around with this data\n\n117\n00:06:16.050 --> 00:06:20.440\na little bit to get it where it's legible\nand I can understand what I'm looking at.\n\n118\n00:06:20.440 --> 00:06:24.430\nAs you look at this information,\nI can see business entity id for somebody.\n\n119\n00:06:24.430 --> 00:06:28.549\nAnd it goes along until I hit a comma for\nthe next person.\n\n120\n00:06:28.549 --> 00:06:30.497\nAnd as I look at this information,\n\n121\n00:06:30.497 --> 00:06:33.799\nactually that's a square\nbracket here in the beginning.\n\n122\n00:06:34.910 --> 00:06:39.095\nAs I look at this information, it starts\nto make a little more sense, or at least\n\n123\n00:06:39.095 --> 00:06:43.103\nappears a little more clear once I start\nbreaking it up into multiple lines.\n\n124\n00:06:43.103 --> 00:06:48.130\nYou can see where each one of these lines\nare representing one of my sales people.\n\n125\n00:06:48.130 --> 00:06:52.620\nAnd inside of each line,\nyou can see an attribute and\n\n126\n00:06:52.620 --> 00:06:55.100\na value, BusinessEntityID is an attribute.\n\n127\n00:06:55.100 --> 00:06:55.660\nWhat's the value?\n\n128\n00:06:55.660 --> 00:06:58.589\nWell, for row one,\nthe value is 279, right?\n\n129\n00:06:58.589 --> 00:07:01.986\nAnd then the bonus,\nwell that's an attribute, and the value?\n\n130\n00:07:01.986 --> 00:07:05.137\n$6,700, now I don't know\nthat it's dollars, right?\n\n131\n00:07:05.137 --> 00:07:06.760\nBut I do know that that's a number.\n\n132\n00:07:06.760 --> 00:07:08.990\nSee, all the numbers are not in quotes.\n\n133\n00:07:08.990 --> 00:07:12.894\nBut then like first name,\nTsvi is in quotes.\n\n134\n00:07:12.894 --> 00:07:18.148\nThat's it telling, hey, it's a text stream\ndata type versus a numeric data type.\n\n135\n00:07:18.148 --> 00:07:22.019\nSo that's the basic typing that JSON does.\n\n136\n00:07:22.019 --> 00:07:24.659\nBut it's basically just\nlaying it out here and\n\n137\n00:07:24.659 --> 00:07:27.036\neach entry has its own little value here.\n\n138\n00:07:27.036 --> 00:07:28.857\nIt's very, very similar to XML.\n\n139\n00:07:28.857 --> 00:07:31.054\nAnd because it's just straight up text,\n\n140\n00:07:31.054 --> 00:07:34.398\nit doesn't take a massively\ncomplex library to support this.\n\n141\n00:07:34.398 --> 00:07:36.536\nSo I thought I only had 17 salespeople,\n\n142\n00:07:36.536 --> 00:07:38.867\nI feel like I've been doing this for\nan hour.\n\n143\n00:07:38.867 --> 00:07:40.929\n&gt;&gt; [LAUGH]\n&gt;&gt; So basically it lays it out here.\n\n144\n00:07:40.929 --> 00:07:45.392\nAnd the information that's being returned\nto me is all right there, right?\n\n145\n00:07:45.392 --> 00:07:49.756\nAnd it's even indicating where some of\nthe data came from, like this p here.\n\n146\n00:07:49.756 --> 00:07:51.999\nNotice how the p is preceded or\n\n147\n00:07:51.999 --> 00:07:56.678\nfollowed by a square bracket\nletting me know this is an array.\n\n148\n00:07:56.678 --> 00:08:01.473\nHere's an array of all the data that\ncame from the person.person table.\n\n149\n00:08:01.473 --> 00:08:04.017\nI got FirstName and\nLastName from Person.Person.\n\n150\n00:08:04.017 --> 00:08:10.050\nI got BusinessEntityID and Bonus, those\ncame from the Sales.Salesperson table.\n\n151\n00:08:10.050 --> 00:08:14.110\nSo it separated those so that I could see\nthat, that yeah this is data that came\n\n152\n00:08:14.110 --> 00:08:18.600\nfrom two different places, and\nit's denoted right in there.\n\n153\n00:08:18.600 --> 00:08:22.590\nThat's what JSON does,\ntries to keep things simple, easy, and\n\n154\n00:08:22.590 --> 00:08:24.990\nready to be parsed by any application.\n\n155\n00:08:24.990 --> 00:08:27.750\n&gt;&gt; So that's it just FOR\nJSON AUTO and we're done?\n\n156\n00:08:28.750 --> 00:08:31.799\n&gt;&gt; Maybe, so yeah, technically\nyou take that query that I wrote.\n\n157\n00:08:31.799 --> 00:08:34.024\n&gt;&gt; [LAUGH]\n&gt;&gt; Like, all I did was add FOR\n\n158\n00:08:34.024 --> 00:08:35.260\nJSON AUTO and we were done.\n\n159\n00:08:35.260 --> 00:08:37.249\nBut there are some things that\nme might wanna tweak, right,\n\n160\n00:08:37.249 --> 00:08:39.240\nthere's some options and\nstuff that we might wanna modify.\n\n161\n00:08:39.240 --> 00:08:41.279\nAnd in fact if you were looking\nat my information here,\n\n162\n00:08:42.340 --> 00:08:46.020\nI've got a square bracket at the beginning\nand a square bracket at the end.\n\n163\n00:08:46.020 --> 00:08:52.070\nOkay, that means that this entire data\nset is being provided as an array,\n\n164\n00:08:52.070 --> 00:08:53.370\nas a single array.\n\n165\n00:08:53.370 --> 00:08:55.840\nNow in your application,\nyou might take that array and\n\n166\n00:08:55.840 --> 00:08:59.820\nstore it into a variable and then start\nto work with it from there, right.\n\n167\n00:08:59.820 --> 00:09:02.160\nBut in your application,\nyou might not want it as an array.\n\n168\n00:09:02.160 --> 00:09:05.680\nSo we might tell it not to include\nthose square brackets, and\n\n169\n00:09:05.680 --> 00:09:06.770\njust give me the rest of the data.\n\n170\n00:09:06.770 --> 00:09:10.385\nNow each one is its own entity\ninstead of being one big array.\n\n171\n00:09:10.385 --> 00:09:12.210\nMy application would have to expect that.\n\n172\n00:09:12.210 --> 00:09:14.100\nBut if I wanna tweak that,\nthat's not so hard.\n\n173\n00:09:14.100 --> 00:09:19.154\nI just come back here to the FOR\nJSON AUTO, and\n\n174\n00:09:19.154 --> 00:09:26.087\nI add a comma, and\nthen I just say WITHOUT_ARRAY_WRAPPER.\n\n175\n00:09:26.087 --> 00:09:29.560\nAnd when I run that,\nI'm gonna get the same data back.\n\n176\n00:09:29.560 --> 00:09:33.660\nBut if you look, you can see where\nthat square bracket is gone, right.\n\n177\n00:09:33.660 --> 00:09:38.880\nSo if I look at it right now,\nI start with a curly brace, right.\n\n178\n00:09:38.880 --> 00:09:43.260\nAnd if I comment out that\nWITHOUT_ARRAY_WRAPPER and\n\n179\n00:09:43.260 --> 00:09:48.200\nI run it again, I can see where that\nsquare bracket has come back again, right.\n\n180\n00:09:48.200 --> 00:09:51.070\nSo I'm just telling it whether or\nnot I want it to be in an array, or\n\n181\n00:09:51.070 --> 00:09:52.190\nI don't want it to be in a array.\n\n182\n00:09:52.190 --> 00:09:53.730\nI'll take mine out of an array.\n\n183\n00:09:53.730 --> 00:09:57.450\nBut that's an example of one\nmodifier that we might wanna change.\n\n184\n00:09:57.450 --> 00:10:02.321\nSo FOR JSON AUTO might be enough, or\nwe might need to tweak it a little bit to\n\n185\n00:10:02.321 --> 00:10:07.680\nkind of get that working the way that we\nwant it to come in and include everything.\n\n186\n00:10:08.910 --> 00:10:14.830\nAnother example, let's see that was for\nremoving the array wrapper.\n\n187\n00:10:15.910 --> 00:10:17.530\nNull values, right.\n\n188\n00:10:17.530 --> 00:10:19.460\nI might want to show null values.\n\n189\n00:10:19.460 --> 00:10:22.500\nAnd I don't have a whole lot\nof null values in mine, so\n\n190\n00:10:22.500 --> 00:10:25.370\nI didn't really see a great example there.\n\n191\n00:10:25.370 --> 00:10:29.910\nBut if I want to see some null\nvalues on mine, I could go in it and\n\n192\n00:10:29.910 --> 00:10:33.110\nblank one out, and come and\nsee that data, right?\n\n193\n00:10:33.110 --> 00:10:38.610\nSo, for example, let me jump over to\nanother window, here I'll take this one.\n\n194\n00:10:38.610 --> 00:10:45.940\nAnd I'm going to, let's, I'm gonna\nnull out somebody's bonus, right?\n\n195\n00:10:45.940 --> 00:10:48.430\nRight now if somebody didn't get\na bonus they have a zero in there.\n\n196\n00:10:48.430 --> 00:10:52.390\nBut let's say that I just nulled\ntheir bonus altogether, right?\n\n197\n00:10:52.390 --> 00:10:55.310\nWell that column doesn't allow null so\nI need to change that real quick.\n\n198\n00:10:55.310 --> 00:11:01.945\nSo I'll do an ALTER TABLE,\nSales.Salesperson, ALTER COLUMN.\n\n199\n00:11:04.654 --> 00:11:10.364\nI'm gonna alter the Bonus column to be\na money data type that allows nulls,\n\n200\n00:11:10.364 --> 00:11:11.730\nall right.\n\n201\n00:11:11.730 --> 00:11:17.450\nSo ALTER TABLE with only one s,\nand that should fix that.\n\n202\n00:11:17.450 --> 00:11:18.380\nThere, all right.\n\n203\n00:11:18.380 --> 00:11:20.670\nSo now I have allowed nulls.\n\n204\n00:11:20.670 --> 00:11:25.870\nSo I can take somebody's bonus and\nI can go through and I can blank it out.\n\n205\n00:11:26.870 --> 00:11:32.929\nSo Sales.SalesPerson,\nwe'll set Bonus equal to NULL,\n\n206\n00:11:32.929 --> 00:11:37.381\nWHERE, BusinessIdentityID equals and,\n\n207\n00:11:37.381 --> 00:11:42.218\nwhose bonus do we want\nto take away today Zach?\n\n208\n00:11:42.218 --> 00:11:44.550\n&gt;&gt; [LAUGH] I will not say.\n\n209\n00:11:44.550 --> 00:11:47.060\n&gt;&gt; Let's do the leader here\nbecause he's on my screen.\n\n210\n00:11:47.060 --> 00:11:48.194\n&gt;&gt; Okay.\n&gt;&gt; So Tavi Reiter,\n\n211\n00:11:48.194 --> 00:11:52.310\nhe's got that big bonus, $6,700,\nhe's BusinessEntityID 279.\n\n212\n00:11:52.310 --> 00:11:56.141\nSo, I'm gonna knock out his bonus,\nteach him to win.\n\n213\n00:11:56.141 --> 00:11:58.770\nAnd [LAUGH] there we go.\n\n214\n00:11:58.770 --> 00:12:01.604\nSo I'll run that, and\nnow he's got a nulled out bonus,\n\n215\n00:12:01.604 --> 00:12:04.679\nwhich I could probably see,\nwell here we'll just go back and\n\n216\n00:12:04.679 --> 00:12:08.200\nwe'll just query it again and\nwe'll see it in the JSON data.\n\n217\n00:12:08.200 --> 00:12:12.235\nSo normally when I run just\nlike I've got right here.\n\n218\n00:12:12.235 --> 00:12:14.050\n&gt;&gt; Mm-hm.\n&gt;&gt; Null values will get left out.\n\n219\n00:12:14.050 --> 00:12:17.156\nSo see our BusinessEntityID\n279 is first and that's Tavi.\n\n220\n00:12:17.156 --> 00:12:17.850\n&gt;&gt; Mm-hm.\n\n221\n00:12:17.850 --> 00:12:22.400\n&gt;&gt; If I run this query again,\nBusinessEntityID 286 is first, right?\n\n222\n00:12:22.400 --> 00:12:25.377\n&gt;&gt; Okay.\n&gt;&gt; Tavi is gone, he had a null value so\n\n223\n00:12:25.377 --> 00:12:28.140\nwe're not gonna return him.\n\n224\n00:12:28.140 --> 00:12:33.753\nNow, I guess I could try and\nlimit this and\n\n225\n00:12:33.753 --> 00:12:40.662\nsay that I want to pull it\nwhere BusinessEntityID.\n\n226\n00:12:40.662 --> 00:12:45.465\nActually I'll do s, s.BusinessEntityID\n\n227\n00:12:45.465 --> 00:12:50.278\nequals 289, or wait, 279, right.\n\n228\n00:12:50.278 --> 00:12:52.750\nMake sure my BusinessID is right,\nthere we go.\n\n229\n00:12:52.750 --> 00:12:55.006\nAnd kind of pull it in that way,\nand query it.\n\n230\n00:12:55.006 --> 00:12:58.628\nAnd so now I get him coming\nback because I specified him,\n\n231\n00:12:58.628 --> 00:13:01.210\nI specifically said I want you.\n\n232\n00:13:01.210 --> 00:13:04.770\nBut if I don't include that\nthen he'll be left out.\n\n233\n00:13:04.770 --> 00:13:09.340\nAnd if I wanna make sure that I actually\nget those null values in there,\n\n234\n00:13:09.340 --> 00:13:11.650\nI can put this back to the way it was,\nwhoops.\n\n235\n00:13:11.650 --> 00:13:14.690\nAnd I can add another little option here.\n\n236\n00:13:14.690 --> 00:13:21.478\nWhich is going to INCLUDE_NULL_VALUES.\n\n237\n00:13:21.478 --> 00:13:24.630\nInclude underscore null underscore values.\n\n238\n00:13:24.630 --> 00:13:30.328\nAnd so when I run that,\nnow it's gonna generate the data, and\n\n239\n00:13:30.328 --> 00:13:35.491\nif I take a look inside of here and\nI try and find old Tavi.\n\n240\n00:13:35.491 --> 00:13:38.258\nI guess if I sort it he should\nbe down here at the end.\n\n241\n00:13:38.258 --> 00:13:43.080\nThere's Tavi Reiter, and notice that\nhis Bonus is listed as null, right?\n\n242\n00:13:43.080 --> 00:13:45.710\nNow look at that word null real quick,\n\n243\n00:13:45.710 --> 00:13:48.260\nthis helps to identify\nhow JSON is working.\n\n244\n00:13:48.260 --> 00:13:52.900\nIf null were a texturing it would\nhave double quotes around it, right?\n\n245\n00:13:52.900 --> 00:13:54.240\nNumbers don't.\n\n246\n00:13:54.240 --> 00:13:59.440\nWell, here's the word null with no quotes\naround it, so that's how JSON knows,\n\n247\n00:13:59.440 --> 00:14:03.700\nthis isn't the word null, this is\nan actual value, this value is empty.\n\n248\n00:14:03.700 --> 00:14:06.560\nSo by saying include nulls\nthat's what we're doing,\n\n249\n00:14:06.560 --> 00:14:09.970\nand JSON can handle that as long\nas set it up to do it, right.\n\n250\n00:14:09.970 --> 00:14:12.340\nSo that's another option\nthat we need to remember.\n\n251\n00:14:12.340 --> 00:14:15.920\nSo that was WITHOUT_ARRAY_WRAPPER and\nINCLUDE_NULL_VALUES,\n\n252\n00:14:15.920 --> 00:14:19.650\nthose are two modifications we\nmight wanna make to JSON AUTO.\n\n253\n00:14:19.650 --> 00:14:23.942\n&gt;&gt; Is there any way to modify JSON\nif we need something customized?\n\n254\n00:14:23.942 --> 00:14:25.719\n&gt;&gt; Yeah and,\nwell I mean within Linux, right?\n\n255\n00:14:25.719 --> 00:14:28.812\n&gt;&gt; Okay.\n&gt;&gt; So [LAUGH] if we wanna tweak this, like\n\n256\n00:14:28.812 --> 00:14:34.692\nthis formatting, it does some things that\nI know I'm not necessarily a big fun of.\n\n257\n00:14:34.692 --> 00:14:36.721\nLike my data is coming from two tables,\n\n258\n00:14:36.721 --> 00:14:40.780\nand so it's splitting these data\nout into these two tables, right?\n\n259\n00:14:40.780 --> 00:14:43.200\nWhen I looked my resultant set earlier,\n\n260\n00:14:43.200 --> 00:14:46.200\nwhich is parked around here somewhere,\nhere.\n\n261\n00:14:46.200 --> 00:14:49.031\nI've got that p designation there and\nFirstName and\n\n262\n00:14:49.031 --> 00:14:52.740\nLastName are in an array cuz\nthey came from the second table.\n\n263\n00:14:52.740 --> 00:14:56.090\nWell, my JSON application\nprobably doesn't care about that.\n\n264\n00:14:56.090 --> 00:14:57.228\nIt doesn't care where the data comes from,\n\n265\n00:14:57.228 --> 00:14:58.531\nit just needs to know the first name and\nlast name.\n\n266\n00:14:58.531 --> 00:14:59.530\n&gt;&gt; Mm-hm.\n\n267\n00:14:59.530 --> 00:15:01.260\n&gt;&gt; So I might not wanna include that.\n\n268\n00:15:01.260 --> 00:15:05.237\nAnd so very similar to the FOR\nXML command, in FOR\n\n269\n00:15:05.237 --> 00:15:08.740\nJSON AUTO we can switch to pah mode.\n\n270\n00:15:08.740 --> 00:15:11.990\nAnd in path mode we can get in and\nwe can start to manipulate these values,\n\n271\n00:15:11.990 --> 00:15:16.280\nand kinda customize it, and change\nthe way that that data is going to look.\n\n272\n00:15:16.280 --> 00:15:19.220\nAnd if I wanna do that,\nwell, doing like FOR\n\n273\n00:15:19.220 --> 00:15:24.050\nJSON AUTO was really easy, going into\npath mode is really not much harder.\n\n274\n00:15:24.050 --> 00:15:29.800\nI can say FOR\nJSON PATH like that instead of AUTO.\n\n275\n00:15:29.800 --> 00:15:34.740\nAnd when I run that, it's going to start\ndisplaying the information in the form of\n\n276\n00:15:34.740 --> 00:15:39.040\na path, which is a little bit different\nthan what we saw a moment ago.\n\n277\n00:15:39.040 --> 00:15:42.980\nAnd if I take a look at that data and\nkind of, I'll just do a few rows here so\n\n278\n00:15:42.980 --> 00:15:44.490\nwe can see it.\n\n279\n00:15:44.490 --> 00:15:49.810\nAs I look at it I've got BusinessEntityID,\nFirstName, LastName, Bonus.\n\n280\n00:15:49.810 --> 00:15:51.980\nThere's no p designator anymore, right?\n\n281\n00:15:51.980 --> 00:15:54.595\nIt's not identifying there's two tables,\n\n282\n00:15:54.595 --> 00:15:57.842\nit's not using the format of\na query to format the JSON.\n\n283\n00:15:57.842 --> 00:16:00.799\nIt's just saying hey,\nhere's this data that you've got, and\n\n284\n00:16:00.799 --> 00:16:04.551\npresenting it in a path mode where each\none is listing the values for that record.\n\n285\n00:16:04.551 --> 00:16:06.531\nAnd to me,\nthat's usually a lot more desirable.\n\n286\n00:16:06.531 --> 00:16:10.160\nThis is kind of more like the JSON\nthat we're used to seeing.\n\n287\n00:16:10.160 --> 00:16:12.280\nBut it gets it kind of arranged and\n\n288\n00:16:12.280 --> 00:16:17.240\nlaid out there and\nkinda put into a way that we want.\n\n289\n00:16:17.240 --> 00:16:21.491\nAnd we can go a little bit further than\nthat, we don't have to just stop there.\n\n290\n00:16:21.491 --> 00:16:22.819\nNow, I sound like an infomercial.\n\n291\n00:16:22.819 --> 00:16:24.583\n&gt;&gt; [LAUGH] But wait, there's more.\n\n292\n00:16:24.583 --> 00:16:25.210\n&gt;&gt; There we go.\n\n293\n00:16:25.210 --> 00:16:27.733\n&gt;&gt; [LAUGH]\n&gt;&gt; But so I can say for example that I\n\n294\n00:16:27.733 --> 00:16:32.365\nmight want to rename what a value is or\nI might want to nest a value together or\n\n295\n00:16:32.365 --> 00:16:35.470\nI might wanna change\nwhat my route is called.\n\n296\n00:16:35.470 --> 00:16:37.460\nSo these are all additional\nmodifications I can do.\n\n297\n00:16:37.460 --> 00:16:43.770\nFor example, I can say route and\nI'm gonna call this, BonusReport.\n\n298\n00:16:43.770 --> 00:16:46.610\nI'm just putting that in tick marks so\nthe sequel knows that it's a text string.\n\n299\n00:16:46.610 --> 00:16:50.135\nSo I'm gonna create a root element and\nthat root element will be called\n\n300\n00:16:50.135 --> 00:16:53.300\nBonusReport, and everything will\nbe inside of that BonusReport.\n\n301\n00:16:53.300 --> 00:16:57.686\nAnd I could take other things,\nlike first name and\n\n302\n00:16:57.686 --> 00:17:03.146\nlast name and I might wanna\nrename those or nest them, right?\n\n303\n00:17:03.146 --> 00:17:06.800\nI might wanna create an element\ncalled Name, and have FirstName and\n\n304\n00:17:06.800 --> 00:17:08.910\nLastName be underneath Name, right?\n\n305\n00:17:08.910 --> 00:17:16.367\nSo I can take that, and I'll just say\nthat I'm gonna call that AS Name.First.\n\n306\n00:17:16.367 --> 00:17:20.700\nSo now there'll be an element called Name,\nand first will be underneath that.\n\n307\n00:17:20.700 --> 00:17:22.390\nAnd I can do the same thing with last.\n\n308\n00:17:22.390 --> 00:17:26.390\nI'll say AS Name.Last.\n\n309\n00:17:26.390 --> 00:17:30.401\nThat dot is indicating a separator\nbetween these elements, and\n\n310\n00:17:30.401 --> 00:17:33.530\nnow when I run that,\nit's gonna modify it again.\n\n311\n00:17:34.590 --> 00:17:40.855\nAnd when I go in and take a look at these\nentries now, go through, and let's see.\n\n312\n00:17:43.660 --> 00:17:46.370\nI created a root element\nup here at the top, so\n\n313\n00:17:46.370 --> 00:17:48.440\nit's kind of got things\na little off on me.\n\n314\n00:17:48.440 --> 00:17:50.950\nSee how we've got this part\nhere BonusReport, right?\n\n315\n00:17:50.950 --> 00:17:52.500\nThere's that root that I created.\n\n316\n00:17:52.500 --> 00:17:55.560\nAnd then it opens the array,\nand here's my first entity.\n\n317\n00:17:55.560 --> 00:17:58.040\nAnd then after that,\nI get my second entity, and third.\n\n318\n00:17:58.040 --> 00:18:01.565\nAnd as I look at the structure of each\nof these entities, what do I have?\n\n319\n00:18:01.565 --> 00:18:04.330\nBusinessEntityID number, that's normal.\n\n320\n00:18:04.330 --> 00:18:07.280\nName is now up here in element.\n\n321\n00:18:07.280 --> 00:18:11.580\nAnd underneath it, there's first and\nlast included, right?\n\n322\n00:18:11.580 --> 00:18:15.010\nAnd then after that is bonus as its own,\nnot underneath name.\n\n323\n00:18:15.010 --> 00:18:17.991\nAnd so now I can start to\nsee those structured the way\n\n324\n00:18:17.991 --> 00:18:19.800\nthat I want them to be, right?\n\n325\n00:18:19.800 --> 00:18:22.580\nIt's up to us,\nwe can tell SQL to kinda rearrange this.\n\n326\n00:18:22.580 --> 00:18:25.475\nSo what we normally do is, we look at our\nthird party application and we say okay,\n\n327\n00:18:25.475 --> 00:18:27.160\nwhat does it expect?\n\n328\n00:18:27.160 --> 00:18:31.140\nAnd then we can come in and we can\nstart to change all of these names or\n\n329\n00:18:31.140 --> 00:18:34.560\nidentifiers or whatever, to match\nwhat that application expects, and\n\n330\n00:18:34.560 --> 00:18:36.990\nnow we can just generate\nthe JSON that it wants.\n\n331\n00:18:36.990 --> 00:18:41.335\nAnd give it to it in a format that it\nis ready to rock with right out of\n\n332\n00:18:41.335 --> 00:18:42.211\nthe server.\n\n333\n00:18:42.211 --> 00:18:46.829\n&gt;&gt; So, we've been JSON as output but\ncan we use JSON as input also?\n\n334\n00:18:46.829 --> 00:18:47.947\n&gt;&gt; Yeah, yeah, you can.\n\n335\n00:18:47.947 --> 00:18:50.730\nThe hardest part on JSON's input is\njust getting it into the system.\n\n336\n00:18:50.730 --> 00:18:52.610\nSo maybe it's coming from a text file,\n\n337\n00:18:52.610 --> 00:18:54.870\nmaybe it's coming from\na variable in an application.\n\n338\n00:18:54.870 --> 00:18:58.730\nBut once you get the JSON to the system,\nit can work with it, right?\n\n339\n00:18:58.730 --> 00:19:03.400\nSo we have the Xquery functions,\nwhich are special functions that let you\n\n340\n00:19:03.400 --> 00:19:06.850\nreach inside of text, and\ntreat it as some other type of data.\n\n341\n00:19:06.850 --> 00:19:08.620\nAnd we can leverage that\nto look at JSON data.\n\n342\n00:19:08.620 --> 00:19:10.800\nWe do the same with XML, right?\n\n343\n00:19:10.800 --> 00:19:13.250\nWait, we can open that stuff up.\n\n344\n00:19:13.250 --> 00:19:18.280\nOne big difference, though,\nin the XML world, we had the OpenQuery\n\n345\n00:19:18.280 --> 00:19:22.080\ncommand that we would use, that would\nopen up and let us call in XQuery.\n\n346\n00:19:22.080 --> 00:19:26.060\nHere, we actually have a specific\ncommand called OPENJSON.\n\n347\n00:19:26.060 --> 00:19:30.420\nAnd, you can use OPENJSON to crack\nopen a query, get the data out of it,\n\n348\n00:19:30.420 --> 00:19:31.090\nand return it.\n\n349\n00:19:31.090 --> 00:19:35.500\nSo, let me show you an example of that,\nI'm gonna just do an all new one here.\n\n350\n00:19:35.500 --> 00:19:37.610\nLet's say that I had some JSON data.\n\n351\n00:19:37.610 --> 00:19:38.950\nSomebody sent it to me.\n\n352\n00:19:38.950 --> 00:19:43.440\nI could, here I'll just copy\nsome of what we've already seen.\n\n353\n00:19:43.440 --> 00:19:48.073\nSo I'll have business entity, id, for\n\n354\n00:19:48.073 --> 00:19:51.080\nsomebody will be 283.\n\n355\n00:19:51.080 --> 00:19:57.835\nI'll do a FirstName which will be John and\n\n356\n00:19:57.835 --> 00:20:03.046\na LastName, which will be Doe,\n\n357\n00:20:03.046 --> 00:20:07.678\nand a Bonus, which will be,\n\n358\n00:20:07.678 --> 00:20:12.903\nI don't know, $3,500.\n\n359\n00:20:12.903 --> 00:20:15.900\nAll right, so\nthere' s a little bit of JSON, right?\n\n360\n00:20:15.900 --> 00:20:20.760\nAnd I just type it up, whatever you\nguys have, you bring into the system.\n\n361\n00:20:20.760 --> 00:20:24.140\nSo if have that data, and\nmaybe stored in the variable, right?\n\n362\n00:20:24.140 --> 00:20:27.120\nSo I can declare a variable and\nstick it in there or whatever.\n\n363\n00:20:27.120 --> 00:20:30.330\nBut then I just need to tell\nthe system to be able to work with it.\n\n364\n00:20:30.330 --> 00:20:32.240\nSo to work with it, well,\nhere you know what?\n\n365\n00:20:32.240 --> 00:20:34.320\nI will stick it in the variable.\n\n366\n00:20:34.320 --> 00:20:37.620\nSo I'll declare a variable,\nwhich I'll just call jsondata,\n\n367\n00:20:37.620 --> 00:20:41.020\nbut again you can call\nit whatever you wanted.\n\n368\n00:20:41.020 --> 00:20:44.104\nIt's text, so I'm gonna use NVARCHAR MAX,\n\n369\n00:20:44.104 --> 00:20:47.527\nwhich means that it can hold\nas much text as I want.\n\n370\n00:20:47.527 --> 00:20:52.681\nThen I'll just SET @jsondata=,\n\n371\n00:20:52.681 --> 00:20:57.146\nand then I'm gonna go ahead and\n\n372\n00:20:57.146 --> 00:21:01.980\ngrab in that text, right there.\n\n373\n00:21:01.980 --> 00:21:03.110\nOkay, so I'm gonna pop it in the variable.\n\n374\n00:21:04.410 --> 00:21:09.240\nQuick bit of advice here,\nalmost all Jsondata uses Unicode.\n\n375\n00:21:09.240 --> 00:21:12.900\nAnd Unicode characters are really\nimportant today because of other\n\n376\n00:21:12.900 --> 00:21:15.580\nlanguages and special accents and\nthings like that.\n\n377\n00:21:15.580 --> 00:21:17.780\nSQL doesn't default to Unicode.\n\n378\n00:21:17.780 --> 00:21:22.000\nSo if I leave it just like it is,\nUnicode characters might be a problem.\n\n379\n00:21:22.000 --> 00:21:26.630\nSo whenever you ingest JSON,\nit's a good idea to stick a capital N,\n\n380\n00:21:26.630 --> 00:21:28.600\nright before the text field.\n\n381\n00:21:28.600 --> 00:21:32.005\nAnd that let's it know that you're gonna\nsupport Unicode characters inside of it,\n\n382\n00:21:32.005 --> 00:21:32.880\nright?\n\n383\n00:21:32.880 --> 00:21:36.520\nWe used to not worry about this stuff but\nin today's day and age where everybody is\n\n384\n00:21:36.520 --> 00:21:39.630\nin international business,\nyou really need to think about that.\n\n385\n00:21:39.630 --> 00:21:41.580\nSo I'm gonna stick that N\nright at the beginning.\n\n386\n00:21:41.580 --> 00:21:44.860\nSo that's what that means is I'm gonna\nbe accepting Unicode characters.\n\n387\n00:21:44.860 --> 00:21:45.460\n&gt;&gt; Good to know.\n\n388\n00:21:46.500 --> 00:21:48.822\n&gt;&gt; Yeah, that's a fun one to troubleshoot,\n\n389\n00:21:48.822 --> 00:21:49.820\ncuz you-\n&gt;&gt; Yeah.\n\n390\n00:21:49.820 --> 00:21:52.860\n&gt;&gt; We do our troubleshooting and\ntesting in the language that we speak, so\n\n391\n00:21:52.860 --> 00:21:54.849\nif I test it in English\neverything works fine.\n\n392\n00:21:54.849 --> 00:21:58.389\nAnd then the first Spanish user\nthat comes along, the thing breaks,\n\n393\n00:21:58.389 --> 00:22:00.410\nand down, I gotta deal with it.\n\n394\n00:22:00.410 --> 00:22:01.320\nSo better to plan ahead.\n\n395\n00:22:01.320 --> 00:22:03.740\nAll right, so\nI've got that data stuck in a variable.\n\n396\n00:22:03.740 --> 00:22:06.180\nHow you get it to the variable\njust depends on your application.\n\n397\n00:22:06.180 --> 00:22:10.980\nBut once it's there,\nI can now use OPENJSON.\n\n398\n00:22:10.980 --> 00:22:14.040\nI could say SELECT * FROM.\n\n399\n00:22:14.040 --> 00:22:16.870\nAnd instead of pointing to a table,\nI can say OPENJSON.\n\n400\n00:22:17.980 --> 00:22:22.770\nAnd then I can provide it that\njsondata that I'm gonna pull, right?\n\n401\n00:22:22.770 --> 00:22:25.180\nSo I'm gonna point to that variable,\nright?\n\n402\n00:22:25.180 --> 00:22:28.500\nSo that's what it's gonna open up and\nreturn back from me, right?\n\n403\n00:22:28.500 --> 00:22:32.750\nIf I run this, well,\nthis JSON goes into the variable,\n\n404\n00:22:32.750 --> 00:22:35.920\nit queries against it and\nthen it outputs it on my screen, right?\n\n405\n00:22:35.920 --> 00:22:37.570\nIt's not too fancy.\n\n406\n00:22:37.570 --> 00:22:41.600\nBut if I run it,\nthere it goes and I get my data.\n\n407\n00:22:41.600 --> 00:22:44.150\nNow, when I pull it up like this though\n\n408\n00:22:45.190 --> 00:22:47.600\nit's not represented the way\nyou might think, right?\n\n409\n00:22:47.600 --> 00:22:53.100\nObviously it did access the jsondata and\nit did render it here as a table.\n\n410\n00:22:53.100 --> 00:22:55.450\nI see the information that I wanted.\n\n411\n00:22:55.450 --> 00:22:59.620\nBut the way it's represented is a lot\ndifferent than we're used to in SQL.\n\n412\n00:22:59.620 --> 00:23:02.350\nAnd the main reason is the data types,\nright?\n\n413\n00:23:03.640 --> 00:23:06.240\nIn JSON data typing is really simple.\n\n414\n00:23:06.240 --> 00:23:09.520\nYou have text versus numbers, right?\n\n415\n00:23:09.520 --> 00:23:13.410\nIn SQL we have eight\ndifferent types of text and\n\n416\n00:23:13.410 --> 00:23:16.840\neight different types of numbers and\njust tons of variations.\n\n417\n00:23:16.840 --> 00:23:21.390\nSo what it's showing me here, is on\nthe left side the key or attribute and\n\n418\n00:23:21.390 --> 00:23:22.940\nthen the value.\n\n419\n00:23:22.940 --> 00:23:27.350\nAnd then based on what JSON was telling\nus, whether it was a number or a string.\n\n420\n00:23:27.350 --> 00:23:30.010\nIf it's a one it was a string,\nif it was a two it was a number, right?\n\n421\n00:23:30.010 --> 00:23:32.570\nWhich is the loose data type, right?\n\n422\n00:23:32.570 --> 00:23:35.730\nSo that's what it's giving me back here so\nI know what that information is.\n\n423\n00:23:35.730 --> 00:23:40.130\nWell, that means that just querying it\nlike this isn't necessarily going to meet\n\n424\n00:23:40.130 --> 00:23:41.500\nall of my needs.\n\n425\n00:23:41.500 --> 00:23:44.400\nI might need to manipulate\nthis data some more.\n\n426\n00:23:44.400 --> 00:23:47.020\nI might have to pivot it to get\nsome of the information I want or\n\n427\n00:23:47.020 --> 00:23:48.970\nleverage other things.\n\n428\n00:23:48.970 --> 00:23:53.128\nI usually don't pull all of the data\nwhen I query Json like this,\n\n429\n00:23:53.128 --> 00:23:57.762\nI'm normally after something specific\nlike FirstName and LastName.\n\n430\n00:23:57.762 --> 00:24:01.296\nAnd so I'm gonna put those in\nas like column headers, right?\n\n431\n00:24:01.296 --> 00:24:06.018\nAnd when I query it that way well,\nI get invalid column name.\n\n432\n00:24:06.018 --> 00:24:08.780\nThat it wasn't able to find FirstName or\nLastName.\n\n433\n00:24:08.780 --> 00:24:14.340\nThat basically, when it goes to look at\nit, those aren't the column names, right?\n\n434\n00:24:14.340 --> 00:24:19.630\nThose are going to be what we\nsaw just a moment ago, here.\n\n435\n00:24:19.630 --> 00:24:20.730\nOops, that worked.\n\n436\n00:24:21.826 --> 00:24:24.400\n&gt;&gt; [LAUGH]\n&gt;&gt; Seems like it would require a space\n\n437\n00:24:24.400 --> 00:24:26.140\nthere, but I guess I figured it out.\n\n438\n00:24:26.140 --> 00:24:29.870\nThe column names are key,\nvalue, type, right?\n\n439\n00:24:29.870 --> 00:24:32.680\nSo that's a little bit of a problem\nwith the way that data comes in.\n\n440\n00:24:32.680 --> 00:24:35.380\nAnd a lot of this functionality\nis still new to Microsoft,\n\n441\n00:24:35.380 --> 00:24:37.090\nthey're still kind of rolling it out.\n\n442\n00:24:37.090 --> 00:24:39.920\nAnd so they are adding\ncapabilities to work with this.\n\n443\n00:24:39.920 --> 00:24:44.890\nBut in the meantime, when it comes in,\nbasically your column\n\n444\n00:24:44.890 --> 00:24:47.153\nnames are on the left side and\nyour values are in the middle.\n\n445\n00:24:47.153 --> 00:24:50.230\nAnd so you may need to leverage\na pivot on this as well.\n\n446\n00:24:50.230 --> 00:24:53.873\nAnd we did an episode on pivots already\non how to turn that data on its side.\n\n447\n00:24:53.873 --> 00:24:55.130\n&gt;&gt; Yeah, we did.\n\n448\n00:24:55.130 --> 00:24:57.280\n&gt;&gt; We might not necessarily\ncare about the types.\n\n449\n00:24:57.280 --> 00:24:59.430\nMaybe we do care about the types,\nit's up to us.\n\n450\n00:24:59.430 --> 00:25:02.460\nWe could calculate insert statements\nbased on this information.\n\n451\n00:25:02.460 --> 00:25:06.130\nWe could feed this into a custom function\nthat then did whatever we wanted\n\n452\n00:25:06.130 --> 00:25:06.720\nwith the data.\n\n453\n00:25:06.720 --> 00:25:11.160\nThe important part though is\nthat we were able to thrash\n\n454\n00:25:11.160 --> 00:25:16.330\nthrough the JSON and\nactually generate tabular data out of it.\n\n455\n00:25:16.330 --> 00:25:19.600\nAnd once you got tabular data, you can\nwork with it just like any other SQL data.\n\n456\n00:25:19.600 --> 00:25:24.080\nYou don't need special tools or skills to\nwork with that, you can just reach in and\n\n457\n00:25:24.080 --> 00:25:25.890\ngrab that information.\n\n458\n00:25:25.890 --> 00:25:29.320\nBut let me show you one little trick\nthat can save you some time as far as\n\n459\n00:25:29.320 --> 00:25:30.390\ndoing the pivot.\n\n460\n00:25:30.390 --> 00:25:35.750\nI'm gonna put the FirstName and\nLastName back in.\n\n461\n00:25:35.750 --> 00:25:42.650\nAnd if that's legitimately all that I\nreally want, I can add WITH, and I can\n\n462\n00:25:42.650 --> 00:25:46.400\ntell it the structure so it understands\nwhat the heck I'm talking about.\n\n463\n00:25:46.400 --> 00:25:51.600\nAnd I can throw this in here and\njust say that FirstName\n\n464\n00:25:51.600 --> 00:25:55.410\nis a n variable character and\nI'm just gonna do 50 this time,\n\n465\n00:25:55.410 --> 00:25:58.720\ncuz I know it's a name,\nit's not gonna be terribly long.\n\n466\n00:25:58.720 --> 00:26:01.870\nAnd then I can tell it how to find it.\n\n467\n00:26:01.870 --> 00:26:05.736\nAnd I'm gonna say that you\ncan find it by looking at $,\n\n468\n00:26:05.736 --> 00:26:09.140\nwhich means the variable data, .FirstName.\n\n469\n00:26:09.140 --> 00:26:14.430\nThat's what it's called inside of the JSON\ndata, it's just called FirstName.\n\n470\n00:26:14.430 --> 00:26:17.290\nIf it was nested,\nmy example a moment ago where I had name,\n\n471\n00:26:17.290 --> 00:26:18.700\nand underneath name was first,\n\n472\n00:26:18.700 --> 00:26:23.340\nthen I would have to say $.name.first so\nthat it could find it in the path.\n\n473\n00:26:23.340 --> 00:26:25.260\nSo I'm gonna specify that.\n\n474\n00:26:25.260 --> 00:26:27.098\nAnd then I'll do the same thing for\nLastName.\n\n475\n00:26:27.098 --> 00:26:29.237\nRight here.\n\n476\n00:26:33.391 --> 00:26:36.530\nAnd I'll tell it how to find that,\nthe same basic process.\n\n477\n00:26:36.530 --> 00:26:39.570\nLastName, there.\n\n478\n00:26:39.570 --> 00:26:41.240\nAnd then I'll just close that one out.\n\n479\n00:26:42.390 --> 00:26:44.950\nSo by doing this,\n\n480\n00:26:44.950 --> 00:26:48.680\nI help the system to understand what\nthat data is, and then it can find it.\n\n481\n00:26:48.680 --> 00:26:50.750\nI just have to map those columns so\n\n482\n00:26:50.750 --> 00:26:53.400\nthat it can figure out where the heck\nthey are and what they mean.\n\n483\n00:26:53.400 --> 00:26:59.390\nAnd when I run that, now the data\ncomes back in a format like I want it.\n\n484\n00:26:59.390 --> 00:27:01.160\nAnd I didn't have to do a pivot, did I?\n\n485\n00:27:01.160 --> 00:27:03.240\nI could have.\n\n486\n00:27:03.240 --> 00:27:08.973\nBut here it saved me a little bit of time\nand it allowed me to apply data types.\n\n487\n00:27:08.973 --> 00:27:10.501\nPivots don't do data types, so\n\n488\n00:27:10.501 --> 00:27:14.075\nthat can cause some problems when your\ndata doesn't actually have a type.\n\n489\n00:27:14.075 --> 00:27:16.975\nYou could end up with a type that's\nnot right for what you want.\n\n490\n00:27:16.975 --> 00:27:20.530\nBy doing it using the WITH operator\nwe can actually get in and fix that.\n\n491\n00:27:20.530 --> 00:27:22.598\nSo I'll usually use this\nif I'm in a hurry and\n\n492\n00:27:22.598 --> 00:27:26.036\nI don't want to do anything else too\ncrazy like writing a custom function.\n\n493\n00:27:26.036 --> 00:27:28.610\nThis will typically give\nme exactly what I want.\n\n494\n00:27:28.610 --> 00:27:32.750\nAnd now I've got tabular data that I\ncan work with just like anything else.\n\n495\n00:27:32.750 --> 00:27:34.300\n&gt;&gt; Awesome job as always, Don.\n\n496\n00:27:34.300 --> 00:27:36.290\nAnd that is working with JSON.\n\n497\n00:27:36.290 --> 00:27:37.500\nGreat episode?\n\n498\n00:27:37.500 --> 00:27:40.590\nAnd before we move on,\nanything else you'd like to say?\n\n499\n00:27:40.590 --> 00:27:44.340\n&gt;&gt; In this series we just did JSON,\nwe had another show on XML, you may or\n\n500\n00:27:44.340 --> 00:27:45.150\nmay not have watched it.\n\n501\n00:27:45.150 --> 00:27:47.290\nThe two tools are very, very similar.\n\n502\n00:27:47.290 --> 00:27:51.790\nBut expect to see Microsoft adding\nmore tools like these where, hey,\n\n503\n00:27:51.790 --> 00:27:57.290\nif you're doing stuff native in SQL or\nMicrosoft SQL or whatever, that's great.\n\n504\n00:27:57.290 --> 00:28:00.920\nBut if you're not, you don't necessarily\nhave to change your system or\n\n505\n00:28:00.920 --> 00:28:02.630\nintegrate some custom library.\n\n506\n00:28:02.630 --> 00:28:06.570\nThe odds are that you can take that\ndata in whatever format it is and\n\n507\n00:28:06.570 --> 00:28:08.090\nSQL can use it.\n\n508\n00:28:08.090 --> 00:28:12.790\nBut if you're using some system\nthat isn't supported, so\n\n509\n00:28:12.790 --> 00:28:15.480\nit's some all new text exchange.\n\n510\n00:28:15.480 --> 00:28:18.955\nThere's the SQL Server\nIntegration Services, SSIS.\n\n511\n00:28:18.955 --> 00:28:21.910\n&gt;&gt; Uh-huh.\n&gt;&gt; And it will allow you to take any data\n\n512\n00:28:21.910 --> 00:28:24.670\nand convert it into\nsomething that SQL can use.\n\n513\n00:28:24.670 --> 00:28:27.800\nAnd you actually write\nthe instructions on how to convert it.\n\n514\n00:28:27.800 --> 00:28:30.840\nSo, you can basically teach\nSQL Server a new input type.\n\n515\n00:28:30.840 --> 00:28:31.560\n&gt;&gt; Fantastic.\n\n516\n00:28:31.560 --> 00:28:33.400\n&gt;&gt; That is a solution that's out there.\n\n517\n00:28:33.400 --> 00:28:36.740\nIt's obviously much, much harder than\njust using these, but it is available.\n\n518\n00:28:36.740 --> 00:28:38.530\n&gt;&gt; Thanks Don, great information.\n\n519\n00:28:38.530 --> 00:28:40.890\nQuerying data with Transact-SQL\nis a wonderful series.\n\n520\n00:28:40.890 --> 00:28:43.710\nMake sure you watch every episode,\nyou'll be glad you did.\n\n521\n00:28:43.710 --> 00:28:46.700\nAnd inside that course library,\nthousands of other videos.\n\n522\n00:28:46.700 --> 00:28:49.060\nThey're there to help you go further,\ncheck them out.\n\n523\n00:28:49.060 --> 00:28:51.510\nAnd tell everybody you know about ITProTV.\n\n524\n00:28:51.510 --> 00:28:53.000\nITProTV is bingeworthy.\n\n525\n00:28:53.000 --> 00:28:53.720\nThanks for watching.\n\n526\n00:28:53.720 --> 00:28:54.650\nI'm Zach Memos.\n\n527\n00:28:54.650 --> 00:28:55.420\n&gt;&gt; And I'm Don Pezet.\n\n528\n00:28:55.420 --> 00:28:57.081\n&gt;&gt; And we will see you again soon.\n\n529\n00:28:57.081 --> 00:29:03.938\n[MUSIC]\n\n530\n00:29:03.938 --> 00:29:06.765\n&gt;&gt; Thank you for watching ITProTV.\n\n",
          "vimeoId": "251826117"
        }
      ],
      "title": "Working with JSON and XML"
    }
  ],
  "url": "querying-datatransactsql",
  "vLab": false
}
